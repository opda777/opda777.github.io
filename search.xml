<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019年---小记</title>
    <url>/2020/01/07/2019%E5%B9%B4---%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    在三维动画，交互设计等等的课程实训，我掐指一算已经有两个月没有更新自己的笔记了，没办法，我也不知道为什么我这个专业的实训特别特别得多….其实早就放假啦，自己也摸鱼了一个星期恢复下元气。</p>
<p>​    对于2019我感觉还行，虽然没有参加什么比赛，但是在实训课程的过程中还是学到了很多东西，做出来的成品也让我感到满意，所以希望下一年也再接再厉，希望寒假没有摸鱼，能找到实习就最好了，哈哈哈。</p>
<p>​    加油！！！奥利给！！！</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记cover</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建过程(踩坑)</title>
    <url>/2019/10/30/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​         本文主要用来记录自己Hexo博客搭建过程中遇到的坑。</p>
 <a id="more"></a> 

<h1 id="个人域名篇"><a href="#个人域名篇" class="headerlink" title="个人域名篇"></a>个人域名篇</h1><p>​         这个个人域名的确有点坑，明明按着教程的操作一步一步来的，还是弄了一晚上，到最后才发现是校园网DNS的坑。。。</p>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><p>​        首先我们要购买一个属于自己的域名，可以去腾讯云，阿里云等网站进行购买，这里我在阿里云购买opda.tech，为什么不用com域名，因为这个便宜。</p>
<p>​    购买域名后我们还要得到github仓库的IP。通过cmd命令行，输入Ping 你的名字.github.io获取名字   </p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/2.png" alt></p>
<p>红色箭头所指就是你github仓库的IP，然后我们就可以进行DNS解析。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/1.png" alt></p>
<p>进去之后，点击新手引导，输入cmd获得的IP即可。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/4.png" alt></p>
<p>解析完的结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/11.png" alt></p>
<p>​    </p>
<h2 id="2-github的绑定"><a href="#2-github的绑定" class="headerlink" title="2.github的绑定"></a>2.github的绑定</h2><p>​        进入你创建的仓库内，点击Setting</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/5.png" alt></p>
<p>​        GitHub Pages设置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/6.png" alt></p>
<p>就这样github仓库的绑定就完成啦！</p>
<h2 id="3-最后一步"><a href="#3-最后一步" class="headerlink" title="3.最后一步"></a>3.最后一步</h2><p>我们还要在本地博客的source文件夹下新建一个CNAME.txt文本，在里面输入我们的自定义域名</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/7.png" alt></p>
<p>最后我们Git Base重新部署一下博客就行啦！</p>
<pre><code class="base">hexo clean
hexo g
hexo d</code></pre>
<h2 id="4-深坑"><a href="#4-深坑" class="headerlink" title="4.深坑"></a>4.深坑</h2><p>​        如果你是校园网用户的话，你要小心校园网DNS这个坑，会让你无法访问你自己的域名，所以解决方法就是修改我们的DNS就好了。</p>
<p>打开我们的控制面板—网络共享中心</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/8.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/9.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/10.png" alt></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4--材质大师课程笔记</title>
    <url>/2020/01/11/UE4--%E6%9D%90%E8%B4%A8%E5%A4%A7%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="压缩和内存"><a href="#压缩和内存" class="headerlink" title="压缩和内存"></a>压缩和内存</h2><p>一般来说纹理导入UE4都是经过压缩的，压缩方式有BC(Block Compression块压缩)/DXTC(Directx Texture Compression DirectX纹理压缩)两种，其实都是用于PC的Directx平台的格式。但是法线贴图有点特殊，是无法通过这两种方式进行压缩的。</p>
<a id="more"></a>

<p>​    如下图所示就是贴图导入UE4后所选择的压缩方式。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F.png" alt></p>
<p>压缩方式后面所带的数字表明是不同的压缩格式，例如BC3(DXTC5)表示带透明度的纹理，BC1(DXTC1)表示不带透明度的纹理。</p>
<p>法线贴图的压缩方式是通过剔除蓝色通道的方式进行压缩，这样可以存储更多的数据，同时对红色和绿色通道进行轻度压缩。最后通过对红绿色进行蓝色通道的复原，这些都是UE4内部自己调用的，不用我们去调整。如下图只是进行蓝色通道复原的演示。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE.png" alt></p>
<p>注意的是，法线贴图的导入方式必须是选择NormalMap。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F.png" alt></p>
<h3 id="为什么要对纹理进行压缩"><a href="#为什么要对纹理进行压缩" class="headerlink" title="为什么要对纹理进行压缩"></a>为什么要对纹理进行压缩</h3><p>最主要是因为受限于内存和带宽，如果不对纹理进行压缩，可能导致卡顿。但帧率过低一般和纹理压缩没有什么关系。可以通过查看统计数据，来查看场景中哪些纹理在内存中的大小。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE.png" alt></p>
<h2 id="多级渐进纹理-纹理尺寸和纹理池"><a href="#多级渐进纹理-纹理尺寸和纹理池" class="headerlink" title="多级渐进纹理 纹理尺寸和纹理池"></a>多级渐进纹理 纹理尺寸和纹理池</h2><h3 id="纹理池"><a href="#纹理池" class="headerlink" title="纹理池"></a>纹理池</h3><p>UE4在计算机内存中，会为纹理暴保留一定的空间，这个空间就是纹理池，我们可以手动调整纹理池的大小，当纹理池大小不够用的时候，会导致贴图的分辨率降低，效果下降。</p>
<p>打开控制台，输入r.Streaming.PoolSize查看纹理池大小，并且可以进行修改。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E8%B0%83%E6%95%B4%E7%BA%B9%E7%90%86%E6%B1%A0.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E8%BF%87%E5%B0%8F%E7%BA%B9%E7%90%86%E6%B1%A0.png" alt></p>
<h3 id="Mipmaps-多级渐进纹理"><a href="#Mipmaps-多级渐进纹理" class="headerlink" title="Mipmaps(多级渐进纹理)"></a>Mipmaps(多级渐进纹理)</h3><p>Mipmaps为原始纹理的副本，大小为1/4左右,使用Mipmaps的原因是为了减少噪点的生成。</p>
<p>左侧是使用了Mipmaps，右边没有使用，可以看出右边的噪点非常多，所以Mipmaps可以看成我们手动进行模糊</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Mipmaps.png" alt></p>
<p>UE4会对远处使用不同的Mipmaps来模拟模糊的效果，如下图离镜头最近的就使用Mipmaps0原始纹理，然后随着离镜头越来越远，使用不同的Mipmaps。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/MipmapsLerp.png" alt></p>
<p>可以在贴图的LOD选择中进行Mipmaps的设置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Mipmaps%E8%AE%BE%E7%BD%AE.png" alt></p>
<h4 id="注意纹理尺寸"><a href="#注意纹理尺寸" class="headerlink" title="注意纹理尺寸"></a>注意纹理尺寸</h4><p>使用Mipmaps可以提高我们的性能，加快渲染速度和减少纹理锯齿，但注意不适于2的幂数的纹理无法生成Mipmaps，但是UI纹理可以是任意分辨率，因为UI纹理不会从远处到近处，所以没必要使用Mipmaps。</p>
<h3 id="材质的纹理数限制"><a href="#材质的纹理数限制" class="headerlink" title="材质的纹理数限制"></a>材质的纹理数限制</h3><p>UE4的每个材质的纹理可采样数是16个，加上内部的光影贴图，其实我们可以用的大概是13个左右，其实已经够用了，但是如果要突破这个限制的话，我们可以把不同的贴图合成RGB通道就成为一张贴图，到使用的的时候就可以分RGB通道分为3张贴图。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E8%B4%B4%E5%9B%BE%E5%90%88%E6%88%90.png" alt></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>Maya导出存储文件工具</title>
    <url>/2020/08/31/Maya%E5%AF%BC%E5%87%BA%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>笔记记录</p>
<a id="more"></a>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>保存场景为ma文件，并且可以加载，刷新等。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/GIF%202020-8-31%2015-49-31.gif" alt></p>
<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>主要逻辑在controllerLibrary.py脚本，save，find，load3个方法。创建ControllerLibrary类继承于dict字典类，数据存储name,path,screenshot的相关路径等等。</p>
<p>主要API：cmds.file()进行文件的存储和读取    cmds.viewFit():将摄像机对准物体    cmds.playblast():渲染导出图片    json.dump()：json文件的编码写入    json.load():json文件的解码读取</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20200831160940099.png" alt="image-20200831160940099"></p>
<pre><code>#-*-coding:gbk-*-

from maya import cmds
import os
import json
import pprint

#获取Maya文档路径
USERAPPDIR = cmds.internalVar(userAppDir=True)
#文件夹路径
DIRECTORY = os.path.join(USERAPPDIR, &quot;controllerLibrary&quot;)


def createDirectory(directory=DIRECTORY):
    &quot;&quot;&quot;
    根据文件路径创建文件夹
    Args:
        directory(str): 要创建的文件夹路径

    Returns:

    &quot;&quot;&quot;
    #首先判断文件夹是否存在
    if not os.path.exists(directory):
        #如果不存在那就创建文件夹
        os.mkdir(directory)


#继承字典类
class ControllerLibrary(dict):

    #保存文件方法
    #**info关键字参数
    def save(self,name,screenshot=True,directory=DIRECTORY,**info):

        #首先要确认要保存的路径是否存在
        createDirectory(directory)

        #保存文件路径
        path = os.path.join(directory,&quot;{0}.ma&quot;.format(name))
        #json保存文件
        infoFile = os.path.join(directory,&quot;{0}.json&quot;.format(name))
        info[&quot;name&quot;] = name
        info[&quot;path&quot;] = path

        #判是否需要screenShot
        if screenshot:
            self.saveScreenshot(name,directory)

        #进行场景文件的保存,保存格式为mayaAscii
        cmds.file(rename=path)

        #如果进行了选择，就单独保存选择了的物体场景
        if cmds.ls(selection=True):
            cmds.file(force=True,type=&quot;mayaAscii&quot;,exportSelected=True)

        #否则保存全部场景物体
        else:
            cmds.file(save=True,type=&quot;mayaAscii&quot;,force=True)

        #打开infoFile文件,保存为json格式,写入文件
        with open(infoFile,&quot;w&quot;) as f:
            json.dump(info,f,indent=4)

        self[name] = path

    #获得文件夹下的所有文件
    def find(self,directory=DIRECTORY):
        # 进行清空，避免删除.ma文件时没有更新
        self.clear()

        if not os.path.exists(directory):
            return None

        files = os.listdir(directory)

        #进行特定筛选，只获取ma文件
        mayaFiles = [f for f in files if f.endswith(&quot;.ma&quot;)]

        #进行键值对存储
        for ma in mayaFiles:
            #分离文件名和扩展名
            name,ext = os.path.splitext(ma)
            path = os.path.join(directory,ma)

            #查看是否json文件
            infoFile = &quot;{0}.json&quot;.format(name)
            if infoFile in files:
                infoFile = os.path.join(directory,infoFile)
                #读取每个场景配置的json文件
                with open(infoFile,&quot;r&quot;) as f:
                    #进行读取
                    info = json.load(f)

            else:
                print(u&quot;没有发现{0}文件&quot;.format(infoFile))
                info = {}

            #查看是否screenshot图片
            screenshot = &quot;{0}.jpg&quot;.format(name)
            if screenshot in files:
                info[&quot;screenshot&quot;] = os.path.join(directory,screenshot)

            info[&quot;name&quot;]=name
            info[&quot;path&quot;]=path

            self[name]=info
            #print(info)

    #加载
    def load(self,name):
        path = self[name][&quot;path&quot;]

        #进行加载
        cmds.file(path,i=True,usingNamespaces=False)

    #保存屏幕截图
    def saveScreenshot(self,name,directory=DIRECTORY):
        #确定图片保存的路径
        path = os.path.join(directory,&quot;{0}.jpg&quot;.format(name))

        #将摄像机对准物体，以方便进行截图
        cmds.viewFit()
        #确定保存图片格式为jpg
        cmds.setAttr(&quot;defaultRenderGlobals.imageFormat&quot;,8)

        #进行截图,这个相当于渲染命令
        &quot;&quot;&quot;
        completeFilename:导出图片的路径    forceOverwrite:是否覆盖现有的playblast     format:输出的格式
        width,heigt:分辨率     showOrnaments:是否显示轴坐标图      viewer:是否启动播放查看器
        &quot;&quot;&quot;
        cmds.playblast(completeFilename=path,forceOverwrite=True,format=&quot;image&quot;,width=200,height=200,
                       showOrnaments=False,startTime=1,endTime=1,viewer=False)

        return path

</code></pre><p>主要逻辑构建好，就可以构建UI了，UI构建在libraryUI.py中完成</p>
<pre><code>#-*-coding:gbk-*-

import controllerLibrary
from imp import reload
reload(controllerLibrary)
from PySide2 import QtWidgets,QtCore,QtGui
import maya.OpenMayaUI as omui
import maya.cmds as cmds
from shiboken2 import wrapInstance


#获取maya主窗口
def maya_main_window():
    main_window_ptr = omui.MQtUtil.mainWindow()
    return wrapInstance(long(main_window_ptr),QtWidgets.QWidget)


#ui类
class ControllerLibraryUI(QtWidgets.QDialog):

    #初始化
    def __init__(self,parent=maya_main_window()):
        super(ControllerLibraryUI, self).__init__(parent)
        self.library = controllerLibrary.ControllerLibrary()

        #图标size
        self.size = 64
        #格子Sizd
        self.buffer=12

        #设置窗口标题
        self.setWindowTitle(u&quot;控制Library窗口&quot;)
        #关闭问号按钮
        self.setWindowFlags(self.windowFlags() ^ QtCore.Qt.WindowContextHelpButtonHint)

        self.createWidgets()
        self.createLayouts()
        self.createConnects()

        #填充ListWidget
        self.populate()

    def createWidgets(self):
        self.save_btn = QtWidgets.QPushButton(&quot;save&quot;)
        self.saveName_lineEdit = QtWidgets.QLineEdit()

        #设置listWidget
        self.file_listWidget = QtWidgets.QListWidget()
        #图标模式
        self.file_listWidget.setViewMode(QtWidgets.QListWidget.IconMode)
        #设置图标大小
        self.file_listWidget.setIconSize(QtCore.QSize(self.size,self.size))
        #设置拉伸模式为Adjust
        self.file_listWidget.setResizeMode(QtWidgets.QListWidget.Adjust)
        #设置GridSize
        self.file_listWidget.setGridSize(QtCore.QSize(self.size+self.buffer,self.size+self.buffer))

        self.import_btn = QtWidgets.QPushButton(&quot;Import&quot;)
        self.refresh_btn = QtWidgets.QPushButton(&quot;Refresh&quot;)
        self.close_btn = QtWidgets.QPushButton(&quot;Close&quot;)

    def createLayouts(self):
        main_layout = QtWidgets.QVBoxLayout(self)

        save_layout = QtWidgets.QHBoxLayout()
        save_layout.addWidget(self.saveName_lineEdit)
        save_layout.addWidget(self.save_btn)
        main_layout.addLayout(save_layout)

        main_layout.addWidget(self.file_listWidget)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_layout.addWidget(self.import_btn)
        btn_layout.addWidget(self.refresh_btn)
        btn_layout.addWidget(self.close_btn)
        main_layout.addLayout(btn_layout)



    def createConnects(self):
        self.save_btn.clicked.connect(self.save)

        self.import_btn.clicked.connect(self.load)
        self.refresh_btn.clicked.connect(self.populate)
        self.close_btn.clicked.connect(self.close)

    def populate(self):

        #清空file_list，避免重复增加
        self.file_listWidget.clear()
        #获取Directory文件夹下经过筛选的文件
        self.library.find()

        #获取键值对
        for name,info in self.library.items():
            #创建ListWidegtItem
            item = QtWidgets.QListWidgetItem(name)
            #添加到file_listWidget
            self.file_listWidget.addItem(item)

            #查看是否有截图
            screenshot = info.get(&quot;screenshot&quot;)
            if screenshot:
                icon = QtGui.QIcon(screenshot)
                item.setIcon(icon)

    def load(self):
        #获取当前选中的ListWidgetItem
        currentItem = self.file_listWidget.currentItem()
        #如果没有选中，则弹出警告
        if not currentItem:
            QtWidgets.QMessageBox.warning(self,&quot;warning&quot;,u&quot;请选择文件！！&quot;)
            return

        self.library.load(currentItem.text())

    def save(self):
        #首先获取lineEdit的str
        name = self.saveName_lineEdit.text()

        #去除name的首尾空格
        if not name.strip():
            QtWidgets.QMessageBox.warning(self,&quot;warning&quot;,u&quot;名字不合法！！&quot;)
            return

        self.library.save(name)
        #重新更新ListWidget
        self.populate()
        #重置LineEdit
        self.saveName_lineEdit.setText(&quot;&quot;)


def showUI():
    ui = ControllerLibraryUI()
    ui.show()

    return ui</code></pre><h2 id="QListView和QListWidget的区别"><a href="#QListView和QListWidget的区别" class="headerlink" title="QListView和QListWidget的区别"></a>QListView和QListWidget的区别</h2><p>我上次搞图片快速分类工具的时候，对于图片文件的预览我使用了QListView来进行数据的展示。这次我用QListWidget列表展示数据，那么他们到底有什么不一样呢？</p>
<p><strong>QlistView类用于展示数据，它的子类是QListWIdget。QListView是基于模型（Model）的，需要程序来建立模型，然后再保存数据。QListWidget是一个升级版本的QListView，它已经建立了一个数据储存模型（QListWidgetItem），直接调用addItem（）函数，就可以添加条目（Item）</strong></p>
<p>图片快速分类中QlistView的使用</p>
<pre><code>        #创建QFileSystemModel
        #QFileSystemModel是一个维护文件目录内容信息的模型，它本身不包含任何数据项，而只是表示本地文件系统上的文件和目录。
        self.file_model = QtWidgets.QFileSystemModel()
        #设置过滤器
        self.file_model.setNameFilters(self.FILTERS)
        #隐藏过滤掉的文件
        self.file_model.setNameFilterDisables(False)
        #设置Model
        self.ui.image_list_view.setModel(self.file_model)
</code></pre><p>存储导入工具中QListWidget的使用</p>
<pre><code>        #设置listWidget
        self.file_listWidget = QtWidgets.QListWidget()
        #图标模式
        self.file_listWidget.setViewMode(QtWidgets.QListWidget.IconMode)
        #设置图标大小
        self.file_listWidget.setIconSize(QtCore.QSize(self.size,self.size))
        #设置拉伸模式为Adjust
        self.file_listWidget.setResizeMode(QtWidgets.QListWidget.Adjust)
        #设置GridSize                        self.file_listWidget.setGridSize(QtCore.QSize(self.size+self.buffer,self.size+self.buffer))</code></pre>]]></content>
      <categories>
        <category>Maya</category>
      </categories>
      <tags>
        <tag>Maya</tag>
      </tags>
  </entry>
  <entry>
    <title>Maya简易控制器</title>
    <url>/2020/08/24/Maya%E7%AE%80%E6%98%93%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<p>Maya教程笔记，过程中会记录自己所遇到的问题和新知识</p>
<a id="more"></a>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>控制器的简易添加，缩放控制器，控制器的颜色选择</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/GIF%202020-8-24%2022-52-16.gif" alt="GIF 2020-8-24 22-52-16"></p>
<h2 id="QLabel"><a href="#QLabel" class="headerlink" title="QLabel"></a>QLabel</h2><p>QLabel提供了一个文本或者图像的显示，没有提供交互功能，在建议控制器中我利用QLabel进行了文字的显示和背景颜色显示</p>
<pre><code>self.controlScale_label = QtWidgets.QLabel(u&quot;控制器Scale&quot;,alignment=QtCore.Qt.AlignCenter)
#设置格式
self.controlScale_label.setStyleSheet(&quot;background-color:rgb(0,0,0,255)&quot;)</code></pre><h2 id="Constraints-约束"><a href="#Constraints-约束" class="headerlink" title="Constraints(约束)"></a>Constraints(约束)</h2><p>point constraints（点约束）：约束位移</p>
<p>orient constraints（反向约束）：约束旋转</p>
<p>parent constraints（父约束）：约束位移和旋转</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>1.首先要获取选中的物体，然后判断是否为joint骨骼类型，如果是则获取选中物体的所有子物体
2.根据joint数量生成一定的控制器，调整控制器的旋转和位置与joint一致
3.进行parent约束限制，这样生成的Circle就可以控制joints
4.利用Pyside2进行GUI的设置，完成交互</code></pre><h2 id="OverrideColor设置问题"><a href="#OverrideColor设置问题" class="headerlink" title="OverrideColor设置问题"></a>OverrideColor设置问题</h2><p>首先OverrideColor指的是Shape下的设置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20200824230019419.png" alt="image-20200824230019419"></p>
<p>这里我需要将颜色设置为RGB而非索引，所以需要一下代码,这里应该可以直接设置overrideColorRGB属性的，但不知道哪里出了问题，所以我就曲线救国</p>
<pre><code>            #获取选中物体的shape
            shape = cmds.listRelatives(tempControl,children=True)[0]
            cmds.setAttr(shape+&quot;.overrideEnabled&quot;,True)
            cmds.setAttr(shape+&quot;.overrideRGBColors&quot;,1)

            #设置颜色值
            cmds.setAttr(shape+&quot;.overrideColorR &quot;,self.color.redF())
            cmds.setAttr(shape + &quot;.overrideColorG &quot;, self.color.greenF())
            cmds.setAttr(shape + &quot;.overrideColorB &quot;, self.color.blueF())
            #print(cmds.getAttr(shape+&quot;.overrideColor&quot;))</code></pre><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20200824230220071.png" alt="image-20200824230220071"></p>
<h2 id="Circle-Scale问题"><a href="#Circle-Scale问题" class="headerlink" title="Circle Scale问题"></a>Circle Scale问题</h2><p>这里不是直接缩放Circle，而是缩放Circle的controlVertics（控制顶点），这样就可以直接连续缩放</p>
<pre><code>    def smallScale(self):
        #获得选中的物体
        selectionControl = cmds.ls(selection=True)
        #获取缩放值
        scaleFactor = self.scale_DoubleSpinBox.value()
        for tempControl in selectionControl:
            # Scale控制顶点
            cmds.scale(1-scaleFactor,1-scaleFactor,1-scaleFactor,tempControl+&quot;.cv[0:]&quot;)</code></pre><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code># -*- coding: GBK -*-
from PySide2 import QtWidgets,QtGui,QtCore
from shiboken2 import wrapInstance
from maya import OpenMayaUI as omui
import maya.cmds as cmds

#maya主窗口
def maya_main_window():
    main_window_ptr = omui.MQtUtil.mainWindow()
    return wrapInstance(long(main_window_ptr),QtWidgets.QWidget)

window_w = 200
window_h = 168


class RigTools_Dialog(QtWidgets.QDialog):

    def __init__(self,parent = maya_main_window()):
        super(RigTools_Dialog, self).__init__(parent)
        #设置默认颜色
        self.color = QtGui.QColor(&quot;#FFFFFF&quot;)
        self.control_list=[]
        self.offset_list=[]

        #设置窗口名称
        self.setWindowTitle(&quot;RigTools&quot;)
        #设置窗口大小
        self.setFixedWidth(window_w)
        self.setFixedHeight(window_h)
        #关闭问号按钮
        self.setWindowFlags(self.windowFlags() ^ QtCore.Qt.WindowContextHelpButtonHint)

        self.createWidgets()
        self.createLayouts()
        self.createConnects()


    def createWidgets(self):
        self.rig_btn = QtWidgets.QPushButton(&quot;Rig&quot;)
        self.rig_btn.setFixedWidth(window_w)
        self.rig_btn.setFixedHeight(40)

        self.controlScale_label = QtWidgets.QLabel(u&quot;控制器Scale&quot;,alignment=QtCore.Qt.AlignCenter)
        #设置格式
        self.controlScale_label.setStyleSheet(&quot;background-color:rgb(0,0,0,255)&quot;)

        self.scale_DoubleSpinBox = QtWidgets.QDoubleSpinBox()
        #设置范围，经度，步长
        self.scale_DoubleSpinBox.setRange(0,1)
        self.scale_DoubleSpinBox.setDecimals(2)
        self.scale_DoubleSpinBox.setSingleStep(0.05)
        self.smallScale_btn = QtWidgets.QPushButton(&quot;Small&quot;)
        self.bigScale_btn = QtWidgets.QPushButton(&quot;Big&quot;)

        self.controlColor_label = QtWidgets.QLabel(u&quot;控制器颜色&quot;,alignment=QtCore.Qt.AlignCenter)
        self.controlColor_label.setStyleSheet(&quot;background-color:rgb(0,0,0,255)&quot;)

        self.color_pick_label = QtWidgets.QLabel()
        self.color_pick_label.setStyleSheet(&quot;background-color:rgb(255,255,255,255)&quot;)
        self.color_pick_btn = QtWidgets.QPushButton(u&quot;颜色选择&quot;)

        self.color_set_btn = QtWidgets.QPushButton(u&quot;颜色设置&quot;)


        pass

    def createLayouts(self):
        #主层级
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setMargin(0)
        main_layout.setSpacing(0)

        main_layout.addWidget(self.rig_btn)

        main_layout.addWidget(self.controlScale_label)

        HLayout = QtWidgets.QHBoxLayout()
        main_layout.setSpacing(5)
        HLayout.addWidget(self.scale_DoubleSpinBox)
        HLayout.addWidget(self.smallScale_btn)
        HLayout.addWidget(self.bigScale_btn)
        main_layout.addLayout(HLayout)

        main_layout.addWidget(self.controlColor_label)

        H_Color_Layout = QtWidgets.QHBoxLayout()
        H_Color_Layout.addWidget(self.color_pick_label)
        H_Color_Layout.addWidget(self.color_pick_btn)
        main_layout.addLayout(H_Color_Layout)

        main_layout.addWidget(self.color_set_btn)

        pass

    def createConnects(self):
        self.rig_btn.clicked.connect(self.rig_function)
        self.smallScale_btn.clicked.connect(self.smallScale)
        self.bigScale_btn.clicked.connect(self.bigScale)
        self.color_pick_btn.clicked.connect(self.color_pick)
        self.color_set_btn.clicked.connect(self.color_set)

    def smallScale(self):
        #获得选中的物体
        selectionControl = cmds.ls(selection=True)
        #获取缩放值
        scaleFactor = self.scale_DoubleSpinBox.value()
        for tempControl in selectionControl:
            # Scale控制顶点
            cmds.scale(1-scaleFactor,1-scaleFactor,1-scaleFactor,tempControl+&quot;.cv[0:]&quot;)
        pass

    def bigScale(self):
        # 获得选中的物体
        selectionControl = cmds.ls(selection=True)
        # 获取缩放值
        scaleFactor = self.scale_DoubleSpinBox.value()
        print(scaleFactor)
        for tempControl in selectionControl:
            #Scale控制顶点
            cmds.scale(1.0 + scaleFactor, 1.0 + scaleFactor, 1.0 + scaleFactor, tempControl+&quot;.cv[0:]&quot;)

        pass

    def color_pick(self):
        #获取颜色选择
        color = QtWidgets.QColorDialog.getColor()
        self.color = color
        self.color_pick_label.setStyleSheet(&quot;background-color: {0}&quot;.format(color.name()))

    def color_set(self):
        #获取选中的物体
        selectionControl = cmds.ls(selection=True)
        #设置颜色值
        for tempControl in selectionControl:
            #获取选中物体的shape
            shape = cmds.listRelatives(tempControl,children=True)[0]
            cmds.setAttr(shape+&quot;.overrideEnabled&quot;,True)
            cmds.setAttr(shape+&quot;.overrideRGBColors&quot;,1)

            #设置颜色值
            cmds.setAttr(shape+&quot;.overrideColorR &quot;,self.color.redF())
            cmds.setAttr(shape + &quot;.overrideColorG &quot;, self.color.greenF())
            cmds.setAttr(shape + &quot;.overrideColorB &quot;, self.color.blueF())
            #print(cmds.getAttr(shape+&quot;.overrideColor&quot;))
        pass


    def rig_function(self):
        # 获取选中的物体
        selected = cmds.ls(selection=True)

        # 判断选择物体是否为空
        if len(selected) == 0:
            cmds.warning(u&quot;请选中物体!!!&quot;)
            QtWidgets.QMessageBox.warning(self,u&quot;警告&quot;,u&quot;请选中物体!!!&quot;)
        elif len(selected) &gt; 1:
            cmds.warning(u&quot;只能选中一个物体！！！&quot;)
            QtWidgets.QMessageBox.warning(self, u&quot;警告&quot;, u&quot;只能选中一个物体！！！&quot;)
        else:
            # 判断类型是否为joint骨骼
            if cmds.objectType(selected[0]) != &quot;joint&quot;:
                cmds.warning(u&quot;选择物体类型不为joint！！！&quot;)
                QtWidgets.QMessageBox.warning(self, u&quot;警告&quot;, u&quot;选择物体类型不为joint！！！&quot;)

            else:
                # 选择该物体的包含的所有子物体和自身
                cmds.select(selected[0], hierarchy=True)
                # 获取选择的物体
                all_Joints = cmds.ls(selection=True)
                # 骨骼数
                joints_number = len(all_Joints)


                # 循环生成circle控制器
                for i in range(joints_number - 1):
                    # 生成circle
                    control = cmds.circle(name=all_Joints[i] + &quot;_control&quot;)
                    # 旋转变换
                    cmds.rotate(0, 90, 0, control[0])

                    # 冻结变换
                    cmds.makeIdentity(apply=True)
                    # 删除变换历史
                    cmds.DeleteHistory()

                    # 创建group组
                    offset_grp = cmds.group(name=all_Joints[i] + &quot;_offset&quot;, empty=True)
                    # 设置父类
                    cmds.parent(control[0], offset_grp)

                    # 获取骨骼的位置Position
                    joint_position = cmds.xform(all_Joints[i], query=True, translation=True, worldSpace=True)
                    # 将控制器移动到骨骼位置
                    cmds.xform(offset_grp, translation=joint_position)

                    # 利用orient约束将圆环旋转到骨骼方向一致
                    orient_cons = cmds.orientConstraint(all_Joints[i], offset_grp)
                    # 删除旋转约束
                    cmds.delete(orient_cons)

                    # parent约束，用于控制器控制骨骼移动
                    cmds.parentConstraint(control[0], all_Joints[i])

                    # 添加到list
                    self.control_list.append(control[0])
                    self.offset_list.append(offset_grp)

                # 重新设置父类关系
                for i in range(joints_number - 2):
                    cmds.parent(self.offset_list[i + 1], self.control_list[i])


if __name__ == &#39;__main__&#39;:
    try:
        rigTools_dialog.close()
        rigTools_dialog.deleteLater()
    except:
        pass

    rigTools_dialog = RigTools_Dialog()
    rigTools_dialog.show()</code></pre>]]></content>
      <categories>
        <category>Maya</category>
      </categories>
      <tags>
        <tag>Maya</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4学习笔记(1)——简单框架</title>
    <url>/2019/11/06/UE4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>纪录自己的UE4学习之路</p>
 <a id="more"></a> 

<h1 id="UE4的简单框架"><a href="#UE4的简单框架" class="headerlink" title="UE4的简单框架"></a>UE4的简单框架</h1><blockquote>
<p> UE创世，万物皆UObject，接着有Actor 。</p>
</blockquote>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/1.png" alt="继承关系"> </p>
<h2 id="Uobject"><a href="#Uobject" class="headerlink" title="Uobject"></a>Uobject</h2><p>Uobject是UE4中最基础的类，具有 元数据、反射生成、GC垃圾回收、序列化、编辑器可见，Class Default Object等功能。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/2.png" alt> </p>
<h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><p>Actor是UE4中最基本的场景元素，与Unity3D的gameobject相似，本身是一个容器，但是与unity不同的是，Actor没有任何可视化属性，甚至连位置属性也没有。但是也是与Unity相似，可以挂在多个可视化的组件( Component)，以达到各种功能，Actor也可以有子Actor。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/3.png" alt></p>
<p>Actor继承至Uobject，多了 Replication（网络复制）,Spawn（生生死死），Tick(有了心跳)等功能。</p>
<h2 id="组件-Component"><a href="#组件-Component" class="headerlink" title="组件(Component)"></a>组件(Component)</h2><p>组件挂在Actor身上发挥功能，例如位置组件，Actor的最终位置来至于他的根组件。组件也可以有根组件。</p>
<h2 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h2><p>Pawn是可以被控制的物体，相当于有controller的大脑，他可以是交通工具，鱼等，可以默认为生物的基类。</p>
<h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><p>Character是人形的Actor，继承于Pawn， 默认拥有一个用于碰撞的胶囊体组件(CapsuleComponent)和运动相关的组件(CharacterMoveMentComponent)，并具有一些动画相关的功能。可以认为是人性动物的基类。 </p>
<h2 id="控制器-Controller"><a href="#控制器-Controller" class="headerlink" title="控制器(Controller)"></a>控制器(Controller)</h2><p>控制器用于控制Pawn的行为， 一般分为AIController和PlayerController。控制器也是从Actor派生的，因此也可以加入到场景中。 </p>
<h3 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h3><p> 玩家控制器。是Pawn和控制其的玩家之间的桥梁，PlayerController代表了人类玩家的意愿。 </p>
<h3 id="AIController"><a href="#AIController" class="headerlink" title="AIController"></a>AIController</h3><p> 用于控制NPC的控制器，决定了NPC如何与玩家互动。 </p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><h3 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h3><p>UI, 显示玩家的名字，血条，得分等信息。 </p>
<h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><p> 每个PlayerConroller都有一个PlayerCameraManager，代表了玩家的视角。 </p>
<h2 id="游戏规则和状态"><a href="#游戏规则和状态" class="headerlink" title="游戏规则和状态"></a>游戏规则和状态</h2><h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><p> 游戏模式。处理游戏的规则，只存在与服务器端，因此客户端相关的逻辑不能存放在GameMode中。 </p>
<h3 id="GameState"><a href="#GameState" class="headerlink" title="GameState"></a>GameState</h3><p>游戏状态， 记录游戏的数据，比如当前游戏的进度，世界任务的完成状态等，会自动同步到各个客户端。 </p>
<h3 id="PlayerState"><a href="#PlayerState" class="headerlink" title="PlayerState"></a>PlayerState</h3><p> 玩家状态。记录玩家个人的数据，比如名字分数等，会自动同步到各个客户端。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>GamePlay框架使用了MVC架构，其中Pawn是视图，PlayerState是数据模型，PlayerController是控制器。</p>
<p>一个游戏由游戏规则(GameMode)和游戏状态组成(GameState)；玩家在游戏里的化身是Pawn，玩家通过PlayerConroller控制着自己的化身，通过PlayerCameraManager观察世界，PlayerState记录了玩家的数据，HUD显示了这些状态；NPC则由AIConroller去控制，与玩家进行互动。 </p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/GameFramework.jpg" alt="GameFramework"></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4学习笔记(2)---蓝图接口-标签</title>
    <url>/2019/11/13/UE4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)---%E8%93%9D%E5%9B%BE%E6%8E%A5%E5%8F%A3-%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="蓝图接口"><a href="#蓝图接口" class="headerlink" title="蓝图接口"></a>蓝图接口</h1><p> <strong>蓝图接口（Blueprint Interface）</strong> 是一个或多个函数的集合 - 只有名称，没有实现。可以添加到其他蓝图中。任何添加了该接口的蓝图都保证拥有这些函数。接口的函数 可以在添加它的每个蓝图中提供功能。在本质上，这类似于一般编程中的接口概念， 它允许多个不同类型的对象通过一个公共接口 共享和被访问。简单地说，蓝图接口允许不同的蓝图相互共享和发送数据。 </p>
<a id="more"></a>

<h2 id="创建蓝图接口"><a href="#创建蓝图接口" class="headerlink" title="创建蓝图接口"></a>创建蓝图接口</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/1.png" alt></p>
<p>新建函数和函数的输入输出值</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/2.png" alt></p>
<p>要使用蓝图接口，就必须继承该接口，并且实现。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/3.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/4.png" alt></p>
<p>实现接口之后，其他蓝图类就可以调用此方法，实现了蓝图之间的通信。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/5.png" alt></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>在调用蓝图接口方法前，先使用标签来判断是敌人还是友军，其实我感觉UE4的标签和Unity的标签还是挺相似的</p>
<h3 id="标签的设置方法"><a href="#标签的设置方法" class="headerlink" title="标签的设置方法"></a>标签的设置方法</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/6.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/7.png" alt></p>
<h2 id="调用蓝图接口方法"><a href="#调用蓝图接口方法" class="headerlink" title="调用蓝图接口方法"></a>调用蓝图接口方法</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/8.png" alt></p>
<p>就这样完成了蓝图接口的调用</p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4材质大师课程笔记(二)---RenderTarget</title>
    <url>/2020/02/19/UE4%E6%9D%90%E8%B4%A8%E5%A4%A7%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0(%E4%BA%8C)---RenderTarget/</url>
    <content><![CDATA[<h1 id="RenderTarget"><a href="#RenderTarget" class="headerlink" title="RenderTarget"></a>RenderTarget</h1><p>UE4的RenderTarget感觉和Unity的差不多，都是获得一个摄像机的渲染结果，然后存在RenderTarget里面进行读取使用。</p>
<a id="more"></a>

<p>在UE4中要使用RenderTarget，首先要添加SceneCapture2D组件或者SceneCapture Cube组件，前者获取2D，后者获取Cube立方体贴图。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget%E7%BB%84%E4%BB%B6.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget%E6%96%B0%E5%BB%BARenderTarget.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget%E8%B5%8B%E5%80%BCRenderTarget.png" alt></p>
<h2 id="RenderTarget的使用"><a href="#RenderTarget的使用" class="headerlink" title="RenderTarget的使用"></a>RenderTarget的使用</h2><h3 id="渲染材质"><a href="#渲染材质" class="headerlink" title="渲染材质"></a>渲染材质</h3><p>在UE4中过程化生成噪点纹理是比较昂贵的，所以通常的做法是将材质绘制到RenderTarget中。</p>
<img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetNoise.png">

<p>可以看出以上这个需要529条指令<img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetNoise%E6%8C%87%E4%BB%A4.png" alt></p>
<p>将材质绘制到RenderTarget</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget%E5%B0%86%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E5%88%B0RenderTarget.png" alt></p>
<p>得到左边的RenderTarget噪点图了，然后右键创建静态纹理则可以得到可以用的Texture纹理了。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200109210329543.png" alt></p>
<p>指令就变为了34，效率得到了提升。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200109210452008.png" alt></p>
<h3 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h3><h4 id="高度图"><a href="#高度图" class="headerlink" title="高度图"></a>高度图</h4><p>效果如下，随着鼠标左键的按下，在平面生成不同的高度。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110182834948.png" alt></p>
<p>1.首先我们要创建MAT_HeightfieldPainter材质，设置如下，注意要把shading Model改为Unlit无光照模式。这个材质主要用于控制物体在Z轴的世界偏移。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110183116238.png" alt></p>
<p>2.创建MAT_ForceSplat材质，设置如下，主要用于处理鼠标点击平面所产生的uv坐标，通过下面的计算获得一个关于这个uv坐标为圆心的渐变圆形贴图</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110183515861.png" alt></p>
<p>3.新建一个HeightFieldPainter的Actor蓝图，设置如下</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110200935951.png" alt></p>
<p>然后在构造函数里面进行动态材质的设置，这里主要针对我们上面的材质创建动态材质。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110201017886.png" alt></p>
<p>新建TraceFromCamera函数，函数用于从摄像头方向射出射线，进行射线检测，如果检测到碰撞物体，就进行伤害传递。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110204023291.png" alt></p>
<p>Begin函数，首先我们要为新建一个RenderTexture并保存，同时将RT传递给Z轴偏移的MAT_HeightfieldPainter材质。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110204531617.png" alt></p>
<p>最后处理伤害函数，传递参数给MAT_ForceSplat材质，例如点击的uv坐标，力度，大小，最后要用Draw Material to Render Target函数将材质绘制到RT里面，这样HeighfieldPainter材质才会根据RT图进行Z轴的偏移。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110204555551.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget%E5%B0%86%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E5%88%B0RenderTarget.png" alt></p>
<p>这里注意，这种方法只适用于平面，计算点击位置的uv坐标也比较简单，首先获取点击位置的世界坐标，然后获取静态网格的worldTransform,然后通过Invert Transform获得从世界坐标到静态网格本地坐标的变换矩阵，将点击位置从世界空间转换为静态网格的本地空间，当然我们也要将得到的本地坐标转为uv坐标，就要除于网格的长宽，映射到【0，1】，这样就得到了正确的uv坐标。</p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity VEG实现烟花效果</title>
    <url>/2019/11/01/Unity-VEG%E5%AE%9E%E7%8E%B0%E7%83%9F%E8%8A%B1%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次利用VEG实现普通烟花效果。</p>
 <a id="more"></a> 

<h2 id="主粒子"><a href="#主粒子" class="headerlink" title="主粒子"></a>主粒子</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/1.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/2.png" alt></p>
<p>设置主粒子的速度，位置，周期等参数。</p>
<h3 id="Position-Line"><a href="#Position-Line" class="headerlink" title="Position(Line)"></a>Position(Line)</h3><p>用于设置粒子的初始化位置，从Start到End随机生成一个位置点。</p>
<h2 id="烟花粒子"><a href="#烟花粒子" class="headerlink" title="烟花粒子"></a>烟花粒子</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/3.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/4.png" alt></p>
<p>这里利用GPU Event当主粒子消亡时生成新的眼花粒子。</p>
<h3 id="GPU-Event"><a href="#GPU-Event" class="headerlink" title="GPU Event"></a>GPU Event</h3><p> GPU事件由系统在特定条件下触发，并且可以被其他系统捕获以生成新粒子。 可以通过读取Source或使用Inherit Source节点在子系统中访问事件数据。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/5.png" alt></p>
<h2 id="主粒子的拖尾粒子"><a href="#主粒子的拖尾粒子" class="headerlink" title="主粒子的拖尾粒子"></a>主粒子的拖尾粒子</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/6.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/7.png" alt></p>
<h2 id="烟花粒子的拖尾"><a href="#烟花粒子的拖尾" class="headerlink" title="烟花粒子的拖尾"></a>烟花粒子的拖尾</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/8.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/9.png" alt></p>
<p>就这样我们的烟花就完成啦</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/10.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/11.png" alt></p>
<p>现在看起来还是有点难看的，但问题不大，给它加点后处理就好了，PostProcessVolume</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/12.png" alt></p>
<p>就这样，好看多了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/13.png" alt></p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>可能后面还想加点其他的功能，所以未完待续。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Visual Effect Graph初探</title>
    <url>/2019/10/31/Unity-Visual-Effect-Graph%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近为了实现动画课程设计的烟花效果，所以要学习一下Unity的新特效工具Visual Effect Graph，特此记录学习的过程，避免以后会忘记。</p>
 <a id="more"></a> 

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>目前Visual Effect Graph只能在HDRP中使用，也就是说必须使用Unity2018.3以上的版本。</p>
</blockquote>
<h2 id="为什么要使用VEF"><a href="#为什么要使用VEF" class="headerlink" title="为什么要使用VEF"></a>为什么要使用VEF</h2><p>我们已经有传统的Particle System系统，那为什么要用VEF呢？</p>
<p>其实VEF能比传统的Particle System能做出更加复杂酷炫的特效，具体可以查看Unity的官方文档。而且我们认为VEF还有一个更加巨大有点就是可视化，我刚开始接触Particle System的时候，看到这么多参数，头都晕了….这次VEF的工作流非常的清楚。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/24.jpg" alt="VEF和传统Particle System区别"></p>
<h2 id="VEF的工作流"><a href="#VEF的工作流" class="headerlink" title="VEF的工作流"></a>VEF的工作流</h2><p>关于VEF的安装和配置就不说了，官方文档有详细的讲解。</p>
<p>首先我们来看一下VEF的画面，可以看出和shader Graph非常的相似。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/1.png" alt="VEG"></p>
<p>VEF默认模板由4个流程构成(VEF称为Context)，包含着多个Block，整个VEF工作流抽象成4个部分</p>
<h3 id="Spawn"><a href="#Spawn" class="headerlink" title="Spawn"></a>Spawn</h3><p>负责生成粒子，右键点击添加的Block都是与粒子生成相关。</p>
<h3 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h3><p>初始化模块，负责初始化粒子的属性，如初始速度，生命周期。</p>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>每帧对粒子的参数进行更新，比如重力，移动速度，坐标等。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>主要负责粒子的渲染，如颜色，形状等。</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>每个Context连接并不是唯一，比如一个Spawn可连接多个Initialize，朝多个方向发射</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/2.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/3.png" alt></p>
<h2 id="VEF的使用"><a href="#VEF的使用" class="headerlink" title="VEF的使用"></a>VEF的使用</h2><h3 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h3><p>VEF的小测试，以粒子的初始速度为基准设置粒子的颜色</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/4.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/5.png" alt></p>
<p>实现以原点为圆心，半径为1，圆以内的呈绿色，圆以外的呈紫色。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/6.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/7.png" alt></p>
<p>也可添加Get Attribute：Color结点获取粒子原本的颜色，达到新效果。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/8.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/9.png" alt></p>
<h3 id="Point-Cache-bake-tool-点阵缓存烘焙器"><a href="#Point-Cache-bake-tool-点阵缓存烘焙器" class="headerlink" title="Point Cache bake tool(点阵缓存烘焙器)"></a>Point Cache bake tool(点阵缓存烘焙器)</h3><p>这个是VEG添加的新工具，它的作用是把一张图或者Mesh的信息，烘焙成一张点阵图，然后再VEG中使用，可烘焙的信息有颜色，法线，位置，UV信息等。</p>
<p>首先点开烘焙工具，烘焙工具在上方Window—Visual Effects—Utilities—Point Cache bake tool,选择要烘焙的网格和信息，这里我选择胶囊体作为测试。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/10.png" alt></p>
<p>在VEG中使用以下两个节点，即可得到一个粒子形成的胶囊体</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/11.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/12.png" alt></p>
<h3 id="Vector-Field-Force-矢量场力"><a href="#Vector-Field-Force-矢量场力" class="headerlink" title="Vector Field Force(矢量场力)"></a>Vector Field Force(矢量场力)</h3><p>官方文档解释：矢量场力施加从包含矢量数据的3D纹理中获取的力。我也不是很明白，以后有机会再研究。通过结合矢量场力和Point Cache我们可以实现粒子物体爆掉的感觉。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/13.png" alt></p>
<h3 id="VFX-Binder脚本，参数与事件的绑定"><a href="#VFX-Binder脚本，参数与事件的绑定" class="headerlink" title="VFX Binder脚本，参数与事件的绑定"></a>VFX Binder脚本，参数与事件的绑定</h3><p>为了在游戏运行时根据游戏内的逻辑来实时动态改变VEG，我们可以用VFX Binder绑定脚本。</p>
<h4 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h4><p>首先，我们为VFX添加VFX Parameter binder脚本</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/14.png" alt></p>
<p>在Hierarchy面板新建一个Cube，这个Cube用于传递位置参数进VEG，实时更新粒子喷发的位置。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/15.png" alt></p>
<p>进入VEG在参数面板新建一个Vector3用于存储Cube的位置参数，并传递给粒子。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/18.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/17.png" alt="最终结果"></p>
<h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>在VEG里事件作为一个单独的Context，不能附加任何的Block并且只能和Spawn相连，作用是管理Spawn的发射开关。</p>
<p>现在做鼠标点击位置生成粒子效果</p>
<p>首先新建一个Plane作为脚本的载体，并且绑定VFX Mouse Event Blinder事件,拖入新建的VFX</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/22.png" alt></p>
<p>双击VEX，新建一个Event，注意名字要和脚本上的EventName要一致。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/21.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/23.png" alt></p>
<h5 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h5><p>Location为Source的Attribute只能用在Initializes中的Block上</p>
<p>最后我们就能实现鼠标点击位置生成粒子的效果了。</p>
<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>第一次尝试这样做笔记，比较痛苦，但成就感也是满满的。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity实现米哈游的Mesh变换转场效果</title>
    <url>/2019/11/13/Unity%E5%AE%9E%E7%8E%B0%E7%B1%B3%E5%93%88%E6%B8%B8%E7%9A%84Mesh%E5%8F%98%E6%8D%A2%E8%BD%AC%E5%9C%BA%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前看过米哈游大佬制作的桃源恋歌MMD，被其中的Mesh变换转场效果所折服了，所以自己想模仿着实现这个效果，幸好kerjiro技术美术大神开源了这方面的视觉特效项目，感觉自己如果想成为TA还有好长的路要走。。。</p>
 <a id="more"></a> 

<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>首先让我们来看一下最终效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/Effect.gif" alt="Effect"></p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>其实这个效果是通过几何着色器来实现的，主要思路就是通过几何着色器对三角面片的顶点进行添加，构成一个Cube。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF.png" alt="实现思路"></p>
<h2 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h2><p>相信大家接触的最多的应该是顶点着色器和像素着色器，那么什么是几何着色器呢？</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在顶点和片段着色器之间有一个可选的着色器，叫做几何着色器(Geometry Shader)。几何着色器以一个或多个表示为一个单独基本图形（primitive）即图元的顶点作为输入，比如可以是一个点或者三角形。几何着色器在将这些顶点发送到下一个着色阶段之前，可以将这些顶点转变为它认为合适的内容。<strong>几何着色器有意思的地方在于它可以把（一个或多个）顶点转变为完全不同的基本图形（primitive），从而生成比原来多得多的顶点。</strong> </p>
<h3 id="使用几何着色器进行图元转换"><a href="#使用几何着色器进行图元转换" class="headerlink" title="使用几何着色器进行图元转换"></a>使用几何着色器进行图元转换</h3><p>声明着色器</p>
<pre><code>#pragma geometry geom</code></pre><p>设置输出顶点数量，其中N为几何着色器为单个调用输出的顶点最大数量，几何着色器每次输出的顶点数量是可变的，但是不能超过定义的最大值， 出于性能考虑，最大顶点数应尽可能小; 当GS输出在1到20个标量之间时，可以实现GS的性能峰值，如果GS输出在27-40个标量之间，则性能下降50％。每次调用的标量输出数是最大顶点输出数和输出顶点类型结构中的标量数的乘积。 </p>
<pre><code>[maxvertexcount(N)]</code></pre><p>声明输入和输出的Struct</p>
<pre><code>            //传递给几何着色器的数据
            struct v2g
            {
                float4 vertex:POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv:TEXCOORD1;

            };

            //传递给像素着色器的数据
            struct g2f
            {
                float4 pos : SV_POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv : TEXCOORD1;
                float4 color:COLOR;
            };</code></pre><p>设置几何着色器输入参数和输出参数，</p>
<p>其中“triangle”为输入的图元类型， 输入参数一定为顶点数组 。</p>
<pre><code class="ruby">输入图元类型 | 所需顶点数  
-|-
point | 输入1个点的1个顶点
line | 输入1条直线的2个顶点 
lineadj | 输入1条具有邻接(lists或strips)的线段的4个顶点 
triangle | 输入1个三角形的3个顶点
triangleadj | 输入1个具有邻接(lists或strips)的三角形的6个顶点</code></pre>
<p>TriangleStream为流类型(stream type)对象，还有 LineStream 和 PointStream ,存储着由几何着色器输出的几何体顶点列表。内置Append用于向输出流添加顶点序列， 若想扩展输入的图元，也可以用内置Append向输出流添加多出来的顶点。 </p>
<p>当指定uint primID:SV_PrimitiveID时，输入汇编阶段会为每个图元自动生成一个图元ID。当调用draw方法绘制n个图元时，ID号为0到n-1，这里用到的原因是为了随机Cube化。</p>
<pre><code>void geom(triangle v2g input[3], uint pid : SV_PrimitiveID, inout TriangleStream&lt;g2f&gt; outStream)
{
    //shader body
}</code></pre><p>将输出顶点传送至输出stream上</p>
<pre><code>OutputStream.Append(o);</code></pre><h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><h3 id="CPU传递数据给Shader"><a href="#CPU传递数据给Shader" class="headerlink" title="CPU传递数据给Shader"></a>CPU传递数据给Shader</h3><p>首先我们需要新建一个脚本用于传递数据给Shader，以下就是K神的传递脚本，我已经写好注释。挂在一个空物体上面即可。</p>
<pre><code>using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//在编辑器模式下也可运行
[ExecuteInEditMode]
public class Voxelizer : MonoBehaviour
{
    //SerializeField用于面板上显示非Public的参数
    //Range(0,1)控制可滑选的范围

    //控制生成方块的密度
    [SerializeField, Range(0, 1)] float _density = 0.05f;
    //控制生成方块的大小
    [SerializeField, Range(0, 10)] float _scale = 3;


    //动画参数
    //用于控制方块变形后的长度
    [SerializeField, Range(0, 20)] float _stretch = 5;
    //用于控制方块变形后上升的最大距离
    [SerializeField, Range(0, 1000)] float _fallDistance = 1;
    //用于控制方块变形后的随机移动范围
    [SerializeField, Range(0, 10)] float _fluctuation = 1;

    //颜色参数
    [SerializeField, ColorUsage(false, true)] Color _emissionColor1 = Color.black;
    [SerializeField, ColorUsage(false, true)] Color _emissionColor2 = Color.black;
    [SerializeField, ColorUsage(false, true)] Color _transitionColor = Color.white;
    [SerializeField, ColorUsage(false, true)] Color _lineColor = Color.white;

    //用于Mesh变换物体的Renderer
    [SerializeField] Renderer[] _renderers = null;


    //效果平面的位置与距离
    Vector4 EffectorPlane
    {
        get
        {
            //获取向前的方向
            var fwd = transform.forward / transform.localScale.z;
            //获取向前方向上的移动距离
            var dist = Vector3.Dot(fwd, transform.position);
            return new Vector4(fwd.x, fwd.y, fwd.z, dist);
        }
    }


    //将RGB颜色模型转为HSV颜色模型
    Vector4  ColorToHsvm(Color color)
    {
        //获取颜色的分量最大值
        var max = color.maxColorComponent;
        float h, s, v;
        Color.RGBToHSV(color / max, out h, out s, out v);
        return new Vector4(h, s, v, max);
    }


    //获取着色器属性的唯一标识符
    //优点：使用属性标识符比将字符串传递给所有材料属性函数更有效。
    //例如，如果您经常调用Material.SetColor或使用MaterialPropertyBlock，
    //则最好只获取一次所需属性的标识符。

    static class ShaderIDs
    {
        public static readonly int VoxelParams = Shader.PropertyToID(&quot;_VoxelParams&quot;);
        public static readonly int AnimParams = Shader.PropertyToID(&quot;_AnimParams&quot;);
        public static readonly int EmissionHsvm1 = Shader.PropertyToID(&quot;_EmissionHsvm1&quot;);
        public static readonly int EmissionHsvm2 = Shader.PropertyToID(&quot;_EmissionHsvm2&quot;);
        public static readonly int TransitionColor = Shader.PropertyToID(&quot;_TransitionColor&quot;);
        public static readonly int LineColor = Shader.PropertyToID(&quot;_LineColor&quot;);
        public static readonly int EffectorPlane = Shader.PropertyToID(&quot;_EffectorPlane&quot;);
        public static readonly int PrevEffectorPlane = Shader.PropertyToID(&quot;_PrevEffectorPlane&quot;);
        public static readonly int LocalTime = Shader.PropertyToID(&quot;_LocalTime&quot;);
    }

    //在要使用相同材质但属性稍有不同的多个对象绘制的情况下使用MaterialPropertyBlock。
    MaterialPropertyBlock _sheet;
    Vector4 _prevEffectorPlane = Vector3.one * 1e+5f;

    private void LateUpdate()
    {
        //查看渲染列表是否为空
        if (_renderers == null || _renderers.Length == 0) return;
        //创建新的MaterialPropertyBlock
        if (_sheet == null) _sheet = new MaterialPropertyBlock();

        var plane = EffectorPlane;
        // Filter out large deltas.
        //过滤掉大的三角面片
        if ((_prevEffectorPlane - plane).magnitude &gt; 100) _prevEffectorPlane = plane;

        //存储参数
        var vparams = new Vector2(_density, _scale);
        var aparams = new Vector3(_stretch, _fallDistance, _fluctuation);
        var emission1 = ColorToHsvm(_emissionColor1);
        var emission2 = ColorToHsvm(_emissionColor2);

        //将参数传递给shader
        foreach (var renderer in _renderers)
        {
            if (renderer == null) continue;
            renderer.GetPropertyBlock(_sheet);
            _sheet.SetVector(ShaderIDs.VoxelParams, vparams);
            _sheet.SetVector(ShaderIDs.AnimParams, aparams);
            _sheet.SetVector(ShaderIDs.EmissionHsvm1, emission1);
            _sheet.SetVector(ShaderIDs.EmissionHsvm2, emission2);
            _sheet.SetColor(ShaderIDs.TransitionColor, _transitionColor);
            _sheet.SetColor(ShaderIDs.LineColor, _lineColor);
            _sheet.SetVector(ShaderIDs.EffectorPlane, plane);
            _sheet.SetVector(ShaderIDs.PrevEffectorPlane, _prevEffectorPlane);
            //_sheet.SetFloat(ShaderIDs.LocalTime, time);
            renderer.SetPropertyBlock(_sheet);
            print(plane);
        }
    }


    //进行gizmo编辑器的实现,用于可视化Debug
    Mesh _gridMesh;

    void OnDestroy()
    {
        if (_gridMesh != null)
        {
            if (Application.isPlaying)
                Destroy(_gridMesh);
            else
                DestroyImmediate(_gridMesh);
        }
    }

    void OnDrawGizmos()
    {
        if (_gridMesh == null) InitGridMesh();

        //矩阵用于控制Gizmos跟随物体的移动而移动
        Gizmos.matrix = transform.localToWorldMatrix;

        Gizmos.color = new Color(1, 1, 0, 0.5f);
        Gizmos.DrawWireMesh(_gridMesh, Vector3.zero);
        Gizmos.DrawWireMesh(_gridMesh, Vector3.forward);

        Gizmos.color = new Color(1, 0, 0, 0.5f);
        Gizmos.DrawWireCube(Vector3.forward / 2, new Vector3(0.02f, 0.02f, 1));
    }

    void InitGridMesh()
    {
        const float ext = 0.5f;
        const int columns = 10;

        var vertices = new List&lt;Vector3&gt;();
        var indices = new List&lt;int&gt;();

        for (var i = 0; i &lt; columns + 1; i++)
        {
            var x = ext * (2.0f * i / columns - 1);

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(x, -ext, 0));

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(x, +ext, 0));

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(-ext, x, 0));

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(+ext, x, 0));
        }

        _gridMesh = new Mesh { hideFlags = HideFlags.DontSave };
        _gridMesh.SetVertices(vertices);
        _gridMesh.SetNormals(vertices);
        _gridMesh.SetIndices(indices.ToArray(), MeshTopology.Lines, 0);
        _gridMesh.UploadMeshData(true);
    }
}
</code></pre><h3 id="MaterialPropertyBlock"><a href="#MaterialPropertyBlock" class="headerlink" title="MaterialPropertyBlock"></a>MaterialPropertyBlock</h3><p>研究代码的时候发现了MaterialPropertyBlock，查阅文档才发现是用于节约性能。实际应用可以查看这篇文章<a href="https://blog.csdn.net/liweizhao/article/details/81937590" target="_blank" rel="noopener">MaterialPropertyBlock</a>。</p>
<h3 id="Shader的实现"><a href="#Shader的实现" class="headerlink" title="Shader的实现"></a>Shader的实现</h3><pre><code>// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;

// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;

Shader &quot;Custom/MeshShader&quot;
{

    Properties
    {
        _MainTex(&quot;主纹理贴图&quot;,2D)=&quot;white&quot;{}
    }
    SubShader
    {
        Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
        LOD 100
        Pass
        {
            Tags{&quot;LightMode&quot;=&quot;ForwardBase&quot;}
            CGPROGRAM

            //声明着色器
            #pragma vertex vert 
            #pragma geometry geom
            #pragma fragment frag

            #include &quot;UnityCG.cginc&quot;
            #include &quot;Assets/My/SimplexNoise3D.hlsl&quot;
            //传递给顶点着色器的数据
            struct a2v
            {
                float4 vertex:POSITION;
                float3 normal:NORMAL;
                float4 texcoord:TEXCOORD0;
            };

            //传递给几何着色器的数据
            struct v2g
            {
                float4 vertex:POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv:TEXCOORD1;

            };

            //传递给像素着色器的数据
            struct g2f
            {
                float4 pos : SV_POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv : TEXCOORD1;
                float4 color:COLOR;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            //用于几何着色器的数据
            half2 _VoxelParams; // density, scale  密度，比例
            half3 _AnimParams;  // stretch, fall distance, fluctuation   伸展、下降距离、波动
            float4 _EffectorPlane;
            float4 _PrevEffectorPlane;

            //用于像素着色器的数据
            half4 _EmissionHsvm1;
            half4 _EmissionHsvm2;
            half3 _TransitionColor;
            half3 _LineColor;


            //顶点着色器
            void vert(inout v2g input)
            {

            }

            g2f VertexOutput(
                float3 position0, float3 position1,
                half3 normal0, half3 normal1, half param,
                half emission = 0, half random = 0, half2 baryCoord = 0.5
            )
            {
                g2f i;
                i.pos = UnityObjectToClipPos(float4(lerp(position0, position1, param),1));
                i.normal = normalize(lerp(normal0, normal1, param));
                i.color = float4(baryCoord, emission,random);
                return i;
            }

            // 计算方块的位置和大小
            void CubePosScale(
                float3 center, float size, float rand, float param,
                out float3 pos, out float3 scale
            )
            {
                const float VoxelScale = _VoxelParams.y;
                const float Stretch = _AnimParams.x;
                const float FallDist = _AnimParams.y;
                const float Fluctuation = _AnimParams.z;

                // Noise field
                //噪声场
                float4 snoise = snoise_grad(float3(rand * 2378.34, param * 0.8, 0));

                // Stretch/move param
                float move = saturate(param * 4 - 3);
                move = move * move;

                // Cube position
                pos = center + snoise.xyz * size * Fluctuation;
                pos.y += move * move * lerp(0.25, 1, rand) * size * FallDist;

                // Cube scale anim
                scale = float2(1 - move, 1 + move * Stretch).xyx;
                scale *= size * VoxelScale * saturate(1 + snoise.w * 2);
            }

            //哈希值，用于随机觉得面片是三角面片还是Cube
            float Hash(uint s)
            {
                s = s ^ 2747636419u;
                s = s * 2654435769u;
                s = s ^ (s &gt;&gt; 16);
                s = s * 2654435769u;
                s = s ^ (s &gt;&gt; 16);
                s = s * 2654435769u;
                return float(s) * rcp(4294967296.0); // 2^-32
            }

            //几何着色器
            [maxvertexcount(24)]
            void geom(triangle v2g input[3], uint pid : SV_PrimitiveID, inout TriangleStream&lt;g2f&gt; outStream)
            {
                //获取密度
                const float VoxelDensity = _VoxelParams.x;

                //获取传入顶点的位置
                float3 p0 = input[0].vertex.xyz;
                float3 p1 = input[1].vertex.xyz;
                float3 p2 = input[2].vertex.xyz;

                float3 p0_prev = p0;
                float3 p1_prev = p1;
                float3 p2_prev = p2;

                //获取传入顶点的法线
                float3 n0 = input[0].normal;
                float3 n1 = input[1].normal;
                float3 n2 = input[2].normal;

                //计算中心点
                float3 center = (p0 + p1 + p2) / 3;
                float size = distance(p0, center);

                //变形参数
                //将中心点变换到世界空间中
                float3 center_ws = mul(unity_ObjectToWorld, float4(center,1)).xyz;
                float param = 1 - dot(_EffectorPlane.xyz, center_ws) + _EffectorPlane.w;


                //如果变形还没开始那就将平常操作
                if (param &lt; 0)
                {
                    outStream.Append(VertexOutput(p0, 0, n0, 0, 0, 0, 0));
                    outStream.Append(VertexOutput(p1, 0, n1, 0, 0, 0, 0));
                    outStream.Append(VertexOutput(p2, 0, n2, 0, 0, 0, 0));
                    outStream.RestartStrip();
                    return;
                }


                //变形结束后，不传递任何数据，从而使物体隐身
                if (param &gt;= 1) return;

                // Choose cube/triangle randomly.
                //uint seed = float3(pid * 877, pid * 877, pid * 877);
                uint seed = pid * 877;
                if (Hash(seed) &lt; VoxelDensity)
                {
                    // -- Cube --

                    // Random numbers
                    float rand1 = Hash(seed + 1);
                    float rand2 = Hash(seed + 5);

                    // Cube position and scale
                    float3 pos, pos_prev, scale, scale_prev;
                    CubePosScale(center, size, rand1, param, pos, scale);

                    // Secondary animation parameters
                    float morph = smoothstep(0, 0.25, param);        

                    float em = smoothstep(0, 0.15, param) * 2; // initial emission
                    em = min(em, 1 + smoothstep(0.8, 0.9, 1 - param));
                    em += smoothstep(0.75, 1, param); // emission while falling

                    // Cube points calculation
                    float3 pc0 = pos + float3(-1, -1, -1) * scale;
                    float3 pc1 = pos + float3(+1, -1, -1) * scale;
                    float3 pc2 = pos + float3(-1, +1, -1) * scale;
                    float3 pc3 = pos + float3(+1, +1, -1) * scale;
                    float3 pc4 = pos + float3(-1, -1, +1) * scale;
                    float3 pc5 = pos + float3(+1, -1, +1) * scale;
                    float3 pc6 = pos + float3(-1, +1, +1) * scale;
                    float3 pc7 = pos + float3(+1, +1, +1) * scale;


                    // World space to object space conversion

                    // Vertex outputs
                    float3 nc = float3(-1, 0, 0);
                    outStream.Append(VertexOutput(p0, pc2, n0, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc0, n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p0, pc6, n0, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p2, pc4, n2, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(1, 0, 0);
                    outStream.Append(VertexOutput(p2, pc1, n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p1, pc3, n1, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p2, pc5, n2, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p1, pc7, n1, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, -1, 0);
                    outStream.Append(VertexOutput(p2, pc0, n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc1, n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p2, pc4, n2, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p2, pc5, n2, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, 1, 0);
                    outStream.Append(VertexOutput(p1, pc3, n1, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p0, pc2, n0, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p1, pc7, n1, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p0, pc6, n0, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, 0, -1);
                    outStream.Append(VertexOutput(p2, pc1, n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc0, n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p1, pc3, n1, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p0, pc2, n0, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, 0, 1);
                    outStream.Append(VertexOutput(p2, pc4, -n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc5, -n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p0, pc6, -n0, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p1, pc7, -n1, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();
                }
                else
                {
                    // -- Triangle --
                    half morph = smoothstep(0, 0.25, param);
                    //half morph = 0.25;
                    half em = smoothstep(0, 0.15, param) * 2;
                    outStream.Append(VertexOutput(p0, center, n0, n0, morph, em));
                    outStream.Append(VertexOutput(p1, center, n1, n1, morph, em));
                    outStream.Append(VertexOutput(p2, center, n2, n2, morph, em));
                    outStream.RestartStrip();
                }
            }

            //计算颜色
            half3 SelfEmission(g2f input)
            {
                half2 bcc = input.color.rg;
                half em1 = saturate(input.color.b);
                half em2 = saturate(input.color.b - 1);
                half rand = input.color.a;

                // Cube face color
                half3 face = lerp(_EmissionHsvm1.xyz, _EmissionHsvm2.xyz, rand);
                face *= lerp(_EmissionHsvm1.w, _EmissionHsvm2.w, rand);

                // Cube face attenuation
                face *= lerp(0.75, 1, smoothstep(0, 0.5, length(bcc - 0.5)));

                // Edge detection
                half2 fw = fwidth(bcc);
                half2 edge2 = min(smoothstep(0, fw * 2, bcc),
                    smoothstep(0, fw * 2, 1 - bcc));
                half edge = 1 - min(edge2.x, edge2.y);

                return
                    face * em1 +
                    _TransitionColor * em2 * face +
                    edge * _LineColor * em1;
            }

            half4 frag(g2f z):SV_Target
            {
                half4 col = half4(SelfEmission(z),1);
                return col;
            }
                ENDCG
        }
    }
    FallBack &quot;Diffuse&quot;
}
</code></pre><p>这里运用到了三维噪声的知识，这里我只是简单的调用了K神写好的噪声函数，并没有深究，其实我还是看过了一些关于噪声的文章，以后已机会把笔记总结出来。</p>
<h1 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h1><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/LastEffect.gif" alt="实现思路"></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这个效果对于模型也是有要求的，模型的面片不能太小，不然就会得到以下的结果…</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/Fail.gif" alt="失败效果"></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
</search>
