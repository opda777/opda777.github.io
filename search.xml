<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019年---小记</title>
    <url>/2020/01/07/2019%E5%B9%B4---%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    在三维动画，交互设计等等的课程实训，我掐指一算已经有两个月没有更新自己的笔记了，没办法，我也不知道为什么我这个专业的实训特别特别得多….其实早就放假啦，自己也摸鱼了一个星期恢复下元气。</p>
<p>​    对于2019我感觉还行，虽然没有参加什么比赛，但是在实训课程的过程中还是学到了很多东西，做出来的成品也让我感到满意，所以希望下一年也再接再厉，希望寒假没有摸鱼，能找到实习就最好了，哈哈哈。</p>
<p>​    加油！！！奥利给！！！</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记cover</tag>
      </tags>
  </entry>
  <entry>
    <title>DirectX11入门笔记---3D渲染管线</title>
    <url>/2020/12/19/DirectX11%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0---3D%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
    <content><![CDATA[<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210042177.png" alt="image-20201217210042177" style="zoom: 50%;"></p>
<a id="more"></a>
<h2 id="3D渲染管线"><a href="#3D渲染管线" class="headerlink" title="3D渲染管线"></a>3D渲染管线</h2><p>渲染管线指：如何将3D场景根据摄像机视角生成2D画面</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219220842650.png" alt="image-20201219220842650"></p>
<h3 id="输入装配阶段"><a href="#输入装配阶段" class="headerlink" title="输入装配阶段"></a>输入装配阶段</h3><p>从内存中读取几何数据（顶点和索引）并将这些数据组合为几何图元（三角形，直线等）</p>
<h4 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h4><p>DirectX中的顶点由空间位置和各种附加属性组合而成，我们可以根据自己的需求建立属于我们的顶点格式。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201218215356463.png" alt="image-20201218215356463"></p>
<h4 id="图元拓扑"><a href="#图元拓扑" class="headerlink" title="图元拓扑"></a>图元拓扑</h4><p>顶点是以<strong>顶点缓冲区</strong>的数据结构绑定到图形管线中的，也就是说<strong>顶点缓冲区</strong>只是存储了一个顶点列表，并没有说以什么方式来组织顶点，顶点中连成直线还是三角形？这时候就需要<strong>图元拓扑</strong>来告知Directx顶点以什么方式组成几何图元。</p>
<pre><code>void ID3D11Device::IASetPrimitiveTopology( D3D11_PRIMITIVE_TOPOLOGY Topology);
//比如说设置为直线列表Line list
DirectxDevice-&gt;IASetPrimitiveTopology( D3D11_PRIMITIVE_TOPOLOGY_LINELIST);
</code></pre><p>点列表，每个顶点都被绘制成独立的顶点</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201218215846709.png" alt="image-20201218215846709"></p>
<p>线带，相邻的顶点会连成一条直线</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201218215931439.png" alt="image-20201218215931439"></p>
<p>线列表，每两个顶点会形成一条独立的直线</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201218220238401.png" alt="image-20201218220238401"></p>
<p>三角形带，生成连续的三角形</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219121021600.png" alt="image-20201219121021600"></p>
<p>三角形列表，每三个顶点形成独立的三角形</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219121124685.png" alt="image-20201219121124685"></p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>如下面构成三角形会共享许多顶点，当复制顶点的时候会造成存储空间的浪费</p>
<pre><code>Vertex quad[6] ={ 
v0, v1, v2, // Triangle0
v0, v2, v3, // Triangle1 };

Vertex octagon[24] ={ 
v0, v1, v2, // Triangle0 
v0, v2, v3, // Triangle1 
v0, v3, v4, // Triangle2 
v0, v4, v5, // Triangle3 
v0, v5, v6, // Triangle4 
v0, v6, v7, // Triangle5 
v0, v7, v8, // Triangle6 
v0, v8, v1 // Triangle 7 };
</code></pre><p>不希望对顶点进行复制的原因：</p>
<ol>
<li>增加内存需求量。（为什么要多次存储相同的顶点数据？）</li>
<li>增加图形硬件的处理负担。（为什么要多次处理相同的顶点数据？）</li>
</ol>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219121655223.png" alt="image-20201219121655223"></p>
<p>索引就是为了解决这个问题，我们创建一个顶点列表和一个 索引列表。顶点列表包含所有唯一的顶点，而索引列表包含指向顶点列表的索引值，这些索 引定义了顶点以何种方式组成三角形。</p>
<pre><code>Vertex v[4] = {v0, v1, v2, v3};
UINT indexList[6] = {
0, 1, 2, // Triangle0 
0, 2, 3}; // Triangle 1
</code></pre><p>我们将“复制问题”转嫁给了索引列表，但是这种复制是可以让人接受的。因为： </p>
<ol>
<li><p>索引是简单的整数，不像顶点结构体那样占用很多内存（顶点结构体包含的分量越多，占用的内存就越多）。 </p>
</li>
<li><p>通过适当的顶点缓存排序，图形硬件不必重复处理顶点（在绝大多数的情况下）。</p>
</li>
</ol>
<h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>完成图元装配之后，顶点传入顶点着色器，顶点着色器可以被看成是一个以顶点作为输入输出数据的函数。每个将要绘制的顶点都会通过顶点着色器推送至硬件；</p>
<h4 id="矩阵变换的方法"><a href="#矩阵变换的方法" class="headerlink" title="矩阵变换的方法"></a>矩阵变换的方法</h4><p>1.已知A坐标空间下的X Y Z轴以及原点Q在B空间下的表示，则可以构建变换矩阵</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219125412645.png" alt="image-20201219125412645"></p>
<p>2.将A坐标空间与B坐标空间重合，通常B坐标空间的远点并不是我们想放置A的地方，所以我们通过缩放，旋转，平移将A坐标空间放置在B空间确定的位置，可以确定SRT构成的矩阵就是变换矩阵</p>
<h4 id="模型空间"><a href="#模型空间" class="headerlink" title="模型空间"></a>模型空间</h4><p>每个模型都有自己的坐标空间，模型空间的原点一般在模型的重心</p>
<h4 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h4><p>可以理解为游戏空间，将顶点坐标从模型空间变换到世界空间的变换叫<strong>模型变换</strong></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219125014123.png" alt="image-20201219125014123"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219125026311.png" alt="image-20201219125026311"></p>
<h4 id="观察空间（摄像机空间）"><a href="#观察空间（摄像机空间）" class="headerlink" title="观察空间（摄像机空间）"></a>观察空间（摄像机空间）</h4><p>在观察空间中，摄像机位于原点，以摄像机的观察方向为Z轴正方向，右侧为X轴，上方为Y轴。</p>
<p>从世界空间到观察空间的坐标变换为：<strong>观察变换</strong></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219130700800.png" alt="image-20201219130700800"></p>
<p>同样这里得到变换矩阵的方法有两种：</p>
<p>1.摄像机的原点，X Y Z轴在世界空间的表示我们是可以得到的，这样就可以构建从观察空间到世界空间的变换矩阵，所以逆矩阵就是从世界空间变换到观察空间的变换矩阵</p>
<p>通过摄像机观察方向与世界空间的向上方向构建观察空间在世界空间的坐标轴表示</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219133411662.png" alt="image-20201219133411662"></p>
<p>假设摄像机相对于世界空间的位置为(5, 3, −10)，目标点为世界原点(0, 0,0)。我们可以使用如下代码创建观察矩阵：</p>
<pre><code>XMVECTOR pos = XMVectorSet(5,3,-10,1.0f); 
XMVECTOR target = XMVectorZero(); 
XMVECTOR up = XMVectorSet(0.0f,1.0f,0.0f,0.0f); 
XMMATRIXV = XMMatrixLookAtLH(pos,target,up);
</code></pre><p>2.平移整个观察空间，让摄像机原点与世界坐标原点，坐标轴与世界空间坐标轴重合。</p>
<h4 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h4><p>描述摄像机所能看到的空间范围，通过一个平截头体来描述</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219133825336.png" alt="image-20201219133825336"></p>
<h5 id="定义平截头体"><a href="#定义平截头体" class="headerlink" title="定义平截头体"></a>定义平截头体</h5><p>近平面n，远平面f，垂直FOV a，横纵比r。</p>
<p>纵横比 r = w/h，w为宽度，h为高度，<strong>注意：投影窗口的纵横比要与后台缓冲区的纵横比一致，否则会出现图像变形</strong>，假设h为2，则w=r。</p>
<p>水平FOV b，它是由垂直FOV a和横纵比r决定。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219173740924.png" alt="image-20201219173740924"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219173849286.png" alt="image-20201219173849286"></p>
<h5 id="对顶点进行投影"><a href="#对顶点进行投影" class="headerlink" title="对顶点进行投影"></a>对顶点进行投影</h5><p>给出一个点 (<em>x, y, z</em>)，求它在投影平面 <em>z</em> = <em>d</em> 上的投影点 (<em>x</em>ʹ, <em>y</em>ʹ, <em>d</em>)。通过下图可以通过相似三角形得到<em>x</em>ʹ  <em>y</em>ʹ。前提条件：假设h为2，则w=r。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219174747257.png" alt="image-20201219174747257"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219174816758.png" alt="image-20201219174816758"></p>
<p>当且仅当以下条件成立时，点(x, y , z)在平截头体内。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219174833941.png" alt="image-20201219174833941"></p>
<h5 id="规范化设备坐标（NDC）"><a href="#规范化设备坐标（NDC）" class="headerlink" title="规范化设备坐标（NDC）"></a>规范化设备坐标（NDC）</h5><p>将平截头体缩放到X，Y在[-1,1]，Z在[0,1]的立方体内</p>
<h5 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h5><p>参考文章：<a href="https://www.cnblogs.com/bluebean/p/5276111.html" target="_blank" rel="noopener">https://www.cnblogs.com/bluebean/p/5276111.html</a></p>
<p>只不过这篇文章是Opengl，Z轴在[-1，1]内，所以我重新推导Directx，有错请多多包涵</p>
<p>已知：近平面d，远平面f，垂直FOV a，横纵比r，宽度w，高度h</p>
<p>根据侧面三角形可得</p>
<script type="math/tex; mode=display">
tan(\frac{a}{2}) = \frac{\frac{H}{2}}{d}\\
d=\frac{h}{2*tan(\frac{a}{2})}</script><p>根据相似三角形可得</p>
<script type="math/tex; mode=display">
\frac{x_1}{x} = \frac{d}{z}=>x_1=\frac{xd}{z}=\frac{xh}{2*z*tan(\frac{a}{2})} \\
\frac{y_1}{y} = \frac{d}{z}=>y_1=\frac{yd}{z}=\frac{yh}{2*z*tan(\frac{a}{2})}</script><p>这是$x_1,y_1$的范围在$[-\frac{w}{2},\frac{w}{2}]$和$[-\frac{h}{2},\frac{h}{2}]$之间，我们要把范围缩放到[-1,1]内，所以要除以$\frac{w}{2},\frac{h}{2}$即可</p>
<script type="math/tex; mode=display">
其中横纵比r=\frac{w}{h} \\
x_2=\frac{x_1}{\frac{w}{2}}=\frac{xh}{z*w*tan(\frac{a}{2})}=\frac{x}{z*r*tan(\frac{a}{2})} \\
y_2=\frac{y_1}{\frac{h}{2}}=\frac{y}{z*tan(\frac{a}{2})}</script><p>假设$z_2$为[0,1]，所以我们最后的坐标为</p>
<script type="math/tex; mode=display">
(\frac{x}{z*r*tan(\frac{a}{2})},\frac{y}{z*tan(\frac{a}{2})},z_2)</script><p>接下来是构建矩阵</p>
<script type="math/tex; mode=display">
\begin{bmatrix}            
   x & y & z & 1 \\            
  \end{bmatrix} * 
  \begin{bmatrix}
  m00 & m01 & m02 & m03 \\
  m10 & m11 & m12 & m13 \\
  m20 & m21 & m22 & m23 \\
  m30 & m31 & m32 & m33 \\
  \end{bmatrix}=
  \begin{bmatrix}            
   \frac{x}{z*r*tan(\frac{a}{2})} & \frac{y}{z*tan(\frac{a}{2})} & z_2 & 1 \\            
  \end{bmatrix}</script><p>可以看到无法求解下列方程，那是因为z当分母的原因</p>
<script type="math/tex; mode=display">
x*m00+y*m10+z*m20+m30=\frac{x}{z*r*tan(\frac{a}{2})}</script><p>我们只要将最右边向量每一项都乘以z即可</p>
<script type="math/tex; mode=display">
\begin{bmatrix}            
   x & y & z & 1 \\            
  \end{bmatrix} * 
  \begin{bmatrix}
  m00 & m01 & m02 & m03 \\
  m10 & m11 & m12 & m13 \\
  m20 & m21 & m22 & m23 \\
  m30 & m31 & m32 & m33 \\
  \end{bmatrix}=
  \begin{bmatrix}            
   \frac{x}{r*tan(\frac{a}{2})} & \frac{y}{tan(\frac{a}{2})} & z*z_2 & z \\            
  \end{bmatrix}</script><p>求得矩阵为</p>
<script type="math/tex; mode=display">
\begin{bmatrix}            
   \frac{x}{r*tan(\frac{a}{2})} & 0 & 0 & 0 \\    
   0 & \frac{y}{tan(\frac{a}{2})} & 0 & 0 \\    
   0 & 0 & m22 & 1 \\    
   0 & 0 & m32 & 0 \\    
  \end{bmatrix}</script><p>我们可以建立方程求解m22，m32</p>
<script type="math/tex; mode=display">
m22*z+m32=z*z_2\\
=>m22+\frac{m32}{z}=z_2\\
当z=d时,z_2=0,当z=f,z_2=1\\
\begin{cases}
m22+\frac{m32}{d} = 0 \\
m22+\frac{m32}{f} = 1 \\
\end{cases}
解得：m22=\frac{f}{f-d}\ \ \ m32=-\frac{fd}{f-d}</script><p>所以最后的矩阵为</p>
<script type="math/tex; mode=display">
\begin{bmatrix}            
   \frac{x}{r*tan(\frac{a}{2})} & 0 & 0 & 0 \\    
   0 & \frac{y}{tan(\frac{a}{2})} & 0 & 0 \\    
   0 & 0 & \frac{f}{f-d} & 1 \\    
   0 & 0 & -\frac{fd}{f-d} & 0 \\    
  \end{bmatrix}</script><p>在与投影矩阵相乘之后，进行透视除法之前，几何体所处的空间为裁剪空间。透视除法(即每个分量都除以第四个分量w)之后，几何体处于NDC内。</p>
<h5 id="Directx函数得到投影矩阵"><a href="#Directx函数得到投影矩阵" class="headerlink" title="Directx函数得到投影矩阵"></a>Directx函数得到投影矩阵</h5><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219213147479.png" alt="image-20201219213147479"></p>
<h3 id="曲面细分着色器-可选"><a href="#曲面细分着色器-可选" class="headerlink" title="曲面细分着色器(可选)"></a>曲面细分着色器(可选)</h3><p>曲面细分（Tessellation）是指通过添加三角形的方式对一个网格的三角形进行细分，这些新添加的三角形可以偏移到一个新的位置，让网格的细节更加丰富。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219213305777.png" alt="image-20201219213305777"></p>
<p>优点：</p>
<ol>
<li>我们可以通过曲面细分实现细节层次（level -of-detai l，LOD），使靠近相机的三角形通过细分产生更多细节，而那些远离相机的三角形则保持不变。</li>
<li>我们可以在内存中保存一个低细节（低细节意味着三角形数量少）的网格，但可以实时地添加额外的三角形，这样可以节省内存。</li>
<li>我们可以在一个低细节的网格上处理动画和物理效果，而只在渲染时才使用细分过的高细节网格。</li>
</ol>
<h3 id="几何着色器-可选"><a href="#几何着色器-可选" class="headerlink" title="几何着色器(可选)"></a>几何着色器(可选)</h3><p>几何着色器阶段（geometry shader stage）是可选的，几何着色器以完整的图元作为输入数据，几何着色器的主要优势是它可以创建或销毁几何体。</p>
<p><strong>注意</strong>：顶点位置在离开几何着色器之前，必须被变换到齐次裁剪空间。 </p>
<h3 id="裁剪阶段"><a href="#裁剪阶段" class="headerlink" title="裁剪阶段"></a>裁剪阶段</h3><p>我们必须完全丢弃在平截头体之外的几何体，裁剪与平截头体边界相交的几何体，只留下平截头体内的部分，这个时系统自动帮我们完成的，所以我就不深入了解了。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219213750375.png" alt="image-20201219213750375"></p>
<h3 id="视口变换-屏幕空间"><a href="#视口变换-屏幕空间" class="headerlink" title="视口变换(屏幕空间)"></a>视口变换(屏幕空间)</h3><p>在裁剪之后，硬件会自动执行透视除法，将顶点从齐次裁剪空间变换到规范化设备空间（NDC）。然后将xy坐标映射到屏幕像素坐标），通常，视口变换不修改 <em>z</em> 坐标，因为 <em>z</em> 坐标还要由深度缓存使用，但是我们可以通过 </p>
<p><strong>D3D11_VIEWPORT</strong> 结构体的 <strong>MinDepth</strong> 和 <strong>MaxDepth</strong> 值修改 z 坐标的取值范围。</p>
<h3 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h3><p>光栅化（rasterization）阶段的主要任务是为投影后的 3D 三角形计算像素颜色。</p>
<h4 id="背面消隐"><a href="#背面消隐" class="headerlink" title="背面消隐"></a>背面消隐</h4><p>一个三角形有两个面。我们使用如下约定来区分这两个面。根据约定好的顶点绕序删除三角形背面，减少GPU负担。</p>
<h4 id="顶点属性插值"><a href="#顶点属性插值" class="headerlink" title="顶点属性插值"></a>顶点属性插值</h4><p>我们通过指定三角形的 3 个顶点来定义一个三角形。除位置外，顶点还可以包含其他属性，比如颜色、法线向量和纹理坐标。在视口变换之后，这些属性必须为三角形表面上的每个像素进行插值。这里需要用到<strong>透视矫正插值</strong>才能插值正确。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201219222735513.png" alt="image-20201219222735513"></p>
<h3 id="像素着色器"><a href="#像素着色器" class="headerlink" title="像素着色器"></a>像素着色器</h3><p>像素着色器（Pixel shader）是由我们编写的在 GPU 上执行的程序。像素着色器会处理 每个像素片段（pixel fragment），它的输入是插值后的顶点属性，由此计算出一个颜色。像素着色器可以非常简单地输出一个颜色，也可以很复杂，例如实现逐像素光照、反射和阴影等效果。</p>
<h3 id="输出合并阶段"><a href="#输出合并阶段" class="headerlink" title="输出合并阶段"></a>输出合并阶段</h3><p>经过像素着色器处理后的片元会被传输到输出合并阶段，未能通过深度测试和模板测试的片段将会被丢弃，最后通过测试的片元会与后台缓冲区进行混合。</p>
]]></content>
      <categories>
        <category>DirectX11</category>
      </categories>
      <tags>
        <tag>DirectX11</tag>
      </tags>
  </entry>
  <entry>
    <title>DirectX11入门笔记---创建几何体以及添加BaseObject类</title>
    <url>/2020/12/29/DirectX11%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0---%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E5%87%A0%E4%BD%95%E4%BD%93/</url>
    <content><![CDATA[<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210042177.png" alt="image-20201217210042177" style="zoom: 50%;"></p>
<a id="more"></a>
<h2 id="GeometryCreator工具类"><a href="#GeometryCreator工具类" class="headerlink" title="GeometryCreator工具类"></a>GeometryCreator工具类</h2><p>为了后续更加方便地添加cube物体，需要一个工具类来生成模型数据，比如顶点属性和索引数组，这里我只需要生成Plane和Cube</p>
<pre><code>#pragma once
#include &lt;DirectXMath.h&gt;
#include &quot;ShaderStruct.h&quot;
using namespace DirectX;

//用于程序化生成常用模型的GeometryCreator工具类
class GeometryCreator
{
public:    
    //创造Plane的顶点数组和索引数组
    static GeoData CreatePlane(float width, float height, UINT gridRow, UINT gridCol);

    //创建Cube的顶点数组和索引数组
    static GeoData CreateCube(float width, float height, float depth);
};
</code></pre><p>GeoData是一个保存了顶点属性和索引的结构体</p>
<pre><code>//与HLSL对应的C++顶点属性
struct VertexAttribute
{
    XMFLOAT4 vertexPosition;
    XMFLOAT3 normal;
    XMFLOAT2 uv;
    XMFLOAT4 color;

};

//用于保存VertexAttribute数据和索引数据
struct GeoData
{
    std::vector&lt;VertexAttribute&gt; vertexs;
    std::vector&lt;UINT&gt; indexs;
};
</code></pre><h3 id="Plane"><a href="#Plane" class="headerlink" title="Plane"></a>Plane</h3><p>首先我们要指定Plane的宽度和高度，行列数，从左上角一直嵌套for循环处理即可</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/1356268522_8860.png" alt="1356268522_8860"></p>
<p>处理索引的方法，一定要顺时针处理索引</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/1356269070_5100.png" alt="1356269070_5100"></p>
<pre><code>GeoData GeometryCreator::CreatePlane(float width, float height, UINT gridRow, UINT gridCol)
{
    GeoData geoData;
    //首先获取行列顶点数
    UINT vertexRow_Num = gridRow + 1;
    UINT vertexCol_Num = gridCol + 1;

    //计算起点坐标
    float originPos_X = -width * 0.5f;
    float originPos_Z = height * 0.5f;

    //顶点之间距离
    float dx = width / gridCol;
    float dz = height / gridRow;
    //重新分配容器内存大小
    geoData.vertexs.resize(vertexRow_Num * vertexCol_Num);
    //填充geoData的VertexAttribute
    for (size_t i = 0; i &lt; vertexRow_Num; i++)
    {
        float tempZ = originPos_Z - dz * i;
        for (size_t j = 0; j &lt; vertexCol_Num; j++)
        {
            //计算当前顶点的索引
            UINT index = vertexRow_Num * i + j;
            geoData.vertexs[index].vertexPosition = XMFLOAT4(originPos_X + dx * j, 0.0f, 
                tempZ, 1.0f);
            geoData.vertexs[index].normal = XMFLOAT3(0.0f, 1.0f, 0.0f);
            geoData.vertexs[index].uv = XMFLOAT2(i * (1.0f / gridCol), j * (1.0f / gridRow));
            geoData.vertexs[index].color = XMFLOAT4(1.0f, 0.0f, 0.0f, 1.0f);
        }
    }

    //填充索引，思路：将每个矩形沿对角线拆分成两个三角形
    //重新分配容器内存大小,总共有row*col个格子，一个格子里有6个索引
    geoData.indexs.resize(gridRow * gridCol * 6);

    UINT temp = 0;
    /*
        A___________B
        |            |
        |            |
        |            |
        C___________D

        A - B - C
        C - B - D
    */
    //进行填充
    for (size_t i = 0; i &lt; gridRow; i++)
    {
        for (size_t j = 0; j &lt; gridCol; j++)
        {
            geoData.indexs[temp] = i * vertexCol_Num + j;    //A
            geoData.indexs[temp + 1] = i * vertexCol_Num + j + 1;    //B
            geoData.indexs[temp + 2] = (i + 1) * vertexCol_Num + j;    //C
            geoData.indexs[temp + 3] = (i + 1) * vertexCol_Num + j;    //C
            geoData.indexs[temp + 4] = i * vertexCol_Num + j + 1;    //B
            geoData.indexs[temp + 5] = (i + 1) * vertexCol_Num + j + 1;    //D

            //进行下一个矩形
            temp += 6;
        }
    }

    return geoData;
}
</code></pre><h3 id="Cube"><a href="#Cube" class="headerlink" title="Cube"></a>Cube</h3><p>Cube的话比较简单，主要区分好面的朝向即可，不要手抖写错，主要包含24个顶点，一个顶点要重复3次，因为一个顶点会有3个面相连接，所以有3个法向量。</p>
<pre><code>GeoData GeometryCreator::CreateCube(float width, float height, float depth)
{
    // ******************
    // 设置立方体顶点
    //     ________ 
    //    /|      /|
    //   /_|_____/ |
    //   | |_ _  |_|
    //   | /     | /
    //   |/______|/
    //          


    //包含24个顶点，36个索引
    GeoData geoData;
    //重新分配内存大小
    geoData.vertexs.resize(24);
    float hw = width / 2.0f;
    float hh = height / 2.0f;
    float hd = depth / 2.0f;
    //上
    geoData.vertexs[0].vertexPosition = XMFLOAT4(-hw, hh, -hd, 1.0f);
    geoData.vertexs[1].vertexPosition = XMFLOAT4(-hw, hh, hd, 1.0f);
    geoData.vertexs[2].vertexPosition = XMFLOAT4(hw, hh, hd, 1.0f);
    geoData.vertexs[3].vertexPosition = XMFLOAT4(hw, hh, -hd, 1.0f);
    //下
    geoData.vertexs[4].vertexPosition = XMFLOAT4(-hw, -hh, hd, 1.0f);
    geoData.vertexs[5].vertexPosition = XMFLOAT4(-hw, -hh, -hd, 1.0f);
    geoData.vertexs[6].vertexPosition = XMFLOAT4(hw, -hh, -hd, 1.0f);
    geoData.vertexs[7].vertexPosition = XMFLOAT4(hw, -hh, hd, 1.0f);
    //左
    geoData.vertexs[8].vertexPosition = XMFLOAT4(-hw, -hh, hd, 1.0f);
    geoData.vertexs[9].vertexPosition = XMFLOAT4(-hw, hh, hd, 1.0f);
    geoData.vertexs[10].vertexPosition = XMFLOAT4(-hw, hh, -hd, 1.0f);
    geoData.vertexs[11].vertexPosition = XMFLOAT4(-hw, -hh, -hd, 1.0f);
    //右
    geoData.vertexs[12].vertexPosition = XMFLOAT4(hw, -hh, -hd, 1.0f);
    geoData.vertexs[13].vertexPosition = XMFLOAT4(hw, hh, -hd, 1.0f);
    geoData.vertexs[14].vertexPosition = XMFLOAT4(hw, hh, hd, 1.0f);
    geoData.vertexs[15].vertexPosition = XMFLOAT4(hw, -hh, hd, 1.0f);
    //前
    geoData.vertexs[16].vertexPosition = XMFLOAT4(-hw, -hh, -hd, 1.0f);
    geoData.vertexs[17].vertexPosition = XMFLOAT4(-hw, hh, -hd, 1.0f);
    geoData.vertexs[18].vertexPosition = XMFLOAT4(hw, hh, -hd, 1.0f);
    geoData.vertexs[19].vertexPosition = XMFLOAT4(hw, -hh, -hd, 1.0f);
    //后
    geoData.vertexs[20].vertexPosition = XMFLOAT4(hw, -hh, hd, 1.0f);
    geoData.vertexs[21].vertexPosition = XMFLOAT4(hw, hh, hd, 1.0f);
    geoData.vertexs[22].vertexPosition = XMFLOAT4(-hw, hh, hd, 1.0f);
    geoData.vertexs[23].vertexPosition = XMFLOAT4(-hw, -hh, hd, 1.0f);

    //填充法线和颜色
    for (size_t i = 0; i &lt; 4; i++)
    {
        //上
        geoData.vertexs[i].normal = XMFLOAT3(0.0f,1.0f,0.0f);
        geoData.vertexs[i].color = XMFLOAT4(0.0f, 1.0f, 0.3f, 1.0f);
        //下
        geoData.vertexs[i+4].normal = XMFLOAT3(0.0f, -1.0f, 0.0f);
        geoData.vertexs[i+4].color = XMFLOAT4(0.0f, 1.0f, 0.3f, 1.0f);
        //左
        geoData.vertexs[i+8].normal = XMFLOAT3(-1.0f, 0.0f, 0.0f);
        geoData.vertexs[i+8].color = XMFLOAT4(0.0f, 1.0f, 0.3f, 1.0f);
        //右
        geoData.vertexs[i+12].normal = XMFLOAT3(1.0f, 0.0f, 0.0f);
        geoData.vertexs[i+12].color = XMFLOAT4(0.0f, 1.0f, 0.3f, 1.0f);
        //前
        geoData.vertexs[i+16].normal = XMFLOAT3(0.0f, 0.0f, -1.0f);
        geoData.vertexs[i+16].color = XMFLOAT4(0.0f, 1.0f, 0.3f, 1.0f);
        //后
        geoData.vertexs[i+20].normal = XMFLOAT3(0.0f, 0.0f, 1.0f);
        geoData.vertexs[i+20].color = XMFLOAT4(0.0f, 1.0f, 0.3f, 1.0f);
    }

    //计算UV
    for (size_t i = 0; i &lt; 6; i++)
    {
        geoData.vertexs[i * 4].uv = XMFLOAT2(0.0f, 1.0f);
        geoData.vertexs[i * 4+1].uv = XMFLOAT2(0.0f, 0.0f);
        geoData.vertexs[i * 4+2].uv = XMFLOAT2(1.0f, 0.0f);
        geoData.vertexs[i * 4+3].uv = XMFLOAT2(1.0f, 1.0f);
    }

    //填充索引
    geoData.indexs.resize(36);
    geoData.indexs =
    {
        0, 1, 2, 2, 3, 0,        // 上
        4, 5, 6, 6, 7, 4,        // 下
        8, 9, 10, 10, 11, 8,    // 左
        12, 13, 14, 14, 15, 12,    // 右
        16, 17, 18, 18, 19, 16, // 前
        20, 21, 22, 22, 23, 20    // 后

    };

    return geoData;
</code></pre><h2 id="细分常量缓冲区"><a href="#细分常量缓冲区" class="headerlink" title="细分常量缓冲区"></a>细分常量缓冲区</h2><p>我们之前的常量缓冲区为了方便把MVP矩阵都放在一个常量缓冲区里面，但是通常的情况是根据变量的修改的频繁程度来创建不同的常量缓冲，所以我们WVP缓冲区给细分为3个常量缓冲，这是因为每个物体的worldMatrix都会不一样，所以每绘制一个物体都要刷新一遍，然后摄像机的viewMatrix只要每帧刷新一遍即可，projMatrix则根据屏幕的大小有没有改变来刷新。</p>
<pre><code>//旧
//常量缓冲区对应的数据结构
struct ConstantBufferStruct
{
    XMMATRIX worldMatrix;
    XMMATRIX viewMatrix;
    XMMATRIX projMatrix;
};

//新
cbuffer cbWorld : register(b0)
{
    matrix WorldMatrix;
}

cbuffer cbView : register(b1)
{
    matrix ViewMatrix;
}

cbuffer cbProj : register(b2)
{
    matrix ProjMatrix;
}
</code></pre><p>同时我们在OpdaGraphics::InitResource中创建相对应的常量缓冲区，并绑定到顶点着色器</p>
<pre><code>    //设置常量缓冲区描述
    D3D11_BUFFER_DESC constantBufferDesc;
    ZeroMemory(&amp;constantBufferDesc, sizeof(constantBufferDesc));
    //由于常量缓冲区大多数需要频繁更新，所以需要设置为
    constantBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
    constantBufferDesc.ByteWidth = sizeof(cbWorld);
    constantBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
    //需要CPU写入矩阵数据
    constantBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

    //直接新建常量缓冲区，无需初始化数据
    DirectxDevice-&gt;CreateBuffer(&amp;constantBufferDesc, nullptr, constantBuffer[0].GetAddressOf());
    constantBufferDesc.ByteWidth = sizeof(cbView);
    DirectxDevice-&gt;CreateBuffer(&amp;constantBufferDesc, nullptr, constantBuffer[1].GetAddressOf());
    constantBufferDesc.ByteWidth = sizeof(cbProj);
    DirectxDevice-&gt;CreateBuffer(&amp;constantBufferDesc, nullptr, constantBuffer[2].GetAddressOf());

    //用于更新常量缓冲区
    cbWorld cbW;
    cbW.WorldMatrix = XMMatrixIdentity();//单位矩阵
    //创建view变换矩阵
    cbView cbV;
    XMVECTOR pos = XMVectorSet(0.0f, 1.0f, -5.0f, 0.0f);
    XMVECTOR target = XMVectorSet(0.0f, 0.0f, 0.0f, 0.0f);
    XMVECTOR up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);
    cbV.ViewMatrix = XMMatrixTranspose( XMMatrixLookAtLH(pos, target, up));

    //创建Proj变换矩阵
    cbProj cbP;
    cbP.ProjMatrix = XMMatrixTranspose(XMMatrixPerspectiveFovLH(XM_PIDIV2, 640.0f / 480.0f, 1.0f, 1000.0f));

    //用于存储map函数获取到缓冲区的内存
    D3D11_MAPPED_SUBRESOURCE mappedData;
    DirectxDeviceContext-&gt;Map(constantBuffer[0].Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedData);
    //安全内存复制，将cbstruct复制到pData
    memcpy_s(mappedData.pData, sizeof(cbWorld), &amp;cbW, sizeof(cbWorld));
    //关闭常量缓冲区的访问权限
    DirectxDeviceContext-&gt;Unmap(constantBuffer[0].Get(), 0);

    //用于存储map函数获取到缓冲区的内存
    DirectxDeviceContext-&gt;Map(constantBuffer[1].Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedData);
    //安全内存复制，将cbstruct复制到pData
    memcpy_s(mappedData.pData, sizeof(cbView), &amp;cbV, sizeof(cbView));
    //关闭常量缓冲区的访问权限
    DirectxDeviceContext-&gt;Unmap(constantBuffer[1].Get(), 0);

    //用于存储map函数获取到缓冲区的内存
    DirectxDeviceContext-&gt;Map(constantBuffer[2].Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedData);
    //安全内存复制，将cbstruct复制到pData
    memcpy_s(mappedData.pData, sizeof(cbProj), &amp;cbP, sizeof(cbProj));
    //关闭常量缓冲区的访问权限
    DirectxDeviceContext-&gt;Unmap(constantBuffer[2].Get(), 0);

    //将常量缓冲区绑定到渲染管线
    DirectxDeviceContext-&gt;VSSetConstantBuffers(0, 1, constantBuffer[0].GetAddressOf());
    DirectxDeviceContext-&gt;VSSetConstantBuffers(1, 1, constantBuffer[1].GetAddressOf());
    DirectxDeviceContext-&gt;VSSetConstantBuffers(2, 1, constantBuffer[2].GetAddressOf());
</code></pre><h2 id="BaseObject类"><a href="#BaseObject类" class="headerlink" title="BaseObject类"></a>BaseObject类</h2><p>此类是为了更加方便地管理场景中的物体，没必要把代码全塞在OpdaGraphics里面，把物体创建绑定顶点缓冲区和索引缓冲区的操作抽象出来构造BaseObject类。</p>
<p>BaseObject的任务主要有两个：</p>
<p><strong>1.利用GeoData数据创建顶点索引缓冲，进行初始化</strong></p>
<p><strong>2.将顶点索引缓冲区绑定到渲染管线，更新常量缓冲区的数据，进行物体的绘制</strong></p>
<pre><code>class BaseObject
{
public:
    BaseObject();
    //重新设置顶点缓冲区和索引缓冲区
    void CreateVertexIndexBuffer(ID3D11Device* directxdevice, const GeoData&amp; geoData);
    //进行渲染
    void Render(ID3D11DeviceContext* directxDeviceContext);

public:
    cbWorld cbW;

private:
    //顶点缓冲区
    ComPtr&lt;ID3D11Buffer&gt; vertexBuffer;
    //索引缓冲区
    ComPtr&lt;ID3D11Buffer&gt; indexBuffer;
    //索引总数
    UINT totalIndex;
};INT totalIndex;
};
</code></pre><h3 id="XXGetConstantBuffers—-获得某一着色阶段的常量缓冲区"><a href="#XXGetConstantBuffers—-获得某一着色阶段的常量缓冲区" class="headerlink" title="XXGetConstantBuffers—-获得某一着色阶段的常量缓冲区"></a>XXGetConstantBuffers—-获得某一着色阶段的常量缓冲区</h3><p>利用这个方法我们就可以获取顶点着色器绑定的指定常量缓冲区</p>
<pre><code>void ID3D11DeviceContext::VSGetConstantBuffers( 
    UINT StartSlot,     // [In]指定的起始槽索引
    UINT NumBuffers,    // [In]常量缓冲区数目 
    ID3D11Buffer **ppConstantBuffers) = 0;    // [Out]常量固定缓冲区数组
</code></pre><pre><code>#include &quot;BaseObject.h&quot;

BaseObject::BaseObject()
{
    cbW.WorldMatrix = XMMatrixIdentity();
    totalIndex = 0;
}

void BaseObject::CreateVertexIndexBuffer(ID3D11Device* directxdevice, const GeoData&amp; geoData)
{
    //释放资源
    vertexBuffer.Reset();
    indexBuffer.Reset();


    //创建顶点缓冲区描述
    D3D11_BUFFER_DESC vertexBufferDesc;
    //初始化内存块
    ZeroMemory(&amp;vertexBufferDesc, sizeof(vertexBufferDesc));
    //因为后续顶点不在改变
    vertexBufferDesc.Usage = D3D11_USAGE_IMMUTABLE;
    //内存块大小
    vertexBufferDesc.ByteWidth = geoData.vertexs.size() * sizeof(VertexAttribute);
    vertexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
    //CPU访问权限
    vertexBufferDesc.CPUAccessFlags = 0;
    vertexBufferDesc.MiscFlags = 0;
    vertexBufferDesc.StructureByteStride = 0;

    //初始化数据
    D3D11_SUBRESOURCE_DATA InitData;
    //初始化内存块
    ZeroMemory(&amp;InitData, sizeof(InitData));
    InitData.pSysMem = geoData.vertexs.data();

    //创建顶点缓冲区
    directxdevice-&gt;CreateBuffer(&amp;vertexBufferDesc, &amp;InitData, vertexBuffer.GetAddressOf());

    //获取索引总数
    totalIndex = (UINT)geoData.indexs.size();
    //创建索引缓冲区描述
    D3D11_BUFFER_DESC indexBufferDesc;
    //初始化内存块
    ZeroMemory(&amp;indexBufferDesc, sizeof(indexBufferDesc));
    //后续索引不再改变
    indexBufferDesc.Usage = D3D11_USAGE_IMMUTABLE;
    //内存块大小
    indexBufferDesc.ByteWidth = geoData.indexs.size() * sizeof(UINT);
    indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
    //CPU访问权限
    indexBufferDesc.CPUAccessFlags = 0;
    indexBufferDesc.MiscFlags = 0;
    indexBufferDesc.StructureByteStride = 0;

    InitData.pSysMem = geoData.indexs.data();
    //创建索引缓冲区
    directxdevice-&gt;CreateBuffer(&amp;indexBufferDesc, &amp;InitData, indexBuffer.GetAddressOf());
}

void BaseObject::Render(ID3D11DeviceContext* directxDeviceContext)
{
    //设置顶点索引缓冲区
    UINT pStride = sizeof(VertexAttribute);
    UINT offset = 0;
    //起始插槽    缓冲区数量    缓冲区元素字节大小    字节偏移量
    directxDeviceContext-&gt;IASetVertexBuffers(0, 1, vertexBuffer.GetAddressOf(), &amp;pStride, &amp;offset);
    directxDeviceContext-&gt;IASetIndexBuffer(indexBuffer.Get(), DXGI_FORMAT_R32_UINT, 0);

    //获取绑定到渲染管线上的常量缓冲区
    ComPtr&lt;ID3D11Buffer&gt; constantBuffer;
    directxDeviceContext-&gt;VSGetConstantBuffers(0,1,constantBuffer.GetAddressOf());


    //更新常量缓冲区
    D3D11_MAPPED_SUBRESOURCE mappedData;
    directxDeviceContext-&gt;Map(constantBuffer.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedData);
    memcpy_s(mappedData.pData, sizeof(cbWorld), &amp;cbW, sizeof(cbWorld));
    directxDeviceContext-&gt;Unmap(constantBuffer.Get(), 0);

    //可以绘制了
    directxDeviceContext-&gt;DrawIndexed(totalIndex, 0, 0);
}
</code></pre><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>首先我们需要在OpdaGraphics::InitResource中进行顶点索引缓冲区的创建</p>
<pre><code>plane.CreateVertexIndexBuffer(DirectxDevice, GeometryCreator::CreatePlane(10.0f, 10.0f, 1, 1));
    cube.CreateVertexIndexBuffer(DirectxDevice, GeometryCreator::CreateCube(2.0f, 2.0f, 2.0f));
</code></pre><p>OpdaGraphics::UpdateScene中更新物体的worldMatrix</p>
<pre><code>cube.cbW.WorldMatrix = XMMatrixTranspose(XMMatrixRotationX(RotateX)* XMMatrixRotationY(RotateY));
    plane.cbW.WorldMatrix = XMMatrixTranspose(XMMatrixRotationX(RotateX) * XMMatrixRotationY(RotateY));
</code></pre><p>最后在OpdaGraphics::RenderScene中调用物体的Render函数</p>
<pre><code>cube.Render(DirectxDeviceContext);
plane.Render(DirectxDeviceContext);
</code></pre>]]></content>
      <categories>
        <category>DirectX11</category>
      </categories>
      <tags>
        <tag>DirectX11</tag>
      </tags>
  </entry>
  <entry>
    <title>DirectX11入门笔记---第三方库的安装</title>
    <url>/2020/12/26/DirectX11%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0---%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210042177.png" alt="image-20201217210042177" style="zoom: 50%;"></p>
<a id="more"></a>
<h2 id="VCPkg—-安装Assimp"><a href="#VCPkg—-安装Assimp" class="headerlink" title="VCPkg—-安装Assimp"></a>VCPkg—-安装Assimp</h2><p>VCPkg相当于Python pip，是用于安装第三方库非常方便的一个工具</p>
<p>github :<a href="https://github.com/Microsoft/vcpkg" target="_blank" rel="noopener">https://github.com/Microsoft/vcpkg</a></p>
<p>直接下载解压到某个你喜欢的位置，官方推荐以下位置</p>
<pre><code>C:\src\vcpkg
</code></pre><p>解压完毕之后就可以点击bootstrap-vcpkg.bat，就完成安装了，最后我们还要设置环境变量才能在cmd中快速使用</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201226191539107.png" alt="image-20201226191539107"></p>
<p>利用命令进行第三方库的查询与安装</p>
<pre><code>vcpkg search assimp//查询功能
vcpkg install assimp//安装功能
</code></pre><p>集成到Vs2019中，这样就可以直接#include了</p>
<pre><code>vcpkg integrate install
</code></pre><p>注意：当你继承到VS2019之后想要卸载vcpkg，要使用命令确保卸载前清理好集成</p>
<pre><code>vcpkg integrate remove
</code></pre><h3 id="出现的坑"><a href="#出现的坑" class="headerlink" title="出现的坑"></a>出现的坑</h3><p>我第一次安装的出现报错</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201226191829240.png" alt="image-20201226191829240"></p>
<p>解决方法：给你的VS安装英语语言包</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201226192041656.png" alt="image-20201226192041656"></p>
<h2 id="NuGet—-安装DirectXTex"><a href="#NuGet—-安装DirectXTex" class="headerlink" title="NuGet—-安装DirectXTex"></a>NuGet—-安装DirectXTex</h2><p>由于我们使用的DirectX SDK已经被集成进Windows SDK，问题是Windows SDK移除了对d3dx.h头文件，所以造成纹理贴图的导入函数并不能使用，幸运的是问题不大，官方给出了替代方法</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201226195442714.png" alt="image-20201226195442714"></p>
<p>官方把D3DX11CreateShaderResourceViewFromFile抽取到了DirectXTex库，所以我们现在的任务就是导入DirectXTex库。</p>
<h3 id="NuGet"><a href="#NuGet" class="headerlink" title="NuGet"></a>NuGet</h3><p>NuGet 其实也是一个第三方库的管理工具，相当于Python 的pip（这个我也没搞懂Nuget和vcpkg的不同之处）</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201226200325346.png" alt="image-20201226200325346"></p>
<p>打开之后，搜索DirectXTex安装即可</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201226200430333.png" alt="image-20201226200430333"></p>
<h3 id="出现的坑-1"><a href="#出现的坑-1" class="headerlink" title="出现的坑"></a>出现的坑</h3><p>问题例子：<a href="https://blog.csdn.net/kunlunjunzi/article/details/77970949" target="_blank" rel="noopener">https://blog.csdn.net/kunlunjunzi/article/details/77970949</a></p>
<p>只需要与DirectXTex的运行库设置一致即可</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201226201121962.png" alt="image-20201226201121962"></p>
]]></content>
      <categories>
        <category>DirectX11</category>
      </categories>
      <tags>
        <tag>DirectX11</tag>
      </tags>
  </entry>
  <entry>
    <title>DirectX11入门笔记---添加第三人称摄像机和diffuse光照</title>
    <url>/2020/12/29/DirectX11%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0---%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%91%84%E5%83%8F%E6%9C%BA%E5%92%8Cdiffuse%E5%85%89%E7%85%A7/</url>
    <content><![CDATA[<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210042177.png" alt="image-20201217210042177" style="zoom: 50%;"></p>
<a id="more"></a>
<h2 id="第三人称摄像机"><a href="#第三人称摄像机" class="headerlink" title="第三人称摄像机"></a>第三人称摄像机</h2><p>之前我们已经把baseObject抽象出来了，但是ViewMatrix和proJMatrix还是在Opda::InitResource中创建初始化的，对我们后续的操作非常不方便，所以我们要抽象出thirdCamera类。</p>
<pre><code>class ThirdCamera
{

public:
    ThirdCamera();

    //围绕target旋转的方法
    void RotateAroundTarget(float RotateX,float RotateY);
    //获取摄像机向前的方向
    XMVECTOR GetForwardDir();
    //缩放FOV
    void ScrollFOV(float delta);


    //获取观察矩阵
    XMMATRIX GetViewMatrix();
    //获取投影矩阵
    XMMATRIX GetProjMatrix();

public:

    //近裁剪面距离
    float distanceNear;
    //远裁剪面距离
    float distanceFar;
    //FOV
    float cameraFOV;
    //FOV限制
    float FOV_Min, FOV_Max;

    ////摄像机位置
    XMFLOAT3 position;
    //旋转
    XMFLOAT3 rotation;
    //摄像机对准的方向
    XMFLOAT3 target;
    XMFLOAT3 up;


};
</code></pre><h3 id="主要功能的实现"><a href="#主要功能的实现" class="headerlink" title="主要功能的实现"></a>主要功能的实现</h3><p>摄像机的主要功能:</p>
<ol>
<li>获取ViewMatrix和ProjMatrix</li>
<li>缩放FOV</li>
<li>围绕Target进行旋转</li>
</ol>
<pre><code>ThirdCamera::ThirdCamera()
{

    //视锥体设置
    distanceNear = 1.0f;
    distanceFar = 1000.0f;

    //默认90FOV
    cameraFOV = 0.25f ;
    //最大180
    FOV_Min = (30.0f / 360.0f);
    //最小10
    FOV_Max = (150.0f / 360.0f);

    //初始化
    position = XMFLOAT3(0.0f, 0.0f, -5.0f);
    rotation = XMFLOAT3(0.0f, 0.0f, 0.0f);
    target = XMFLOAT3(0.0f, 0.0f, 0.0f);
    up = XMFLOAT3(0.0f, 1.0f, 0.0f);

}

void ThirdCamera::RotateAroundTarget(float RotateX, float RotateY)
{
    //首先围绕TargetY轴转动
    rotation.x = RotateX;
    rotation.y = -RotateY;

    //获取旋转之后的向前方向,位移一段距离
    XMVECTOR forwardDir = GetForwardDir();
    XMVECTOR tempPos = XMVectorMultiplyAdd(XMVectorReplicate(7.0f), XMVector3Normalize(forwardDir), XMLoadFloat3(&amp;target));

    //计算完毕之后需要存储为XMFLOAT3类型
    XMStoreFloat3(&amp;position, tempPos);


}

XMVECTOR ThirdCamera::GetForwardDir()
{
    XMMATRIX rotMatrix = XMMatrixRotationRollPitchYawFromVector(XMLoadFloat3(&amp;rotation));
    //获取Z轴
    return rotMatrix.r[2];
}

void ThirdCamera::ScrollFOV(float delta)
{
    cameraFOV -= delta;
    //限制大小
    if (cameraFOV &gt; FOV_Max)
    {
        cameraFOV = FOV_Max;
    }
    else if (cameraFOV &lt; FOV_Min)
    {
        cameraFOV = FOV_Min;
    }

}

XMMATRIX ThirdCamera::GetViewMatrix()
{
    XMVECTOR eyePos = XMVectorSet(position.x, position.y, position.z, 0.0f);
    XMVECTOR targetPos = XMVectorSet(target.x, target.y, target.z, 0.0f);
    XMVECTOR upDir = XMVectorSet(up.x, up.y, up.z, 0.0f);
    XMMATRIX viewMatrix = XMMatrixTranspose(XMMatrixLookAtLH(eyePos, targetPos, upDir));
    return viewMatrix;
}

XMMATRIX ThirdCamera::GetProjMatrix()
{
    XMMATRIX proJMatrix = XMMatrixTranspose(XMMatrixPerspectiveFovLH(cameraFOV * XM_PI, 640.0f / 480.0f, distanceNear, distanceFar));
    return proJMatrix;
}
</code></pre><h3 id="MessageProc中对鼠标滚轮的处理"><a href="#MessageProc中对鼠标滚轮的处理" class="headerlink" title="MessageProc中对鼠标滚轮的处理"></a>MessageProc中对鼠标滚轮的处理</h3><p>缩放FOV涉及到鼠标滚轮的信息处理，在OpdaGraphics::RealMessageProc中添加对鼠标滚轮信息的处理</p>
<pre><code>case WM_MOUSEWHEEL:
        //处理鼠标滚轮事件
        MouseScrollWheel((short)HIWORD(wParam));
        break;
</code></pre><p>这里我们只需要接受(short)HIWORD(wParam)，其他的用不到</p>
<pre><code> afx_msg   BOOL   OnMouseWheel(  
 UINT   nFlags,  //是否按下了虚拟键
 short   zDelta,  //鼠标滚轮转动的距离，返回120的倍数
 CPoint   pt   );   //鼠标光标的位置
</code></pre><p>这里由于我们重新设置了FOV，所以要重新更新ViewMatrix的常量缓冲区</p>
<pre><code>void OpdaGraphics::MouseScrollWheel(short WheelDelte)
{
    thirdCamera-&gt;ScrollFOV((WheelDelte / 120.0f) * 0.01f);

    //创建Proj变换矩阵
    cbProj cbP;
    cbP.ProjMatrix = thirdCamera-&gt;GetProjMatrix();
    //更新缓冲区
    D3D11_MAPPED_SUBRESOURCE mappedData;
    DirectxDeviceContext-&gt;Map(constantBuffer[2].Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedData);
    //安全内存复制，将cbstruct复制到pData
    memcpy_s(mappedData.pData, sizeof(cbProj), &amp;cbP, sizeof(cbProj));
    //关闭常量缓冲区的访问权限
    DirectxDeviceContext-&gt;Unmap(constantBuffer[2].Get(), 0);
}
</code></pre><p>记住对摄像机的属性进行了设置要重新更新相对应的常量缓冲区</p>
<pre><code>thirdCamera-&gt;RotateAroundTarget(RotateX, RotateY);

    //创建view变换矩阵
    cbView cbV;
    cbV.ViewMatrix = thirdCamera-&gt;GetViewMatrix();
    //更新常量缓冲区
    D3D11_MAPPED_SUBRESOURCE mappedData;
    //用于存储map函数获取到缓冲区的内存
    DirectxDeviceContext-&gt;Map(constantBuffer[1].Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedData);
    //安全内存复制，将cbstruct复制到pData
    memcpy_s(mappedData.pData, sizeof(cbView), &amp;cbV, sizeof(cbView));
    //关闭常量缓冲区的访问权限
    DirectxDeviceContext-&gt;Unmap(constantBuffer[1].Get(), 0);
</code></pre><h3 id="添加鼠标旋转功能"><a href="#添加鼠标旋转功能" class="headerlink" title="添加鼠标旋转功能"></a>添加鼠标旋转功能</h3><p>同样需要在OpdaGraphics::RealMessageProc中处理一下信息</p>
<pre><code>    case WM_LBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
        //处理鼠标点击事件
        MouseDown(wParam, (int)LOWORD(lParam), (int)HIWORD(lParam));
        break;
    case WM_LBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
        //处理鼠标松开事件
        MouseUp(wParam, (int)LOWORD(lParam), (int)HIWORD(lParam));
        break;
    case WM_MOUSEMOVE:
        MouseMove(wParam, (int)LOWORD(lParam), (int)HIWORD(lParam));
        break;
</code></pre><p>记录鼠标左键按下的LastPos位置，在MouseMove计算鼠标位置的delta距离，这样就能得到大概旋转的值，最后更新LastPos的位置</p>
<pre><code>void OpdaGraphics::MouseDown(WPARAM btnState, int x, int y)
{
    mouseLastPosX = x;
    mouseLastPosY = y;
    //捕捉鼠标
    SetCapture(hwnd);
}

void OpdaGraphics::MouseUp(WPARAM btnState, int x, int y)
{
    ReleaseCapture();
}

void OpdaGraphics::MouseMove(WPARAM btnState, int x, int y)
{
    if (btnState == MK_LBUTTON)
    {
        float dx = 0.01f * static_cast&lt;float&gt; (x - mouseLastPosX);
        float dy = 0.01f * static_cast&lt;float&gt; (y - mouseLastPosY);

        RotateX -= dy;
        RotateY -= dx;
        mouseLastPosX = x;
        mouseLastPosY = y;

    }
}
</code></pre><p>最后在UpdateScene中调用摄像机的RotateAroundTarget即可。</p>
<h2 id="添加diffuse光照"><a href="#添加diffuse光照" class="headerlink" title="添加diffuse光照"></a>添加diffuse光照</h2><p>我们创建最基本的平行光diffuse光照，首先要定义好材质和灯光的数据结构</p>
<pre><code>struct Material
{
    XMFLOAT4 diffuse;        //漫反射颜色
    XMFLOAT4 specular;        //高光颜色
    XMFLOAT4 ambient;        //环境光
};

//平行光
struct Light
{
    XMFLOAT4 lightColor;        //光的颜色
    XMFLOAT3 lightDirection;    //光的方向
    float temp;        //对齐用的
};
</code></pre><h3 id="HLSL内存对齐"><a href="#HLSL内存对齐" class="headerlink" title="HLSL内存对齐"></a>HLSL内存对齐</h3><p>注意到平行光的结构体有一个Temp的数据，这个涉及到HLSL的内存对齐，不对齐会报错，程序无法运行</p>
<p>相关文章：<a href="https://blog.csdn.net/BonChoix/article/details/8445218" target="_blank" rel="noopener">https://blog.csdn.net/BonChoix/article/details/8445218</a></p>
<h3 id="创建材质灯光的各自缓冲区"><a href="#创建材质灯光的各自缓冲区" class="headerlink" title="创建材质灯光的各自缓冲区"></a>创建材质灯光的各自缓冲区</h3><p>同样先在OpdaGraphics::InitResource()中进行初始化创建，后续再进行优化</p>
<pre><code>    //创建材质
    Material normalMat;
    Light DirectionLight;
    DirectionLight.lightColor = XMFLOAT4(0.8f, 0.8f, 0.8f, 1.0f);
    DirectionLight.lightDirection = XMFLOAT3(1.0f, -5.0f, 1.0f);
    DirectionLight.temp = 0;
    normalMat.ambient = XMFLOAT4(0.2f, 0.2f, 0.2f, 1.0f);
    normalMat.diffuse = XMFLOAT4(0.7f, 1.0f, 1.0f, 1.0f);
    normalMat.specular = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);
</code></pre><p>接下来的任务就是绑定到渲染管线，注意这里我是把材质灯光的常量缓冲区绑定到了像素着色器，因为我们的光照计算是在像素着色器中进行。</p>
<pre><code>    //将常量缓冲区绑定到像素着色器
    DirectxDeviceContext-&gt;PSSetConstantBuffers(3, 1, constantBuffer[3].GetAddressOf());
    DirectxDeviceContext-&gt;PSSetConstantBuffers(4, 1, constantBuffer[4].GetAddressOf());
</code></pre><h3 id="HLSL光照计算"><a href="#HLSL光照计算" class="headerlink" title="HLSL光照计算"></a>HLSL光照计算</h3><p>普通的漫反射计算，跟UnityShader入门精要差不多，由于我们现在的物体是没有动</p>
<pre><code>//常量缓冲区
cbuffer cbWorld : register(b0)
{
    matrix WorldMatrix;
}

cbuffer cbView : register(b1)
{
    matrix ViewMatrix;
}

cbuffer cbProj : register(b2)
{
    matrix ProjMatrix;
}

cbuffer material : register(b3)
{
    float4 diffuse; //漫反射颜色
    float4 specular; //高光颜色
    float4 ambient; //环境光
}

cbuffer light : register(b4)
{
    float4 lightColor; //光的颜色
    float3 lightDirection; //光的方向
    float temp;
}

struct VertexIn
{
    float4 pos : POSITION;
    float3 normal : NORMAL;
    float4 color : COLOR;
};

struct VertexOut
{
    float4 pos : SV_POSITION;
    float3 worldNormal : COLOR0;
    float4 color : COLOR1;
};

//顶点着色器
VertexOut VS(VertexIn vIn)
{
    VertexOut vOut;
    //变换到裁剪空间，MVP矩阵
    vOut.pos = mul(mul(mul(vIn.pos, WorldMatrix), ViewMatrix),ProjMatrix);
    vOut.worldNormal = normalize(mul(vIn.normal, (float3x3) WorldMatrix));
    vOut.color = vIn.color;
    return vOut;
}

//像素着色器
float4 PS(VertexOut pIn):SV_Target
{
    //计算漫反射
    float3 lightDir = -normalize(lightDirection);
    float3 diffuseColor = lightColor.rgb * diffuse.rgb * (dot(pIn.worldNormal,lightDir)*0.5+0.5);

    float3 finalColor = saturate(diffuseColor + ambient.rgb);
    return float4(finalColor, 1.0f);
}
</code></pre>]]></content>
      <categories>
        <category>DirectX11</category>
      </categories>
      <tags>
        <tag>DirectX11</tag>
      </tags>
  </entry>
  <entry>
    <title>DirectX11入门笔记---绘制三角形</title>
    <url>/2020/12/20/DirectX11%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0---%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    <content><![CDATA[<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210042177.png" alt="image-20201217210042177" style="zoom: 50%;"></p>
<a id="more"></a>
<h2 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h2><p>写了差不多三百多行代码，才弄出个三角形，真是太难顶了:sweat_smile:</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201220192624585.png" alt="image-20201220192624585"></p>
<h3 id="编写着色器"><a href="#编写着色器" class="headerlink" title="编写着色器"></a>编写着色器</h3><p>新建Shader筛选项用于存储HLSL文件，新建Triangle.hlsl开始编写着色器</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201220192744731.png" alt="image-20201220192744731"></p>
<p>这里推荐安装VS插件,非常好用，提供了HLSL高亮提示等功能</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201220192822607.png" alt="image-20201220192822607"></p>
<p>这里跟Unity Shader差不多，编写顶点着色器和片元着色器</p>
<pre><code>//传入顶点着色器的格式
struct VertexIn
{
    float4 pos : POSITION;
    float4 color : COLOR;
};
//传入像素着色器的格式
struct VertexOut
{
    float4 pos : SV_POSITION;
    float4 color : COLOR;
};

//顶点着色器
VertexOut VS(VertexIn vIn)
{
    VertexOut vOut;
    vOut.pos = vIn.pos;
    vOut.color = vIn.color;
    return vOut;
}

//像素着色器
float4 PS(VertexOut pIn):SV_Target
{
    return pIn.color;
}
</code></pre><h4 id="编译着色器方法"><a href="#编译着色器方法" class="headerlink" title="编译着色器方法"></a>编译着色器方法</h4><p>目前编译与加载着色器的方法有三种，我使用的是在程序运行期间编译着色器代码，并读取生成的字节码，所以要修改Triangle.hlsl的属性，防止一开始就参与编译</p>
<p>参考文章：<a href="https://www.cnblogs.com/X-Jun/p/10066282.html" target="_blank" rel="noopener">https://www.cnblogs.com/X-Jun/p/10066282.html</a></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201220193854521.png" alt="image-20201220193854521"></p>
<p>D3DCompileFromFile函数—-可以让我们运行时编译.hlsl文件</p>
<pre><code>HRESULT D3DCompileFromFile(
    LPCWSTR pFileName,                  // [In]要编译的.hlsl文件
    CONST D3D_SHADER_MACRO* pDefines,   // [In_Opt]忽略
    ID3DInclude* pInclude,              // [In_Opt]如何应对#include宏
    LPCSTR pEntrypoint,                 // [In]入口函数名
    LPCSTR pTarget,                     // [In]使用的着色器模型
    UINT Flags1,                        // [In]D3DCOMPILE系列宏
    UINT Flags2,                        // [In]D3DCOMPILE_FLAGS2系列宏
    ID3DBlob** ppCode,                  // [Out]获得着色器的二进制块
    ID3DBlob** ppErrorMsgs);            // [Out]可能会获得错误信息的二进制块
</code></pre><ol>
<li>pFileName:要编译hlsl文件的路径</li>
<li>pDefines:高级选项，我们为nullptr</li>
<li>pInclude:其中<code>pInclude</code>用于决定如何处理包含文件。如果设为<code>nullptr</code>，则编译的着色器代码包含<code>#include</code>时会引发编译器报错。如果你需要使用<code>#include</code>，可以传递<code>D3D_COMPILE_STANDARD_FILE_INCLUDE</code>宏，这是一个默认的包含句柄，可以按该着色器代码所处的相对路径去搜索对应的头文件并包含进来。</li>
<li>pEntryPoint:着色器的入口点函数名，因为一个hlsl文件可以包含多个着色器程序，比如一个顶点着色器和像素着色器，所以我们要指定入口</li>
<li>pTarget:指定着色器类型和版本的字符串</li>
<li>Flags1:我们仅使用<strong>D3DCOMPILE_DEBUG</strong>（获取着色器调试错误信息）和<strong>D3DCOMPILE_SKIP_OPTIMIZATION</strong>（跳过编译优化阶段以避免不合理状况）</li>
<li>Flags2:高级选项，不使用。</li>
<li>ppcode: 返回一个只想ID3DBlob的指针，存储着编译好的着色器二进制块</li>
<li>ppErrorMsgs:如果在编译过程中发生了错误，它会存储错误字符串</li>
</ol>
<p><strong>ID3DBlob</strong>只是一个普通的内存块，我们常用的有两种方法</p>
<ol>
<li>GetBufferPointer:返回void*类型指针</li>
<li>GetBufferSize:返回缓冲区字节大小</li>
</ol>
<p>D3DCompileFromFile</p>
<pre><code>ComPtr&lt;ID3DBlob&gt; OpdaGraphics::CompileShader(const WCHAR* hlslFileName, const D3D_SHADER_MACRO* defines, const LPCSTR entryPoint, const LPCSTR shaderModel)
{
    //判断是否处于调试模式
    UINT compileFlags = 0;
#if defined(DEBUG) || defined(_DEBUG)
    //D3DCOMPILE_DEBUG用于获取着色器调试信息
    //D3DCOMPILE_SKIP_OPTIMIZATION禁止优化，避免调试期间出现问题
    compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
#endif
    //用于获取着色器的二进制块
    ComPtr&lt;ID3DBlob&gt; byteCode = nullptr;
    //用于获取错误信息的二进制块
    ComPtr&lt;ID3DBlob&gt; errorsMsg = nullptr;
    HRESULT hr = S_OK;
    hr = D3DCompileFromFile(hlslFileName, defines, D3D_COMPILE_STANDARD_FILE_INCLUDE, 
        entryPoint, shaderModel, compileFlags, 0, byteCode.GetAddressOf(),errorsMsg.GetAddressOf());

    //输出错误信息
    if (errorsMsg != nullptr)
    {
        OutputDebugStringA((char*)errorsMsg-&gt;GetBufferPointer());
    }

    WCHAR strBufferError[300];
    FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        nullptr, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        strBufferError, 256, nullptr);
    OutputDebugStringW(strBufferError);

    //返回编译得到的着色器二进制块
    return byteCode;
}
</code></pre><p>使用例子</p>
<pre><code>    //着色器的二进制块
    ComPtr&lt;ID3DBlob&gt; shaderByteCode;
    //运行编译着色器
    shaderByteCode = CompileShader(L&quot;Triangle.hlsl&quot;, nullptr, &quot;VS&quot;, &quot;vs_5_0&quot;);
</code></pre><h4 id="HR宏关于dxerr库的替代方案"><a href="#HR宏关于dxerr库的替代方案" class="headerlink" title="HR宏关于dxerr库的替代方案"></a>HR宏关于dxerr库的替代方案</h4><p>DX11龙书上面使用的是dxerr库来作为错误原因追踪工具，但是Windows SDK 8.0以上已经没有dxerr库了，这里我用了<strong>FormatMessageW函数—获取格式化消息字符串</strong></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201220212351653.png" alt="image-20201220212351653"></p>
<pre><code>    WCHAR strBufferError[300];
    FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        nullptr, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        strBufferError, 256, nullptr);
    OutputDebugStringW(strBufferError);
</code></pre><p>参考文章:<a href="https://www.cnblogs.com/X-Jun/p/10170535.html" target="_blank" rel="noopener">https://www.cnblogs.com/X-Jun/p/10170535.html</a></p>
<h3 id="顶点与顶点布局（输入布局）"><a href="#顶点与顶点布局（输入布局）" class="headerlink" title="顶点与顶点布局（输入布局）"></a>顶点与顶点布局（输入布局）</h3><p>既然HLSL中已经确定好了我们顶点格式，那么我们C++中也要有与之对应的顶点格式数据结构，这里我新建了一个ShaderStruct.h来存储C++的顶点格式</p>
<pre><code>#pragma once
#include &lt;DirectXMath.h&gt;
using namespace DirectX;

struct VertexPosColor
{
    XMFLOAT4 pos;
    XMFLOAT4 color;
};
</code></pre><p>定义了顶点结构体之后，我们需要描述顶点结构体的分量结构，让DirectX知道如何使用每个分量。描述信息是以输入布局（<strong>ID3D11InputLayout</strong>）的形式提供给 Direct3D 的 ，然后输入布局其实是 一 个 <strong>D3D11_INPUT_ELEMENT_DESC</strong> 数 组 ，我们将 <strong>D3D11_INPUT_ELEMENT_DESC</strong> 称为输入布局描述</p>
<pre><code>typedef struct D3D11_INPUT_ELEMENT_DESC
{
    LPCSTR SemanticName;        // 语义名，将顶点结构体中的元素映射为顶点着色器参数
    UINT SemanticIndex;         // 语义索引 避免重复语义
    DXGI_FORMAT Format;         // 数据格式
    UINT InputSlot;             // 输入槽索引(0-15)
    UINT AlignedByteOffset;     // 初始位置(字节偏移量) 对于单个输入槽需要用到偏移量
    D3D11_INPUT_CLASSIFICATION InputSlotClass; // 输入类型
    UINT InstanceDataStepRate;  // 忽略
} D3D11_INPUT_ELEMENT_DESC;
</code></pre><p>我们在OpdaGraphics中创建InitEffect方法，专门用来做顶点布局和着色器相关的东西</p>
<p>通过语义、数据类型和起始偏移量，我们就可以建立起C++顶点缓冲区数据和HLSL顶点之间的联系。</p>
<pre><code>void OpdaGraphics::InitEffect()
{
    //我们先初始化输入布局描述
    D3D11_INPUT_ELEMENT_DESC inputLayout[2] = {
        {&quot;POSITION&quot;,0,DXGI_FORMAT_R32G32B32A32_FLOAT,0,0,D3D11_INPUT_PER_VERTEX_DATA,0},
        {&quot;COLOR&quot;,0,DXGI_FORMAT_R32G32B32A32_FLOAT,0,16,D3D11_INPUT_PER_VERTEX_DATA,0}
    };
}
</code></pre><p>完成输入布局描述之后，可以使用 <strong>ID3D11Device::CreateInputLayout</strong> 方法获取一个表示输入布局的 <strong>ID3D11InputLayout</strong> 接口的指针</p>
<pre><code>HRESULT ID3D11Device::CreateInputLayout( 
    const D3D11_INPUT_ELEMENT_DESC *pInputElementDescs, // [In]输入布局描述
    UINT NumElements,                                   // [In]上述数组元素个数
    const void *pShaderBytecodeWithInputSignature,      // [In]顶点着色器字节码
    SIZE_T BytecodeLength,                              // [In]顶点着色器字节码长度
    ID3D11InputLayout **ppInputLayout);                 // [Out]获取的输入布局
</code></pre><p>在此之前我们先编译Triangle.hlsl的顶点着色器再创建输入布局</p>
<pre><code>    //着色器的二进制块
    ComPtr&lt;ID3DBlob&gt; shaderByteCode;
    //运行编译着色器
    shaderByteCode = CompileShader(L&quot;Triangle.hlsl&quot;, nullptr, &quot;VS&quot;, &quot;vs_5_0&quot;);

    //创建绑定顶点布局
    DirectxDevice-&gt;CreateInputLayout(inputLayout, ARRAYSIZE(inputLayout), shaderByteCode-&gt;GetBufferPointer(),
        shaderByteCode-&gt;GetBufferSize(), vertexLayout.GetAddressOf());
</code></pre><p>接下来创建顶点着色器和像素着色器</p>
<pre><code>    //创建顶点着色器
    DirectxDevice-&gt;CreateVertexShader(shaderByteCode-&gt;GetBufferPointer(), shaderByteCode-&gt;GetBufferSize(),
        nullptr, vertexShader.GetAddressOf());

    //创建像素着色器
    shaderByteCode = CompileShader(L&quot;Triangle.hlsl&quot;, nullptr, &quot;PS&quot;, &quot;ps_5_0&quot;);
    DirectxDevice-&gt;CreatePixelShader(shaderByteCode-&gt;GetBufferPointer(), shaderByteCode-&gt;GetBufferSize(),
        nullptr, pixelShader.GetAddressOf());
</code></pre><p>整个InitEffect函数如下</p>
<pre><code>void OpdaGraphics::InitEffect()
{
    //初始化输入布局描述
    D3D11_INPUT_ELEMENT_DESC inputLayout[2] = {
        {&quot;POSITION&quot;,0,DXGI_FORMAT_R32G32B32A32_FLOAT,0,0,D3D11_INPUT_PER_VERTEX_DATA,0},
        {&quot;COLOR&quot;,0,DXGI_FORMAT_R32G32B32A32_FLOAT,0,16,D3D11_INPUT_PER_VERTEX_DATA,0}
    };

    //着色器的二进制块
    ComPtr&lt;ID3DBlob&gt; shaderByteCode;
    //运行编译着色器
    shaderByteCode = CompileShader(L&quot;Triangle.hlsl&quot;, nullptr, &quot;VS&quot;, &quot;vs_5_0&quot;);

    //创建顶点布局
    DirectxDevice-&gt;CreateInputLayout(inputLayout, ARRAYSIZE(inputLayout), shaderByteCode-&gt;GetBufferPointer(),
        shaderByteCode-&gt;GetBufferSize(), vertexLayout.GetAddressOf());

    //创建顶点着色器
    DirectxDevice-&gt;CreateVertexShader(shaderByteCode-&gt;GetBufferPointer(), shaderByteCode-&gt;GetBufferSize(),
        nullptr, vertexShader.GetAddressOf());

    //创建像素着色器
    shaderByteCode = CompileShader(L&quot;Triangle.hlsl&quot;, nullptr, &quot;PS&quot;, &quot;ps_5_0&quot;);
    DirectxDevice-&gt;CreatePixelShader(shaderByteCode-&gt;GetBufferPointer(), shaderByteCode-&gt;GetBufferSize(),
        nullptr, pixelShader.GetAddressOf());

}
</code></pre><h3 id="顶点缓冲"><a href="#顶点缓冲" class="headerlink" title="顶点缓冲"></a>顶点缓冲</h3><p>为了让GPU能访问到顶点数组，我们需要把顶点放到Buffer的容器内，容易用<strong>ID3D11Buffer</strong>接口表示。</p>
<p>首先让我们定义三角形的顶点属性</p>
<pre><code>    //设置三角形顶点,顶点应按顺时针排布
    VertexPosColor vertices[] =
    {
        { XMFLOAT4(0.0f, 0.5f, 0.5f,1.0f), XMFLOAT4(0.0f, 1.0f, 0.0f, 1.0f) },
        { XMFLOAT4(0.5f, -0.5f, 0.5f,1.0f), XMFLOAT4(0.0f, 0.0f, 1.0f, 1.0f) },
        { XMFLOAT4(-0.5f, -0.5f, 0.5f,1.0f), XMFLOAT4(1.0f, 0.0f, 0.0f, 1.0f) }
    };
</code></pre><p>首先还是需要先创建顶点缓冲区的描述</p>
<pre><code>typedef struct D3D11_BUFFER_DESC
{
    UINT ByteWidth;             // 数据字节数
    D3D11_USAGE Usage;          // CPU和GPU的读写权限相关
    UINT BindFlags;             // 缓冲区类型的标志
    UINT CPUAccessFlags;        // CPU读写权限的指定
    UINT MiscFlags;             // 忽略
    UINT StructureByteStride;   // 忽略
}     D3D11_BUFFER_DESC;
</code></pre><p>D3D11_USAGE对应关系</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center"><strong>CPU读</strong></th>
<th style="text-align:center"><strong>CPU写</strong></th>
<th style="text-align:center"><strong>GPU读</strong></th>
<th style="text-align:center"><strong>GPU写</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>D3D11_USAGE_DEFAULT</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>D3D11_USAGE_IMMUTABLE</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>D3D11_USAGE_DYNAMIC</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>D3D11_USAGE_STAGING</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
</div>
<p><strong>由于目前的教程所涉及到的顶点缓冲区在创建后通常是不会修改的，因此将其设为</strong><code>D3D11_USAGE_IMMUTABLE</code></p>
<p>ZeroMemory的作用是将vertexBufferDesc的内存区域填充为0，可以不使用ZeroMemory，但是就要自己手动去初始化MiscFlags，CPUAccessFlags，StructureByteStride等参数，否则会内存溢出错误</p>
<pre><code>    //创建顶点缓冲区描述
    D3D11_BUFFER_DESC vertexBufferDesc;
    //ZeroMemory(&amp;vertexBufferDesc, sizeof(vertexBufferDesc));
    vertexBufferDesc.Usage = D3D11_USAGE_IMMUTABLE;
    vertexBufferDesc.ByteWidth = sizeof(vertices);
    vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
    vertexBufferDesc.CPUAccessFlags = 0;
    vertexBufferDesc.MiscFlags = 0;
    vertexBufferDesc.StructureByteStride = 0;
</code></pre><p>还需要使用<code>D3D11_SUBRESOURCE_DATA</code>结构体来指定要用来初始化的数据</p>
<pre><code>typedef struct D3D11_SUBRESOURCE_DATA
{
    const void *pSysMem;        // 用于初始化的数据
    UINT SysMemPitch;           // 忽略
    UINT SysMemSlicePitch;      // 忽略
}     D3D11_SUBRESOURCE_DATA;
</code></pre><pre><code>    //指定要初始化的数据
    D3D11_SUBRESOURCE_DATA InitData;
    InitData.pSysMem = vertices;
</code></pre><p>最后就可以创建顶点缓冲区了</p>
<pre><code>HRESULT ID3D11Device::CreateBuffer( 
    const D3D11_BUFFER_DESC *pDesc,     // [In]顶点缓冲区描述
    const D3D11_SUBRESOURCE_DATA *pInitialData, // [In]子资源数据
    ID3D11Buffer **ppBuffer);           // [Out] 获取缓冲区
</code></pre><pre><code>    //顶点缓冲区
    DirectxDevice-&gt;CreateBuffer(&amp;vertexBufferDesc, &amp;InitData, vertexBuffer.GetAddressOf());
</code></pre><h3 id="绑定至渲染管线"><a href="#绑定至渲染管线" class="headerlink" title="绑定至渲染管线"></a>绑定至渲染管线</h3><p>首先将顶点缓冲绑定到设备的输入槽，这样才能将顶点送入管线</p>
<pre><code>void ID3D11DeviceContext::IASetVertexBuffers( 
    UINT StartSlot,     // [In]输入槽索引
    UINT NumBuffers,    // [In]缓冲区数目
    ID3D11Buffer *const *ppVertexBuffers,   // [In]指向顶点缓冲区数组的指针
    const UINT *pStrides,   // [In]一个数组，规定了对所有缓冲区每次读取的字节数分别是多少
    const UINT *pOffsets);  // [In]一个数组，规定了对所有缓冲区的初始字节偏移量
</code></pre><pre><code>//输入装配阶段的顶点缓冲区设置
    UINT stride = sizeof(VertexPosColor);        //跨越字节数
    UINT offset = 0;        //起始偏移量

    DirectxDeviceContext-&gt;IASetVertexBuffers(0, 1, vertexBuffer.GetAddressOf(), &amp;stride, &amp;offset);
</code></pre><p>接下来就是设置图元类型，设置输入布局</p>
<pre><code>    // 设置图元类型，设定输入布局
    DirectxDeviceContext-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    DirectxDeviceContext-&gt;IASetInputLayout(vertexLayout.Get());
</code></pre><p>将着色器绑定到管线</p>
<pre><code>    // 将着色器绑定到渲染管线
    DirectxDeviceContext-&gt;VSSetShader(vertexShader.Get(), nullptr, 0);
    DirectxDeviceContext-&gt;PSSetShader(pixelShader.Get(), nullptr, 0);
</code></pre><p>最后利用ID3D11DeviceContex::Draw方法—-根据已经绑定的顶点缓冲区进行绘制</p>
<pre><code>void ID3D11DeviceContext::Draw( 
    UINT VertexCount,           // [In]需要绘制的顶点数目
    UINT StartVertexLocation);  // [In]起始顶点索引
</code></pre><pre><code>void OpdaGraphics::RenderScene()
{
    XMVECTORF32 color = { 0.0f,0.0f,0.0f,1.0f };
    DirectxDeviceContext-&gt;ClearRenderTargetView(renderTargetView, reinterpret_cast&lt;float*&gt;(&amp;color));
    DirectxDeviceContext-&gt;ClearDepthStencilView(depthStencilView, D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);

    //绘制三角形
    DirectxDeviceContext-&gt;Draw(3, 0);
    dxgiSwapChain-&gt;Present(0, 0);
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>绘制三角形的步骤可以分为:</p>
<ol>
<li><p>编写着色器HLSL文件，包含顶点着色器，像素着色器</p>
</li>
<li><p>运行时编译着色器文件，获得着色器的二进制块，创建顶点布局</p>
</li>
<li><p>创建顶点着色器，像素着色器</p>
</li>
<li><p>填充顶点缓冲区的描述，指定初始化数据，创建顶点缓冲</p>
</li>
<li><p>最后将所有创建的东西都绑定到渲染管线上</p>
</li>
</ol>
]]></content>
      <categories>
        <category>DirectX11</category>
      </categories>
      <tags>
        <tag>DirectX11</tag>
      </tags>
  </entry>
  <entry>
    <title>DirectX11入门笔记---绘制立方体</title>
    <url>/2020/12/22/DirectX11%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0---%E7%BB%98%E5%88%B6%E7%AB%8B%E6%96%B9%E4%BD%93/</url>
    <content><![CDATA[<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210042177.png" alt="image-20201217210042177" style="zoom: 50%;"></p>
<a id="more"></a>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/GIF%202020-12-22%2016-19-43.gif" alt="GIF 2020-12-22 16-19-43"></p>
<h2 id="绘制立方体"><a href="#绘制立方体" class="headerlink" title="绘制立方体"></a>绘制立方体</h2><p>首先我们初始化顶点数据</p>
<pre><code>    // ******************
    // 设置立方体顶点
    //    5________ 6
    //    /|      /|
    //   /_|_____/ |
    //  1|4|_ _ 2|_|7
    //   | /     | /
    //   |/______|/
    //  0       3

    //设置立方体顶点,顶点应按顺时针排布
    VertexPosColor vertices[] =
    {
        { XMFLOAT4(-1.0f, -1.0f, -1.0f,1.0f), XMFLOAT4(0.0f, 0.0f, 0.0f, 1.0f) },
        { XMFLOAT4(-1.0f, 1.0f, -1.0f,1.0f), XMFLOAT4(1.0f, 1.0f, 0.0f, 1.0f) },
        { XMFLOAT4(1.0f, 1.0f, -1.0f,1.0f), XMFLOAT4(1.0f, 1.0f, 0.0f, 1.0f) },
        { XMFLOAT4(1.0f, -1.0f, -1.0f,1.0f), XMFLOAT4(0.0f, 1.0f, 0.0f, 1.0f) },
        { XMFLOAT4(-1.0f, -1.0f, 1.0f,1.0f), XMFLOAT4(0.0f, 0.0f, 1.0f, 1.0f) },
        { XMFLOAT4(-1.0f, 1.0f, 1.0f,1.0f), XMFLOAT4(1.0f, 0.0f, 1.0f, 1.0f) },
        { XMFLOAT4(1.0f, 1.0f, 1.0f,1.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT4(1.0f, -1.0f, 1.0f,1.0f), XMFLOAT4(0.0f, 1.0f, 1.0f, 1.0f) }
    };
</code></pre><h3 id="索引缓冲区"><a href="#索引缓冲区" class="headerlink" title="索引缓冲区"></a>索引缓冲区</h3><p>索引缓冲区的作用是用来避免复制大量重复的顶点数据，毕竟占用的存储空间会非常大，如果复制的是索引那占用空间没什么所谓了</p>
<p>初始化索引数组</p>
<pre><code>    //初始化索引数组
    DWORD indexs[] =
    {
        //正面
        0,1,2,
        2,3,0,
        //左面
        4,5,1,
        1,0,4,
        //顶面
        1,5,6,
        6,2,1,
        //背面
        7,6,5,
        5,4,7,
        //右面
        3,2,6,
        6,7,3,
        //底面
        4,0,3,
        3,7,4
    };
</code></pre><p>接下来和顶点缓冲区的创建一致，先创建索引缓冲区描述，再初始化数据，最后创建索引缓冲区</p>
<pre><code>    //设置索引缓冲区描述
    D3D11_BUFFER_DESC indexBufferDesc;
    //将指定内存区域都设置为0
    ZeroMemory(&amp;indexBufferDesc, sizeof(indexBufferDesc));
    //目前索引缓冲区在创建后通常不会修改，所以选择D3D11_USAGE_IMMUTABLE
    indexBufferDesc.Usage = D3D11_USAGE_IMMUTABLE;
    indexBufferDesc.ByteWidth = sizeof(indexs);
    indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
    indexBufferDesc.CPUAccessFlags = 0;

    //同样需要指定初始化数据
    InitData.pSysMem = indexs;
    //创建索引缓冲区
    DirectxDevice-&gt;CreateBuffer(&amp;indexBufferDesc, &amp;InitData, indexBuffer.GetAddressOf());
</code></pre><p><strong>ID3D11DeviceContext::IASetIndexBuffer</strong>与渲染管线进行绑定</p>
<pre><code>void ID3D11DeviceContext::IASetIndexBuffer( 
    ID3D11Buffer *pIndexBuffer,     // [In]索引缓冲区
    DXGI_FORMAT Format,             // [In]数据格式
    UINT Offset);                   // [In]字节偏移量
</code></pre><p>Format：指定每个索引所占的字节</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>DXGI_FORMAT</strong></th>
<th><strong>字节数</strong></th>
<th><strong>索引范围</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>DXGI_FORMAT_R8_UINT</td>
<td>1</td>
<td>0-255</td>
</tr>
<tr>
<td>DXGI_FORMAT_R16_UINT</td>
<td>2</td>
<td>0-65535</td>
</tr>
<tr>
<td>DXGI_FORMAT_R32_UINT</td>
<td>4</td>
<td>0-2147483647</td>
</tr>
</tbody>
</table>
</div>
<pre><code>    //将索引缓冲区绑定到渲染管线
    DirectxDeviceContext-&gt;IASetIndexBuffer(indexBuffer.Get(), DXGI_FORMAT_R32_UINT, 0);
</code></pre><h3 id="常量缓冲区"><a href="#常量缓冲区" class="headerlink" title="常量缓冲区"></a>常量缓冲区</h3><p>常量缓冲区相当于C++的全局变量，供着色器使用，首先我们要在hlsl文件中定义常量缓冲区</p>
<pre><code>//常量缓冲区
cbuffer ConstantBuffer : register(b0)
{
    matrix WorldMatrix;
    matrix ViewMatrix;
    matrix ProjMatrix;
}
</code></pre><p>定义了一个ConstantBuffer的<code>cbuffer</code>对象，cbuffer就是常量缓冲，里面存储了各自独立的MVP矩阵</p>
<p><code>matrix</code>相当于<code>float4x4</code>，directx中矩阵默认是行主矩阵，但HLSL矩阵是列主矩阵，这个要进行转置，否则会出错</p>
<p><code>register</code>指该常量缓冲区处于寄存器索引为0的缓冲区</p>
<p>我们在C++中也应该有相对应的数据结构</p>
<pre><code>//常量缓冲区对应的数据结构
struct ConstantBufferStruct
{
    XMMATRIX worldMatrix;
    XMMATRIX viewMatrix;
    XMMATRIX projMatrix;
};
</code></pre><h4 id="更新方式"><a href="#更新方式" class="headerlink" title="更新方式"></a>更新方式</h4><p>常量缓冲区有两种运行时更新方式：</p>
<ol>
<li>缓冲区描述<strong>Usage</strong>指定为D3D11_USAGE_DEFAULT，可以允许常量缓冲区从GPU写入，需要用<code>ID3D11DeviceContext::UpdateSubresource</code>方法更新，这种方法适合更新不频繁的数据</li>
<li>在创建资源的时候指定<code>Usage</code>为<code>D3D11_USAGE_DYNAMIC</code>、<code>CPUAccessFlags</code>为<code>D3D11_CPU_ACCESS_WRITE</code>，允许常量缓冲区从CPU写入，首先通过<code>ID3D11DeviceContext::Map</code>方法获取内存映射，然后再更新到映射好的内存区域，最后通过<code>ID3D11DeviceContext::Unmap</code>方法解除占用，这种方法适合频繁更新的数据</li>
</ol>
<p><strong>ID3D11DeviceContext::Map</strong>—获取指向缓冲区中数据的指针并拒绝GPU对该缓冲区的访问</p>
<pre><code>HRESULT ID3D11DeviceContext::Map(
    ID3D11Resource           *pResource,          // [In]包含ID3D11Resource接口的资源对象
    UINT                     Subresource,         // [In]包含在资源中的子资源的索引,由于缓冲区不包含子资源，所以设置为0
    D3D11_MAP                MapType,             // [In]D3D11_MAP枚举值，指定读写相关操作
    UINT                     MapFlags,            // [In]填0，CPU需要等待GPU使用完毕当前缓冲区
    D3D11_MAPPED_SUBRESOURCE *pMappedResource     // [Out]获取到的已经映射到缓冲区的内存
);
</code></pre><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201222155452623.png" alt="image-20201222155452623"></p>
<p>获取到缓冲区内存之后，我们使用<strong>memcpy_s</strong>将我们计算好的矩阵数据复制到pMappedResource.pData里去。</p>
<p><strong>ID3D11DeviceContext::Unmap函数</strong>—让指向资源的指针无效并重新启用GPU对该资源的访问权限</p>
<p>当你完成缓冲区的更新操作之后，必须调用 <strong>ID3D11Buffer::Unmap</strong> 函数。</p>
<pre><code>void ID3D11DeviceContext::Unmap(
    ID3D11Resource *pResource,      // [In]包含ID3D11Resource接口的资源对象
    UINT           Subresource      // [In]缓冲区资源填0
);
</code></pre><h4 id="创建常量缓冲区"><a href="#创建常量缓冲区" class="headerlink" title="创建常量缓冲区"></a>创建常量缓冲区</h4><p>同样的操作，只不过不需要初始化数据</p>
<pre><code>    //设置常量缓冲区描述
    D3D11_BUFFER_DESC constantBufferDesc;
    ZeroMemory(&amp;constantBufferDesc, sizeof(constantBufferDesc));
    //由于常量缓冲区大多数需要频繁更新，所以需要设置为
    constantBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
    constantBufferDesc.ByteWidth = sizeof(ConstantBufferStruct);
    constantBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
    //需要CPU写入矩阵数据
    constantBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

    //直接新建常量缓冲区，无需初始化数据
    DirectxDevice-&gt;CreateBuffer(&amp;constantBufferDesc, nullptr, constantBuffer.GetAddressOf());
</code></pre><h4 id="计算矩阵并且更新常量缓冲区"><a href="#计算矩阵并且更新常量缓冲区" class="headerlink" title="计算矩阵并且更新常量缓冲区"></a>计算矩阵并且更新常量缓冲区</h4><pre><code>//用于更新常量缓冲区
    cbStruct.worldMatrix = XMMatrixIdentity();//单位矩阵
    //创建view变换矩阵
    XMVECTOR pos = XMVectorSet(0.0f, 0.0f, -5.0f, 0.0f);
    XMVECTOR target = XMVectorSet(0.0f, 0.0f, 0.0f, 0.0f);
    XMVECTOR up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);
    cbStruct.viewMatrix = XMMatrixTranspose( XMMatrixLookAtLH(pos, target, up));

    //创建Proj变换矩阵
    cbStruct.projMatrix = XMMatrixTranspose(XMMatrixPerspectiveFovLH(XM_PIDIV2, 640.0f / 480.0f, 1.0f, 1000.0f));

    //用于存储map函数获取到缓冲区的内存
    D3D11_MAPPED_SUBRESOURCE mappedData;
    DirectxDeviceContext-&gt;Map(constantBuffer.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedData);
    //安全内存复制，将cbstruct复制到pData
    memcpy_s(mappedData.pData, sizeof(cbStruct), &amp;cbStruct, sizeof(cbStruct));
    //关闭常量缓冲区的访问权限
    DirectxDeviceContext-&gt;Unmap(constantBuffer.Get(), 0);
</code></pre><h4 id="绑定至渲染管线顶点着色阶段"><a href="#绑定至渲染管线顶点着色阶段" class="headerlink" title="绑定至渲染管线顶点着色阶段"></a>绑定至渲染管线顶点着色阶段</h4><p><strong>ID3D11DeviceContext::*SSetConstantBuffers</strong>—渲染管线某一着色阶段设置常量缓冲区</p>
<pre><code>void ID3D11DeviceContext::VSSetConstantBuffers( 
    UINT StartSlot,     // [In]放入缓冲区的起始索引，例如上面指定了b0，则这里应为0
    UINT NumBuffers,    // [In]设置的缓冲区数目
    ID3D11Buffer *const *ppConstantBuffers);    // [In]用于设置的缓冲区数组
</code></pre><pre><code>    //将常量缓冲区绑定到渲染管线
    DirectxDeviceContext-&gt;VSSetConstantBuffers(0, 1, constantBuffer.GetAddressOf());
</code></pre><h4 id="UpdateScene旋转立方体"><a href="#UpdateScene旋转立方体" class="headerlink" title="UpdateScene旋转立方体"></a>UpdateScene旋转立方体</h4><p>因为要旋转立方体，所以需要每帧更新WorldMatrix，所以要在Update中进行操作</p>
<pre><code>void OpdaGraphics::UpateScene(float deltaTime)
{
    static float rotateY = 0.0f;
    rotateY += 0.00015f;
    cbStruct.worldMatrix = XMMatrixTranspose(XMMatrixRotationY(rotateY));
    // 更新常量缓冲区，让立方体转起来
    D3D11_MAPPED_SUBRESOURCE mappedData;
    DirectxDeviceContext-&gt;Map(constantBuffer.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedData);
    memcpy_s(mappedData.pData, sizeof(cbStruct), &amp;cbStruct, sizeof(cbStruct));
    DirectxDeviceContext-&gt;Unmap(constantBuffer.Get(), 0);
}
</code></pre><p>最后在DrawScene进行修改</p>
<pre><code>void OpdaGraphics::RenderScene()
{
    XMVECTORF32 color = { 0.0f,0.0f,0.0f,1.0f };
    DirectxDeviceContext-&gt;ClearRenderTargetView(renderTargetView, reinterpret_cast&lt;float*&gt;(&amp;color));
    DirectxDeviceContext-&gt;ClearDepthStencilView(depthStencilView, D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);

    //绘制三角形
    //DirectxDeviceContext-&gt;Draw(3, 0);
    //绘制立方体
    DirectxDeviceContext-&gt;DrawIndexed(36, 0, 0);
    dxgiSwapChain-&gt;Present(0, 0);
}
</code></pre><pre><code>void ID3D11DeviceContext::DrawIndexed( 
    UINT IndexCount,            // 索引数目
    UINT StartIndexLocation,    // 起始索引位置
    INT BaseVertexLocation);    // 起始顶点位置
</code></pre><h3 id="HLSL文件"><a href="#HLSL文件" class="headerlink" title="HLSL文件"></a>HLSL文件</h3><pre><code>
//常量缓冲区
cbuffer ConstantBuffer : register(b0)
{
    matrix WorldMatrix;
    matrix ViewMatrix;
    matrix ProjMatrix;
}


struct VertexIn
{
    float4 pos : POSITION;
    float4 color : COLOR;
};

struct VertexOut
{
    float4 pos : SV_POSITION;
    float4 color : COLOR;
};

//顶点着色器
VertexOut VS(VertexIn vIn)
{
    VertexOut vOut;
    //变换到裁剪空间，MVP矩阵
    vOut.pos = mul(mul(mul(vIn.pos, WorldMatrix), ViewMatrix),ProjMatrix);
    vOut.color = vIn.color;
    return vOut;
}

//像素着色器
float4 PS(VertexOut pIn):SV_Target
{
    return pIn.color;
}
</code></pre>]]></content>
      <categories>
        <category>DirectX11</category>
      </categories>
      <tags>
        <tag>DirectX11</tag>
      </tags>
  </entry>
  <entry>
    <title>DirectX11入门笔记---计时器实现</title>
    <url>/2020/12/18/DirectX11%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0---%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210042177.png" alt="image-20201217210042177" style="zoom: 50%;"></p>
<a id="more"></a>
<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><p>计时器支持暂停，开始，重置，每帧调用功能，程序中每一帧调用一次计数，并随时返回距离上一次计数之间的差值。这个差值就是控制游戏、动画更新的最重要的数据。</p>
<p> 这个定时器用到了Windows中高精度的计时函数：<strong>QueryPerformanceCounter</strong>（用于计算调用的时间差）</p>
<p><strong>QueryPerformanceFrequency</strong>（返回计时器的计算频率，每秒的计算次数，用于转换秒的转换因子）</p>
<pre><code>BOOL QueryPerformanceCounter(  LARGE_INTEGER* lpPerformanceCount );
BOOL QueryPerformanceFrequency(  LARGE_INTEGER* lpFrequency );
</code></pre><h3 id="计时器类"><a href="#计时器类" class="headerlink" title="计时器类"></a>计时器类</h3><pre><code>#pragma once

// 计时器
class Timer
{
public:
    // 构造函数
    Timer();

    float TotalTime() const;        //返回从开始计时到现在的总时间
    float DeltaTime() const;        //返回时间差

    void Start();        //取消暂停时调用
    void Stop();        //暂停时调用
    void Reset();        //消息循环前调用
    void Tick();        //每帧调用

private:
    float secsPerCount;        //系统有关，把时间单位转换为秒的转换因子
    float deltaTime;        //时间差

    __int64 baseTime;        //计时器开始工作的起始时间点
    __int64 stopTime;        //暂停状态的起始时间点
    __int64 pauseTime;        //累计的暂停时间
    __int64 currTime;        //当前起始时间点
    __int64 prevTime;        //上次起始时间点

    bool IsStop;        //是否暂停

};
</code></pre><pre><code>#include &quot;Timer.h&quot;
#include &lt;Windows.h&gt;

// 进行初始化
Timer::Timer():secsPerCount(0.0f),deltaTime(0),pauseTime(0),prevTime(0),
currTime(0),IsStop(false)
{
    //计算秒转换因子
    __int64 countPerSec;
    QueryPerformanceFrequency((LARGE_INTEGER*)&amp;countPerSec);
    secsPerCount = 1.0f / (double)countPerSec;
}

float Timer::TotalTime() const
{
    //判断是否处于暂停状态
    if (IsStop)
    {
        return (float)((stopTime - pauseTime) - baseTime * secsPerCount);
    }
    else
    {
        return (float)((currTime - pauseTime) - baseTime * secsPerCount);
    }
}

float Timer::DeltaTime() const
{
    return deltaTime;
}

void Timer::Start()
{
    //记录当前时间
    __int64 currTime_Temp;
    QueryPerformanceCounter((LARGE_INTEGER*)&amp;currTime_Temp);

    //判断是否处于暂停状态
    if (IsStop)
    {
        //添加上暂停的这段时间
        pauseTime += currTime_Temp - stopTime;
        //因为重新计时，所以我们要重新设置
        prevTime = currTime;
        stopTime = 0;
        IsStop = false;
    }
}

void Timer::Stop()
{
    //判断是否处于暂停状态
    if (!IsStop)
    {
        //记录暂停的时间
        __int64 currTime_Temp;
        QueryPerformanceCounter((LARGE_INTEGER*)&amp;currTime_Temp);
        //设置暂停标志
        stopTime = currTime_Temp;
        IsStop = true;
    }
}

void Timer::Reset()
{
    __int64 currTime_Temp;
    QueryPerformanceCounter((LARGE_INTEGER*)&amp;currTime_Temp);
    //因为重置计时器，所以baseTime，prevTime，stopTime要重新设置
    baseTime = currTime_Temp;
    prevTime = currTime_Temp;
    stopTime = 0;
    IsStop = false;
}

void Timer::Tick()
{
    //判断是否暂停
    if (IsStop)
    {
        deltaTime = 0.0;
        return;
    }

    //获取当前时间值
    __int64 currTime_Temp;
    QueryPerformanceCounter((LARGE_INTEGER*)&amp;currTime_Temp);
    currTime = currTime_Temp;

    //计算时间差
    deltaTime = (currTime - prevTime) * secsPerCount;

    //为计算下一帧做准备
    prevTime = currTime;

    //确保deltaTime不是负值
    //出现负值的情况：1.处理器进入节电模式        2.切换到另外一个处理器
    if (deltaTime &lt; 0)
    {
        deltaTime = 0;
    }
}
</code></pre>]]></content>
      <categories>
        <category>DirectX11</category>
      </categories>
      <tags>
        <tag>DirectX11</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建过程(踩坑)</title>
    <url>/2019/10/30/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​         本文主要用来记录自己Hexo博客搭建过程中遇到的坑。</p>
 <a id="more"></a> 
<h1 id="个人域名篇"><a href="#个人域名篇" class="headerlink" title="个人域名篇"></a>个人域名篇</h1><p>​         这个个人域名的确有点坑，明明按着教程的操作一步一步来的，还是弄了一晚上，到最后才发现是校园网DNS的坑。。。</p>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><p>​        首先我们要购买一个属于自己的域名，可以去腾讯云，阿里云等网站进行购买，这里我在阿里云购买opda.tech，为什么不用com域名，因为这个便宜。</p>
<p>​    购买域名后我们还要得到github仓库的IP。通过cmd命令行，输入Ping 你的名字.github.io获取名字   </p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/2.png" alt></p>
<p>红色箭头所指就是你github仓库的IP，然后我们就可以进行DNS解析。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/1.png" alt></p>
<p>进去之后，点击新手引导，输入cmd获得的IP即可。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/4.png" alt></p>
<p>解析完的结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/11.png" alt></p>
<p>​    </p>
<h2 id="2-github的绑定"><a href="#2-github的绑定" class="headerlink" title="2.github的绑定"></a>2.github的绑定</h2><p>​        进入你创建的仓库内，点击Setting</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/5.png" alt></p>
<p>​        GitHub Pages设置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/6.png" alt></p>
<p>就这样github仓库的绑定就完成啦！</p>
<h2 id="3-最后一步"><a href="#3-最后一步" class="headerlink" title="3.最后一步"></a>3.最后一步</h2><p>我们还要在本地博客的source文件夹下新建一个CNAME.txt文本，在里面输入我们的自定义域名，修改完毕之后记得把CNAME的txt后缀去掉！！！不然会不行的（感谢猫桑的bug发现）</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/7.png" alt></p>
<p>最后我们Git Base重新部署一下博客就行啦！</p>
<pre><code class="lang-base">hexo clean
hexo g
hexo d
</code></pre>
<h2 id="4-深坑"><a href="#4-深坑" class="headerlink" title="4.深坑"></a>4.深坑</h2><p>​        如果你是校园网用户的话，你要小心校园网DNS这个坑，会让你无法访问你自己的域名，所以解决方法就是修改我们的DNS就好了。</p>
<p>打开我们的控制面板—-网络共享中心</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/8.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/9.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/10.png" alt></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini创建地形原型搭建工具(二)</title>
    <url>/2020/11/29/Houdini%E5%88%9B%E5%BB%BA%E5%9C%B0%E5%BD%A2%E5%8E%9F%E5%9E%8B%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用curve搭建模型，搭配object_merge在UE4中进行地形的构建，可以在引擎中使用此工具达到快速搭建的效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130154350820.png" alt="image-20201130154350820"></p>
<a id="more"></a>
<h3 id="Fill-shape"><a href="#Fill-shape" class="headerlink" title="Fill shape"></a>Fill shape</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221017033.png" alt="image-20201128221017033"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221031137.png" alt="image-20201128221031137"></p>
<p>首先curve节点创建基本点，点击curve节点然后enter进入编辑模式，esc退出编辑模式</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221116432.png" alt="image-20201128221116432"></p>
<p>add节点进行补面</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221138646.png" alt="image-20201128221138646"></p>
<p>利用thicken进行挤出，polyBevel进行倒角，fuse融合接近的点，得到一个fill shape</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221438367.png" alt="image-20201128221438367"></p>
<h3 id="sweep"><a href="#sweep" class="headerlink" title="sweep"></a>sweep</h3><p>同样利用curve确定基本点，然后switch选择补面或者不补面，这影响到sweep结果是否封闭，最后选择circle作为横截面输入到sweep节点</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221517056.png" alt="image-20201128221517056"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221532620.png" alt="没有补面"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221707965.png" alt="补面"></p>
<h3 id="copy-shape"><a href="#copy-shape" class="headerlink" title="copy shape"></a>copy shape</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221824366.png" alt="image-20201128221824366"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221846392.png" alt="在curve线上生成"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221940837.png" alt="在curve围成的面上生成"></p>
<h4 id="curve线上"><a href="#curve线上" class="headerlink" title="curve线上"></a>curve线上</h4><p>比较简单，利用resample节点增加curve线上的点数量即可</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128222109485.png" alt="image-20201128222109485"></p>
<h4 id="curve围成面"><a href="#curve围成面" class="headerlink" title="curve围成面"></a>curve围成面</h4><p>同样首先利用add节点封面，divide三角面化，subdivide细分</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129130324379.png" alt="image-20201129130324379"></p>
<p>利用distance from border营造一种边缘点数量少，点都聚集再网格中心的效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129130442126.png" alt="image-20201129130442126"></p>
<p>sactter散布点，将Cd属性改名为pscale属性，这是为了让生成的物体中心高，边缘低</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129130629108.png" alt="image-20201129130629108"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>为了能在ue4中编辑curve属性，需要在属性面板将curve节点暴露出来</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129130810912.png" alt="image-20201129130810912"></p>
<p>剩下的看自己需求来暴露节点的属性进行修改了。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129130852851.png" alt="image-20201129130852851"></p>
<p>obejct_merge的Input类型要选择为Asset Input，因为我们的原型搭建工具是HDA</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129131147266.png" alt="image-20201129131147266"></p>
<p>最后结果，UE4的地形就能根据你摆放的原型搭建工具进行改变</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129131236728.png" alt="image-20201129131236728"></p>
]]></content>
      <categories>
        <category>Houdini</category>
      </categories>
      <tags>
        <tag>Houdini</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini利用基本形状构建地形(一)</title>
    <url>/2020/11/28/Houdini%E5%88%A9%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%BD%A2%E7%8A%B6%E6%9E%84%E5%BB%BA%E5%9C%B0%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Houdini官方教程笔记，随手记录，会比较乱</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130154350820.png" alt="image-20201130154350820"></p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>主要利用box搭建原型，然后细化，最后分层Mask导出</p>
<h3 id="利用HeightFieldProject投射构建基本地形"><a href="#利用HeightFieldProject投射构建基本地形" class="headerlink" title="利用HeightFieldProject投射构建基本地形"></a>利用HeightFieldProject投射构建基本地形</h3><p>首先利用box或者其他网格节点merge成自己想要的地形形状</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161006105.png" alt="image-20201128161006105"></p>
<p>得到结果，这里project的Max，根据你的网格进行拉伸</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161116638.png" alt="image-20201128161116638"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161023938.png" alt="image-20201128161023938"></p>
<p>也可以利用project的Mini进行网格映射的下沉，可以选择是否勾选HitFarthest，就是以最远面还是最近面来作为投射的结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161227502.png" alt="image-20201128161227502"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161238029.png" alt="image-20201128161238029"></p>
<p>得到基本的形状，然后就可以在这个基础上进行侵蚀，模糊等等操作</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161429075.png" alt="image-20201128161429075"></p>
<h3 id="基本地形的继续细化"><a href="#基本地形的继续细化" class="headerlink" title="基本地形的继续细化"></a>基本地形的继续细化</h3><p>使用blur会造成地形形状的软化缩小，所以为了在固定地形形状的前提下进行地形的blur，可以使用一下节点，<strong>Expand</strong>为扩大的意思，这样先扩大再blur即可保持基本形状的不变</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161854074.png" alt="image-20201128161854074"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161913940.png" alt="image-20201128161913940"></p>
<p>接下来就是distort，添加noise让地形更加丰富</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128162230010.png" alt="image-20201128162230010"></p>
<p>得到的最终结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128162253237.png" alt="image-20201128162253237"></p>
<h3 id="模拟地形的侵蚀"><a href="#模拟地形的侵蚀" class="headerlink" title="模拟地形的侵蚀"></a>模拟地形的侵蚀</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128162505936.png" alt="image-20201128162505936"></p>
<p>利用erode模型流水和热力的侵蚀</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128162739054.png" alt="image-20201128162739054"></p>
<p>根据maskbyfeature来进行Slump坍塌侵蚀的模拟</p>
<h3 id="进行Mask分层"><a href="#进行Mask分层" class="headerlink" title="进行Mask分层"></a>进行Mask分层</h3><p>Mask层是在UE4中进行地形材质landscape的使用。首先我们要获得layer_02层，利用Mask by feature获得斜坡mask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128164755717.png" alt="image-20201128164755717"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128164804090.png" alt="image-20201128164804090"></p>
<p>再利用mask By feature 减去一些曲率mask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128164904279.png" alt="image-20201128164904279"></p>
<p>最后用copylayer将Mask层存储为layer_02层</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165104837.png" alt="image-20201128165104837"></p>
<p>再利用remap将Mask翻转同样操作得到Layer_01层，最后利用blast只保留我们需要的mask层信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165309831.png" alt="image-20201128165309831"></p>
<h3 id="赋予材质"><a href="#赋予材质" class="headerlink" title="赋予材质"></a>赋予材质</h3><p>这样导出到UE4时就可以自动赋予UE4材质而不需要手动去拉取材质了，但这个unreal_Material目前有Bug无法使用….</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165524432.png" alt="image-20201128165524432"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165405739.png" alt="image-20201128165405739"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165608747.png" alt="image-20201128165608747"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165620882.png" alt="image-20201128165620882"></p>
]]></content>
      <categories>
        <category>Houdini</category>
      </categories>
      <tags>
        <tag>Houdini</tag>
      </tags>
  </entry>
  <entry>
    <title>Maya导出存储文件工具</title>
    <url>/2020/08/31/Maya%E5%AF%BC%E5%87%BA%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>笔记记录</p>
<a id="more"></a>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>保存场景为ma文件，并且可以加载，刷新等。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/GIF%202020-8-31%2015-49-31.gif" alt></p>
<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>主要逻辑在controllerLibrary.py脚本，save，find，load3个方法。创建ControllerLibrary类继承于dict字典类，数据存储name,path,screenshot的相关路径等等。</p>
<p>主要API：cmds.file()进行文件的存储和读取    cmds.viewFit():将摄像机对准物体    cmds.playblast():渲染导出图片    json.dump()：json文件的编码写入    json.load():json文件的解码读取</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20200831160940099.png" alt="image-20200831160940099"></p>
<pre><code>#-*-coding:gbk-*-

from maya import cmds
import os
import json
import pprint

#获取Maya文档路径
USERAPPDIR = cmds.internalVar(userAppDir=True)
#文件夹路径
DIRECTORY = os.path.join(USERAPPDIR, &quot;controllerLibrary&quot;)


def createDirectory(directory=DIRECTORY):
    &quot;&quot;&quot;
    根据文件路径创建文件夹
    Args:
        directory(str): 要创建的文件夹路径

    Returns:

    &quot;&quot;&quot;
    #首先判断文件夹是否存在
    if not os.path.exists(directory):
        #如果不存在那就创建文件夹
        os.mkdir(directory)


#继承字典类
class ControllerLibrary(dict):

    #保存文件方法
    #**info关键字参数
    def save(self,name,screenshot=True,directory=DIRECTORY,**info):

        #首先要确认要保存的路径是否存在
        createDirectory(directory)

        #保存文件路径
        path = os.path.join(directory,&quot;{0}.ma&quot;.format(name))
        #json保存文件
        infoFile = os.path.join(directory,&quot;{0}.json&quot;.format(name))
        info[&quot;name&quot;] = name
        info[&quot;path&quot;] = path

        #判是否需要screenShot
        if screenshot:
            self.saveScreenshot(name,directory)

        #进行场景文件的保存,保存格式为mayaAscii
        cmds.file(rename=path)

        #如果进行了选择，就单独保存选择了的物体场景
        if cmds.ls(selection=True):
            cmds.file(force=True,type=&quot;mayaAscii&quot;,exportSelected=True)

        #否则保存全部场景物体
        else:
            cmds.file(save=True,type=&quot;mayaAscii&quot;,force=True)

        #打开infoFile文件,保存为json格式,写入文件
        with open(infoFile,&quot;w&quot;) as f:
            json.dump(info,f,indent=4)

        self[name] = path

    #获得文件夹下的所有文件
    def find(self,directory=DIRECTORY):
        # 进行清空，避免删除.ma文件时没有更新
        self.clear()

        if not os.path.exists(directory):
            return None

        files = os.listdir(directory)

        #进行特定筛选，只获取ma文件
        mayaFiles = [f for f in files if f.endswith(&quot;.ma&quot;)]

        #进行键值对存储
        for ma in mayaFiles:
            #分离文件名和扩展名
            name,ext = os.path.splitext(ma)
            path = os.path.join(directory,ma)

            #查看是否json文件
            infoFile = &quot;{0}.json&quot;.format(name)
            if infoFile in files:
                infoFile = os.path.join(directory,infoFile)
                #读取每个场景配置的json文件
                with open(infoFile,&quot;r&quot;) as f:
                    #进行读取
                    info = json.load(f)

            else:
                print(u&quot;没有发现{0}文件&quot;.format(infoFile))
                info = {}

            #查看是否screenshot图片
            screenshot = &quot;{0}.jpg&quot;.format(name)
            if screenshot in files:
                info[&quot;screenshot&quot;] = os.path.join(directory,screenshot)

            info[&quot;name&quot;]=name
            info[&quot;path&quot;]=path

            self[name]=info
            #print(info)

    #加载
    def load(self,name):
        path = self[name][&quot;path&quot;]

        #进行加载
        cmds.file(path,i=True,usingNamespaces=False)

    #保存屏幕截图
    def saveScreenshot(self,name,directory=DIRECTORY):
        #确定图片保存的路径
        path = os.path.join(directory,&quot;{0}.jpg&quot;.format(name))

        #将摄像机对准物体，以方便进行截图
        cmds.viewFit()
        #确定保存图片格式为jpg
        cmds.setAttr(&quot;defaultRenderGlobals.imageFormat&quot;,8)

        #进行截图,这个相当于渲染命令
        &quot;&quot;&quot;
        completeFilename:导出图片的路径    forceOverwrite:是否覆盖现有的playblast     format:输出的格式
        width,heigt:分辨率     showOrnaments:是否显示轴坐标图      viewer:是否启动播放查看器
        &quot;&quot;&quot;
        cmds.playblast(completeFilename=path,forceOverwrite=True,format=&quot;image&quot;,width=200,height=200,
                       showOrnaments=False,startTime=1,endTime=1,viewer=False)

        return path
</code></pre><p>主要逻辑构建好，就可以构建UI了，UI构建在libraryUI.py中完成</p>
<pre><code>#-*-coding:gbk-*-

import controllerLibrary
from imp import reload
reload(controllerLibrary)
from PySide2 import QtWidgets,QtCore,QtGui
import maya.OpenMayaUI as omui
import maya.cmds as cmds
from shiboken2 import wrapInstance


#获取maya主窗口
def maya_main_window():
    main_window_ptr = omui.MQtUtil.mainWindow()
    return wrapInstance(long(main_window_ptr),QtWidgets.QWidget)


#ui类
class ControllerLibraryUI(QtWidgets.QDialog):

    #初始化
    def __init__(self,parent=maya_main_window()):
        super(ControllerLibraryUI, self).__init__(parent)
        self.library = controllerLibrary.ControllerLibrary()

        #图标size
        self.size = 64
        #格子Sizd
        self.buffer=12

        #设置窗口标题
        self.setWindowTitle(u&quot;控制Library窗口&quot;)
        #关闭问号按钮
        self.setWindowFlags(self.windowFlags() ^ QtCore.Qt.WindowContextHelpButtonHint)

        self.createWidgets()
        self.createLayouts()
        self.createConnects()

        #填充ListWidget
        self.populate()

    def createWidgets(self):
        self.save_btn = QtWidgets.QPushButton(&quot;save&quot;)
        self.saveName_lineEdit = QtWidgets.QLineEdit()

        #设置listWidget
        self.file_listWidget = QtWidgets.QListWidget()
        #图标模式
        self.file_listWidget.setViewMode(QtWidgets.QListWidget.IconMode)
        #设置图标大小
        self.file_listWidget.setIconSize(QtCore.QSize(self.size,self.size))
        #设置拉伸模式为Adjust
        self.file_listWidget.setResizeMode(QtWidgets.QListWidget.Adjust)
        #设置GridSize
        self.file_listWidget.setGridSize(QtCore.QSize(self.size+self.buffer,self.size+self.buffer))

        self.import_btn = QtWidgets.QPushButton(&quot;Import&quot;)
        self.refresh_btn = QtWidgets.QPushButton(&quot;Refresh&quot;)
        self.close_btn = QtWidgets.QPushButton(&quot;Close&quot;)

    def createLayouts(self):
        main_layout = QtWidgets.QVBoxLayout(self)

        save_layout = QtWidgets.QHBoxLayout()
        save_layout.addWidget(self.saveName_lineEdit)
        save_layout.addWidget(self.save_btn)
        main_layout.addLayout(save_layout)

        main_layout.addWidget(self.file_listWidget)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_layout.addWidget(self.import_btn)
        btn_layout.addWidget(self.refresh_btn)
        btn_layout.addWidget(self.close_btn)
        main_layout.addLayout(btn_layout)



    def createConnects(self):
        self.save_btn.clicked.connect(self.save)

        self.import_btn.clicked.connect(self.load)
        self.refresh_btn.clicked.connect(self.populate)
        self.close_btn.clicked.connect(self.close)

    def populate(self):

        #清空file_list，避免重复增加
        self.file_listWidget.clear()
        #获取Directory文件夹下经过筛选的文件
        self.library.find()

        #获取键值对
        for name,info in self.library.items():
            #创建ListWidegtItem
            item = QtWidgets.QListWidgetItem(name)
            #添加到file_listWidget
            self.file_listWidget.addItem(item)

            #查看是否有截图
            screenshot = info.get(&quot;screenshot&quot;)
            if screenshot:
                icon = QtGui.QIcon(screenshot)
                item.setIcon(icon)

    def load(self):
        #获取当前选中的ListWidgetItem
        currentItem = self.file_listWidget.currentItem()
        #如果没有选中，则弹出警告
        if not currentItem:
            QtWidgets.QMessageBox.warning(self,&quot;warning&quot;,u&quot;请选择文件！！&quot;)
            return

        self.library.load(currentItem.text())

    def save(self):
        #首先获取lineEdit的str
        name = self.saveName_lineEdit.text()

        #去除name的首尾空格
        if not name.strip():
            QtWidgets.QMessageBox.warning(self,&quot;warning&quot;,u&quot;名字不合法！！&quot;)
            return

        self.library.save(name)
        #重新更新ListWidget
        self.populate()
        #重置LineEdit
        self.saveName_lineEdit.setText(&quot;&quot;)


def showUI():
    ui = ControllerLibraryUI()
    ui.show()

    return ui
</code></pre><h2 id="QListView和QListWidget的区别"><a href="#QListView和QListWidget的区别" class="headerlink" title="QListView和QListWidget的区别"></a>QListView和QListWidget的区别</h2><p>我上次搞图片快速分类工具的时候，对于图片文件的预览我使用了QListView来进行数据的展示。这次我用QListWidget列表展示数据，那么他们到底有什么不一样呢？</p>
<p><strong>QlistView类用于展示数据，它的子类是QListWIdget。QListView是基于模型（Model）的，需要程序来建立模型，然后再保存数据。QListWidget是一个升级版本的QListView，它已经建立了一个数据储存模型（QListWidgetItem），直接调用addItem（）函数，就可以添加条目（Item）</strong></p>
<p>图片快速分类中QlistView的使用</p>
<pre><code>        #创建QFileSystemModel
        #QFileSystemModel是一个维护文件目录内容信息的模型，它本身不包含任何数据项，而只是表示本地文件系统上的文件和目录。
        self.file_model = QtWidgets.QFileSystemModel()
        #设置过滤器
        self.file_model.setNameFilters(self.FILTERS)
        #隐藏过滤掉的文件
        self.file_model.setNameFilterDisables(False)
        #设置Model
        self.ui.image_list_view.setModel(self.file_model)
</code></pre><p>存储导入工具中QListWidget的使用</p>
<pre><code>        #设置listWidget
        self.file_listWidget = QtWidgets.QListWidget()
        #图标模式
        self.file_listWidget.setViewMode(QtWidgets.QListWidget.IconMode)
        #设置图标大小
        self.file_listWidget.setIconSize(QtCore.QSize(self.size,self.size))
        #设置拉伸模式为Adjust
        self.file_listWidget.setResizeMode(QtWidgets.QListWidget.Adjust)
        #设置GridSize                        self.file_listWidget.setGridSize(QtCore.QSize(self.size+self.buffer,self.size+self.buffer))
</code></pre>]]></content>
      <categories>
        <category>Maya</category>
      </categories>
      <tags>
        <tag>Maya</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini创建通道和铁路(三)</title>
    <url>/2020/11/30/Houdini%E5%88%9B%E5%BB%BA%E9%80%9A%E9%81%93%E5%92%8C%E9%93%81%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先利用curve节点绘制出道路和铁路的路径轨迹，利用ray节点将曲线投射在地形的表面，根据投射得到的Mask对道路和铁路的地形进行修改，最后copy to points节点将石块和铁轨放置在点上。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130154350820.png" alt="image-20201130154350820"></p>
<a id="more"></a>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130131722045.png" alt="image-20201130131722045"></p>
<h3 id="curve曲线投射地形"><a href="#curve曲线投射地形" class="headerlink" title="curve曲线投射地形"></a>curve曲线投射地形</h3><p>curve节点绘制出道路和铁路的基本形状</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130124839080.png" alt="image-20201130124839080"></p>
<p>ray节点将曲线投射在地形上，在此之前要将HeightField转换为geometry</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130125041029.png" alt="image-20201130125041029"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130125057280.png" alt="image-20201130125057280"></p>
<h3 id="利用投射曲线创造Mask并修改Mask地形"><a href="#利用投射曲线创造Mask并修改Mask地形" class="headerlink" title="利用投射曲线创造Mask并修改Mask地形"></a>利用投射曲线创造Mask并修改Mask地形</h3><p>curve节点随便构建一个用于sweep的横截面，要在前视图创建曲线，根据需求用Transfrom对曲线进行scale的修改</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130125402354.png" alt="image-20201130125402354"></p>
<p>sweep得到的图形</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130125457068.png" alt="image-20201130125457068"></p>
<p>为了让sweep构成的图形朝上的方向为Y轴，可能是为了平面更平，需要修改一下选项（虽然我也不知道这些东西有啥用）</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130131102923.png" alt="image-20201130131102923"></p>
<p>接下来就可以maskByObject得到道路和铁路的Mask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130131701548.png" alt="image-20201130131701548"></p>
<p>用project节点将道路和铁路的object投射到地形上，造成地形的不平坦</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130131939120.png" alt="image-20201130131939120"></p>
<p>可以看到project造成的地形拉起有一点过于明显，需要blur模糊一下</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130132129245.png" alt="image-20201130132129245"></p>
<p>同样mask遮罩也过于生硬，用maskblur进行模糊</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130132210644.png" alt="image-20201130132210644"></p>
<p>接下来就可以为道路和铁路的地形添加noise细节，更多的不平坦效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130132326994.png" alt="image-20201130132326994"></p>
<p>用blend混合模式来混合原有地形和noise地形的结合</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130132417556.png" alt="image-20201130132417556"></p>
<p>最后要对mask的区域进行erode侵蚀效果处理，由于我们只想要mask地区进行侵蚀而非全部heightField，我们需要blast节点删除我们不需要的信息层。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130142430191.png" alt="image-20201130142430191"></p>
<p>同时早erode节点开启mask on表示使用mask，否则还是会应用到全地形</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130142519084.png" alt="image-20201130142519084"></p>
<p>接下来就是将计算出来的mask层存储为Layer_03层级，在此之前我们需要将mask减去一些层级信息，最后maskclear</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130142753497.png" alt="image-20201130142753497"></p>
<p>地形就能处理好了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130142854698.png" alt="image-20201130142854698"></p>
<h3 id="利用点生成石块和铁轨"><a href="#利用点生成石块和铁轨" class="headerlink" title="利用点生成石块和铁轨"></a>利用点生成石块和铁轨</h3><p>同样先将我们的曲线resample，得到更多的点，可以修改Treat Polygons As 方法得到更加平滑的曲线</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130143101334.png" alt="image-20201130143101334"></p>
<p>利用rand函数随机删除几个点，达到不规则的效果，其次为了让物体跟随曲线的旋转而旋转，需要添加orientalongcurve节点计算，得到属性N和up，这两个属性共同控制物体的朝向和旋转，如果不这样做，就会出现一下错误结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130143712900.png" alt="错误结果"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130143754077.png" alt="正确结果"></p>
<p>同时为了让生成物体更好的卡在地形表面而非被地形淹没，我们需要将地形转换为geometry然后smooth重新计算法线，将法线N更改为up，attributetransfer将地形的up传递给曲线的up属性，这样得到的效果会更好</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130144120978.png" alt="image-20201130144120978"></p>
<p>同理铁路也一样的处理方式，最后我们可以利用Mask在道路和铁路周围散布植物的点云。</p>
<p>首先利用blur节点的expand方法将layer_03往外扩一点</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130144348579.png" alt="image-20201130144348579"></p>
<p>再减去利用maskByfeature得到的斜坡遮罩，最后减去layer_03得到植物的mask遮罩，scatter散布点即可</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130144520872.png" alt="image-20201130144520872"></p>
<p>生成模型合并在一起，得到最后结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130153048776.png" alt="image-20201130153048776"></p>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>OutPut总共分为3个，一个输出地形，一个输出生成的模型，一个输出点云</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130153318367.png" alt="image-20201130153318367"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130153328375.png" alt="image-20201130153328375"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130153338818.png" alt="image-20201130153338818"></p>
]]></content>
      <categories>
        <category>Houdini</category>
      </categories>
      <tags>
        <tag>Houdini</tag>
      </tags>
  </entry>
  <entry>
    <title>Maya简易控制器</title>
    <url>/2020/08/24/Maya%E7%AE%80%E6%98%93%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<p>Maya教程笔记，过程中会记录自己所遇到的问题和新知识</p>
<a id="more"></a>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>控制器的简易添加，缩放控制器，控制器的颜色选择</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/GIF%202020-8-24%2022-52-16.gif" alt="GIF 2020-8-24 22-52-16"></p>
<h2 id="QLabel"><a href="#QLabel" class="headerlink" title="QLabel"></a>QLabel</h2><p>QLabel提供了一个文本或者图像的显示，没有提供交互功能，在建议控制器中我利用QLabel进行了文字的显示和背景颜色显示</p>
<pre><code>self.controlScale_label = QtWidgets.QLabel(u&quot;控制器Scale&quot;,alignment=QtCore.Qt.AlignCenter)
#设置格式
self.controlScale_label.setStyleSheet(&quot;background-color:rgb(0,0,0,255)&quot;)
</code></pre><h2 id="Constraints-约束"><a href="#Constraints-约束" class="headerlink" title="Constraints(约束)"></a>Constraints(约束)</h2><p>point constraints（点约束）：约束位移</p>
<p>orient constraints（反向约束）：约束旋转</p>
<p>parent constraints（父约束）：约束位移和旋转</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>1.首先要获取选中的物体，然后判断是否为joint骨骼类型，如果是则获取选中物体的所有子物体
2.根据joint数量生成一定的控制器，调整控制器的旋转和位置与joint一致
3.进行parent约束限制，这样生成的Circle就可以控制joints
4.利用Pyside2进行GUI的设置，完成交互
</code></pre><h2 id="OverrideColor设置问题"><a href="#OverrideColor设置问题" class="headerlink" title="OverrideColor设置问题"></a>OverrideColor设置问题</h2><p>首先OverrideColor指的是Shape下的设置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20200824230019419.png" alt="image-20200824230019419"></p>
<p>这里我需要将颜色设置为RGB而非索引，所以需要一下代码,这里应该可以直接设置overrideColorRGB属性的，但不知道哪里出了问题，所以我就曲线救国</p>
<pre><code>            #获取选中物体的shape
            shape = cmds.listRelatives(tempControl,children=True)[0]
            cmds.setAttr(shape+&quot;.overrideEnabled&quot;,True)
            cmds.setAttr(shape+&quot;.overrideRGBColors&quot;,1)

            #设置颜色值
            cmds.setAttr(shape+&quot;.overrideColorR &quot;,self.color.redF())
            cmds.setAttr(shape + &quot;.overrideColorG &quot;, self.color.greenF())
            cmds.setAttr(shape + &quot;.overrideColorB &quot;, self.color.blueF())
            #print(cmds.getAttr(shape+&quot;.overrideColor&quot;))
</code></pre><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20200824230220071.png" alt="image-20200824230220071"></p>
<h2 id="Circle-Scale问题"><a href="#Circle-Scale问题" class="headerlink" title="Circle Scale问题"></a>Circle Scale问题</h2><p>这里不是直接缩放Circle，而是缩放Circle的controlVertics（控制顶点），这样就可以直接连续缩放</p>
<pre><code>    def smallScale(self):
        #获得选中的物体
        selectionControl = cmds.ls(selection=True)
        #获取缩放值
        scaleFactor = self.scale_DoubleSpinBox.value()
        for tempControl in selectionControl:
            # Scale控制顶点
            cmds.scale(1-scaleFactor,1-scaleFactor,1-scaleFactor,tempControl+&quot;.cv[0:]&quot;)
</code></pre><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code># -*- coding: GBK -*-
from PySide2 import QtWidgets,QtGui,QtCore
from shiboken2 import wrapInstance
from maya import OpenMayaUI as omui
import maya.cmds as cmds

#maya主窗口
def maya_main_window():
    main_window_ptr = omui.MQtUtil.mainWindow()
    return wrapInstance(long(main_window_ptr),QtWidgets.QWidget)

window_w = 200
window_h = 168


class RigTools_Dialog(QtWidgets.QDialog):

    def __init__(self,parent = maya_main_window()):
        super(RigTools_Dialog, self).__init__(parent)
        #设置默认颜色
        self.color = QtGui.QColor(&quot;#FFFFFF&quot;)
        self.control_list=[]
        self.offset_list=[]

        #设置窗口名称
        self.setWindowTitle(&quot;RigTools&quot;)
        #设置窗口大小
        self.setFixedWidth(window_w)
        self.setFixedHeight(window_h)
        #关闭问号按钮
        self.setWindowFlags(self.windowFlags() ^ QtCore.Qt.WindowContextHelpButtonHint)

        self.createWidgets()
        self.createLayouts()
        self.createConnects()


    def createWidgets(self):
        self.rig_btn = QtWidgets.QPushButton(&quot;Rig&quot;)
        self.rig_btn.setFixedWidth(window_w)
        self.rig_btn.setFixedHeight(40)

        self.controlScale_label = QtWidgets.QLabel(u&quot;控制器Scale&quot;,alignment=QtCore.Qt.AlignCenter)
        #设置格式
        self.controlScale_label.setStyleSheet(&quot;background-color:rgb(0,0,0,255)&quot;)

        self.scale_DoubleSpinBox = QtWidgets.QDoubleSpinBox()
        #设置范围，经度，步长
        self.scale_DoubleSpinBox.setRange(0,1)
        self.scale_DoubleSpinBox.setDecimals(2)
        self.scale_DoubleSpinBox.setSingleStep(0.05)
        self.smallScale_btn = QtWidgets.QPushButton(&quot;Small&quot;)
        self.bigScale_btn = QtWidgets.QPushButton(&quot;Big&quot;)

        self.controlColor_label = QtWidgets.QLabel(u&quot;控制器颜色&quot;,alignment=QtCore.Qt.AlignCenter)
        self.controlColor_label.setStyleSheet(&quot;background-color:rgb(0,0,0,255)&quot;)

        self.color_pick_label = QtWidgets.QLabel()
        self.color_pick_label.setStyleSheet(&quot;background-color:rgb(255,255,255,255)&quot;)
        self.color_pick_btn = QtWidgets.QPushButton(u&quot;颜色选择&quot;)

        self.color_set_btn = QtWidgets.QPushButton(u&quot;颜色设置&quot;)


        pass

    def createLayouts(self):
        #主层级
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setMargin(0)
        main_layout.setSpacing(0)

        main_layout.addWidget(self.rig_btn)

        main_layout.addWidget(self.controlScale_label)

        HLayout = QtWidgets.QHBoxLayout()
        main_layout.setSpacing(5)
        HLayout.addWidget(self.scale_DoubleSpinBox)
        HLayout.addWidget(self.smallScale_btn)
        HLayout.addWidget(self.bigScale_btn)
        main_layout.addLayout(HLayout)

        main_layout.addWidget(self.controlColor_label)

        H_Color_Layout = QtWidgets.QHBoxLayout()
        H_Color_Layout.addWidget(self.color_pick_label)
        H_Color_Layout.addWidget(self.color_pick_btn)
        main_layout.addLayout(H_Color_Layout)

        main_layout.addWidget(self.color_set_btn)

        pass

    def createConnects(self):
        self.rig_btn.clicked.connect(self.rig_function)
        self.smallScale_btn.clicked.connect(self.smallScale)
        self.bigScale_btn.clicked.connect(self.bigScale)
        self.color_pick_btn.clicked.connect(self.color_pick)
        self.color_set_btn.clicked.connect(self.color_set)

    def smallScale(self):
        #获得选中的物体
        selectionControl = cmds.ls(selection=True)
        #获取缩放值
        scaleFactor = self.scale_DoubleSpinBox.value()
        for tempControl in selectionControl:
            # Scale控制顶点
            cmds.scale(1-scaleFactor,1-scaleFactor,1-scaleFactor,tempControl+&quot;.cv[0:]&quot;)
        pass

    def bigScale(self):
        # 获得选中的物体
        selectionControl = cmds.ls(selection=True)
        # 获取缩放值
        scaleFactor = self.scale_DoubleSpinBox.value()
        print(scaleFactor)
        for tempControl in selectionControl:
            #Scale控制顶点
            cmds.scale(1.0 + scaleFactor, 1.0 + scaleFactor, 1.0 + scaleFactor, tempControl+&quot;.cv[0:]&quot;)

        pass

    def color_pick(self):
        #获取颜色选择
        color = QtWidgets.QColorDialog.getColor()
        self.color = color
        self.color_pick_label.setStyleSheet(&quot;background-color: {0}&quot;.format(color.name()))

    def color_set(self):
        #获取选中的物体
        selectionControl = cmds.ls(selection=True)
        #设置颜色值
        for tempControl in selectionControl:
            #获取选中物体的shape
            shape = cmds.listRelatives(tempControl,children=True)[0]
            cmds.setAttr(shape+&quot;.overrideEnabled&quot;,True)
            cmds.setAttr(shape+&quot;.overrideRGBColors&quot;,1)

            #设置颜色值
            cmds.setAttr(shape+&quot;.overrideColorR &quot;,self.color.redF())
            cmds.setAttr(shape + &quot;.overrideColorG &quot;, self.color.greenF())
            cmds.setAttr(shape + &quot;.overrideColorB &quot;, self.color.blueF())
            #print(cmds.getAttr(shape+&quot;.overrideColor&quot;))
        pass


    def rig_function(self):
        # 获取选中的物体
        selected = cmds.ls(selection=True)

        # 判断选择物体是否为空
        if len(selected) == 0:
            cmds.warning(u&quot;请选中物体!!!&quot;)
            QtWidgets.QMessageBox.warning(self,u&quot;警告&quot;,u&quot;请选中物体!!!&quot;)
        elif len(selected) &gt; 1:
            cmds.warning(u&quot;只能选中一个物体！！！&quot;)
            QtWidgets.QMessageBox.warning(self, u&quot;警告&quot;, u&quot;只能选中一个物体！！！&quot;)
        else:
            # 判断类型是否为joint骨骼
            if cmds.objectType(selected[0]) != &quot;joint&quot;:
                cmds.warning(u&quot;选择物体类型不为joint！！！&quot;)
                QtWidgets.QMessageBox.warning(self, u&quot;警告&quot;, u&quot;选择物体类型不为joint！！！&quot;)

            else:
                # 选择该物体的包含的所有子物体和自身
                cmds.select(selected[0], hierarchy=True)
                # 获取选择的物体
                all_Joints = cmds.ls(selection=True)
                # 骨骼数
                joints_number = len(all_Joints)


                # 循环生成circle控制器
                for i in range(joints_number - 1):
                    # 生成circle
                    control = cmds.circle(name=all_Joints[i] + &quot;_control&quot;)
                    # 旋转变换
                    cmds.rotate(0, 90, 0, control[0])

                    # 冻结变换
                    cmds.makeIdentity(apply=True)
                    # 删除变换历史
                    cmds.DeleteHistory()

                    # 创建group组
                    offset_grp = cmds.group(name=all_Joints[i] + &quot;_offset&quot;, empty=True)
                    # 设置父类
                    cmds.parent(control[0], offset_grp)

                    # 获取骨骼的位置Position
                    joint_position = cmds.xform(all_Joints[i], query=True, translation=True, worldSpace=True)
                    # 将控制器移动到骨骼位置
                    cmds.xform(offset_grp, translation=joint_position)

                    # 利用orient约束将圆环旋转到骨骼方向一致
                    orient_cons = cmds.orientConstraint(all_Joints[i], offset_grp)
                    # 删除旋转约束
                    cmds.delete(orient_cons)

                    # parent约束，用于控制器控制骨骼移动
                    cmds.parentConstraint(control[0], all_Joints[i])

                    # 添加到list
                    self.control_list.append(control[0])
                    self.offset_list.append(offset_grp)

                # 重新设置父类关系
                for i in range(joints_number - 2):
                    cmds.parent(self.offset_list[i + 1], self.control_list[i])


if __name__ == &#39;__main__&#39;:
    try:
        rigTools_dialog.close()
        rigTools_dialog.deleteLater()
    except:
        pass

    rigTools_dialog = RigTools_Dialog()
    rigTools_dialog.show()
</code></pre>]]></content>
      <categories>
        <category>Maya</category>
      </categories>
      <tags>
        <tag>Maya</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(三)</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/</url>
    <content><![CDATA[<h2 id="完成漆面材质和创建铁锈材质"><a href="#完成漆面材质和创建铁锈材质" class="headerlink" title="完成漆面材质和创建铁锈材质"></a>完成漆面材质和创建铁锈材质</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00005.png" alt="HighresScreenshot00005"></p>
<a id="more"></a>
<h3 id="灯光效果"><a href="#灯光效果" class="headerlink" title="灯光效果"></a>灯光效果</h3><p>新建一个灯光效果填充，并添加Light生成器，将灯源的角度为从上往下投射，将灯光效果图层混合效果改为Value(这可能就是艺术家的直觉吧)</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201144027771.png" alt="image-20201201144027771"></p>
<p>灯光太平了，添加noise细节</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201144227025.png" alt="image-20201201144227025"></p>
<p>最后为了让灯光效果集中在某些区域，添加生成器dirt来限制区域</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201144538852.png" alt="image-20201201144538852"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201144643555.png" alt="image-20201201144643555"></p>
<h3 id="铁锈效果"><a href="#铁锈效果" class="headerlink" title="铁锈效果"></a>铁锈效果</h3><p>首先我们需要导入外部素材，添加好标签方便查询</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201145231806.png" alt="image-20201201145231806"></p>
<p>新建一个文件夹为Rust，在Rust文件夹下新建base基础颜色填充图层，只输出color，height，rought。ao通道，将导入的贴图进行应用</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201152233485.png" alt="image-20201201152233485"></p>
<p>可以看到凹凸效果过于强烈，由于height贴图已经应用，没有数值可以修改，我们可以通过图层的height来修改比例，效果就好很多了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201152339199.png" alt="image-20201201152339199"></p>
<p>可以看出Rust文件夹完全覆盖了PaintedMetal文件夹，所以需要遮罩进行修正</p>
<p>首先添加grunge Map 004 达到效果，这里不选用三面映射，是因为三面映射会造成模糊效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201154327236.png" alt="image-20201201154327236"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201154408898.png" alt="三面映射模糊"></p>
<p>继续添加细节noise，这里选用的是grunge concrete old ，混合模式为Max，取最亮</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201154550759.png" alt="image-20201201154550759"></p>
<p>可以看出铁锈的区域有点多，我们可以添加生成器light限制铁锈的区域，混合模式为Mul</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201154701956.png" alt="image-20201201154701956"></p>
<p>现在铁锈的效果是分散的，添加dirt生成器让铁锈效果更加集中一些，混合效果同样为Max</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201185618247.png" alt="image-20201201185618247"></p>
<p>再添加边缘细节，同样为利用mask editor自带的两个Texture接口可以为边缘添加noise细节，以及为竖面添加划痕</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201194232328.png" alt="image-20201201194232328"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201194255305.png" alt="image-20201201194255305"></p>
<p>最后为Rust的基础颜色添加HSL滤镜因为教程老师觉得颜色过于饱和了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201194338431.png" alt="image-20201201194338431"></p>
<h2 id="智能材质的应用和图层链接"><a href="#智能材质的应用和图层链接" class="headerlink" title="智能材质的应用和图层链接"></a>智能材质的应用和图层链接</h2><p>只要把做好的材质转换为智能材质，就能应用到其他模型上面非常的方便，因为智能材质会根据模型的不同进行烘焙贴图的切换</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201195117599.png" alt="image-20201201195117599"></p>
<p>得到结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201195620136.png" alt="image-20201201195620136"></p>
<h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><p>由于赋予的智能材质是各自为实例的，所以单独的修改不能影响全部的智能材质实例，比如我将底座的颜色改为红色，其他智能材质并不会改变</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201195801091.png" alt="image-20201201195801091"></p>
<h3 id="图层链接"><a href="#图层链接" class="headerlink" title="图层链接"></a>图层链接</h3><p>图层链接的诞生就是为了解决这个问题，右键图层—-跨纹理图层链接，即可解决问题</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201200026950.png" alt="image-20201201200026950"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201201218569.png" alt="image-20201201201218569"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>Poof效果Niagara实现</title>
    <url>/2020/10/31/Poof%E6%95%88%E6%9E%9CNiagara%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>教程：<a href="https://www.youtube.com/watch?v=aiw1slB4Mdo&amp;t=1677s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=aiw1slB4Mdo&amp;t=1677s</a>    </p>
<p>这位老哥的Niagara教程非常的棒，思路很清晰。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/Poof%E6%95%88%E6%9E%9C.gif" alt="Poof效果"></p>
 <a id="more"></a> 
<h2 id="分析实现点"><a href="#分析实现点" class="headerlink" title="分析实现点"></a>分析实现点</h2><p>1.底层的烟雾效果    2.四处飞散的烟雾效果    3.爆炸火花和漂浮火花效果</p>
<h2 id="底层的烟雾效果"><a href="#底层的烟雾效果" class="headerlink" title="底层的烟雾效果"></a>底层的烟雾效果</h2><p><strong>主要思路</strong>：利用Cylinder Location生成沿圆柱体表面的粒子，再Add Velocity达到外扩效果，最后Scale Sprite Size调整大小。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031154142500.png" alt="image-20201031154142500"></p>
<h3 id="Cylinder-Location"><a href="#Cylinder-Location" class="headerlink" title="Cylinder Location"></a>Cylinder Location</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031154347484.png" alt="image-20201031154347484"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201030170321744.png" alt="image-20201030170321744"></p>
<p>可以通过勾选SurfaceOnly，让点只生成在圆柱的表面</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201030170359427.png" alt="image-20201030170359427"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201030170405653.png" alt="image-20201030170405653"></p>
<p>也可以选择是否封盖模式，可以看到这样点就不会生成在圆柱的上下表面</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201030170548167.png" alt="image-20201030170548167"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201030170552930.png" alt="image-20201030170552930"></p>
<h3 id="Drag"><a href="#Drag" class="headerlink" title="Drag"></a>Drag</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031154558620.png" alt="image-20201031154558620"></p>
<p>其实在我看来就是摩擦力，能达到一个非常好的物理模拟效果。</p>
<h3 id="为烟雾添加Light效果"><a href="#为烟雾添加Light效果" class="headerlink" title="为烟雾添加Light效果"></a>为烟雾添加Light效果</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031154937201.png" alt="image-20201031154937201"></p>
<h2 id="四处飞散的烟雾效果"><a href="#四处飞散的烟雾效果" class="headerlink" title="四处飞散的烟雾效果"></a>四处飞散的烟雾效果</h2><p>思路：首先用一个Emitter发射出5个点来模拟烟雾的轨迹，Generate Location Event发出Event，然后另一个Emitter接受Event，完成了粒子之间的属性传递。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031155452425.png" alt="发出Event的Emitter"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031155533248.png" alt="接收Event的Emitter"></p>
<h3 id="Add-Velocity-from-point"><a href="#Add-Velocity-from-point" class="headerlink" title="Add Velocity from point"></a>Add Velocity from point</h3><p>这个也是用于添加Velocity，大概意思是根据Velocity Origin 来计算粒子点的速度，Simulation Position指Niagara System中在场景中的位置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031155754305.png" alt="image-20201031155754305"></p>
<h3 id="Generate-Location-Event"><a href="#Generate-Location-Event" class="headerlink" title="Generate Location Event"></a>Generate Location Event</h3><p>这个需要在发射器属性中勾选持久ID，Event主要实现的是Emitter之间的信息传递，一个Emitter发出Event，另一个Emitter进行监听</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031160049739.png" alt="image-20201031160049739"></p>
<p>Event Send Rate：Event发射的速率多少，会影响接收方Emitter生成粒子的数量</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031155942917.png" alt="image-20201031155942917"></p>
<h3 id="Receive-Location-Event"><a href="#Receive-Location-Event" class="headerlink" title="Receive Location Event"></a>Receive Location Event</h3><p>顾名思义是接受Event</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031160428716.png" alt="image-20201031160428716"></p>
<h2 id="爆炸火花和漂浮火花效果"><a href="#爆炸火花和漂浮火花效果" class="headerlink" title="爆炸火花和漂浮火花效果"></a>爆炸火花和漂浮火花效果</h2><p>这个比较简单，都是利用Add Velocity from point 添加了速度，让粒子往外扩，添加Curl Noise Force让粒子更飘动更随机一点，其中Hit Emitter的size是经过拉伸的，这样才能形成长方形效果，最后都是调整Size曲线</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031160730199.png" alt="image-20201031160730199"></p>
<h2 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h2><p>如果在材质中开启默认光照，特别注意光照对粒子的效果，可能会照成粒子变黑</p>
<h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><p>朴实无华</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031161649592.png" alt="image-20201031161649592"></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>DirectX11入门笔记---DirectX初始化</title>
    <url>/2020/12/17/Directx11%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0---DirectX%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210042177.png" alt="image-20201217210042177" style="zoom: 50%;"></p>
<a id="more"></a>
<p>DirectXMath之XMVECTOR ：<a href="https://blog.csdn.net/BonChoix/article/details/8280596" target="_blank" rel="noopener">https://blog.csdn.net/BonChoix/article/details/8280596</a></p>
<p>DirectXMath之XMMATRIX  ：<a href="https://blog.csdn.net/BonChoix/article/details/8280617" target="_blank" rel="noopener">https://blog.csdn.net/BonChoix/article/details/8280617</a></p>
<h2 id="Directx—-Vs2019环境配置"><a href="#Directx—-Vs2019环境配置" class="headerlink" title="Directx—-Vs2019环境配置"></a>Directx—-Vs2019环境配置</h2><p>首先打开Vs2019—-工具—-扩展工具和功能勾选一下选项</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210456000.png" alt="image-20201217210456000"></p>
<p>下载安装完毕之后，新建项目可以看到Directx11项目</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210549337.png" alt="image-20201217210549337"></p>
<p>根据龙书教程我们可以不适用VS2019自带的Directx框架，新建一个空项目，然后右键项目—-属性</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210732179.png" alt="image-20201217210732179"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217210657134.png" alt="image-20201217210657134"></p>
<h2 id="DirectX11初始化"><a href="#DirectX11初始化" class="headerlink" title="DirectX11初始化"></a>DirectX11初始化</h2><p>DirectX初始化步骤总共分为：</p>
<p>1．使用 <strong>D3D11CreateDevice</strong> 方法创建 <strong>ID3D11Device</strong> 和 <strong>ID3D11DeviceContext</strong>。 </p>
<p>2．使用 <strong>ID3D11Device::CheckMultisampleQualityLevels</strong> 方法检测设备支持的 4X 多重采样质量等级。 </p>
<p>3．填充一个 <strong>IDXGI_SWAP_CHAIN_DESC</strong> 结构体，该结构体描述了所要创建的交换链的特性。 </p>
<p>4．查询 <strong>IDXGIFactory</strong> 实例，这个实例用于创建设备和一个 <strong>IDXGISwapChain</strong> 实例。 </p>
<p>5．为交换链的后台缓冲区创建一个渲染目标视图。 </p>
<p>6．创建深度/模板缓冲区以及相关的深度/模板视图。 </p>
<p>7．将渲染目标视图和深度/模板视图绑定到渲染管线的输出合并阶段，使它们可以被Direct3D 使用。 </p>
<p>8．设置视口。</p>
<h3 id="创建Device和Context"><a href="#创建Device和Context" class="headerlink" title="创建Device和Context"></a>创建Device和Context</h3><p>Device和Context是Direct3D最重要的接口，可以通过该接口与硬件进行交互，命令硬件件完成一些工作 （比如：在显存中分配资源、清空后台缓冲区、将资源绑定到各种管线阶段、绘制几何体）。</p>
<p>1． <strong>ID3D11Device</strong> 接口用于检测显示适配器功能和分配资源。 </p>
<p>2． <strong>ID3D11DeviceContext</strong> 接口用于设置管线状态、将资源绑定到图形管线和生成渲染命令。</p>
<pre><code>HRESULT  D3D11CreateDevice(
  __in   IDXGIAdapter *pAdapter,
  __in   D3D_DRIVER_TYPE DriverType,
  __in   HMODULE Software,
  __in   UINT Flags,
  __in   const D3D_FEATURE_LEVEL *pFeatureLevels,
  __in   UINT FeatureLevels,
  __in   UINT SDKVersion,
  __out  ID3D11Device **ppDevice,
  __out  D3D_FEATURE_LEVEL *pFeatureLevel,
  __out  ID3D11DeviceContext **ppImmediateContext
);
</code></pre><p>​    1．<strong>pAdapter</strong>：指定要为哪个物理显卡创建设备对象。当该参数设为空值时，表示使用主显卡。</p>
<p>​    2．<strong>DriverType</strong>：一般来讲，该参数总是指定为 <strong>D3D_DRIVER_TYPE_HARDWARE</strong> , 表示使用 3D 硬件来加快渲染速度。</p>
<p>​    3．<strong>Software</strong>：用于支持软件光栅化设备（software rasterizer）。我们总是将该参数设为空值，因为我们使用硬件进行渲染。</p>
<ol>
<li>可选参数，一般为NULL，可以设为<strong>D3D11_CREATE_DEVICE_DEBUG</strong>、<strong>D3D11_CREATE_DEVICE_SINGLETHREADED</strong>，或两者一起，前者让要用于调试时收集信息，后者在确定程序只在单线程下运行时设置为它，可以提高性能；</li>
<li><strong>pFeatureLevels</strong>：为我们提供给程序的特征等级的一个数组，下一个参数为数组中元素个数</li>
<li><strong>SDKVersion</strong>：始终设为 <strong>D3D11_SDK_VERSION</strong>。</li>
<li><strong>ppDevice</strong>：返回创建后的设备对象。</li>
<li><strong>pFeatureLevel</strong> ： 返 回 <strong>pFeatureLevels</strong> 数 组 中 第 一 个 支 持 的 特 征 等 级 （ 如 果 <strong>pFeatureLevels</strong> 为 null，则返回可支持的最高等级）。</li>
<li><strong>ppImmediateContext</strong>：返回创建后的设备上下文。</li>
</ol>
<pre><code>    //DirectX设备
    ID3D11Device* DirectxDevice;
    //Directx上下文
    ID3D11DeviceContext* DirectxDeviceContext;

    //特征等级
    D3D_FEATURE_LEVEL featureLevels[3] =
    {
        D3D_FEATURE_LEVEL_11_0,
        D3D_FEATURE_LEVEL_10_1,
        D3D_FEATURE_LEVEL_10_0,
    };

    //当前特征等级
    D3D_FEATURE_LEVEL curLevel;

    //创建设备和上下文
    D3D11CreateDevice(
        0,        //默认显卡
        D3D_DRIVER_TYPE_HARDWARE,        //硬件加速
        0,        //硬件渲染，不适用软光栅化渲染器
        0,        //不需要收集调试信息
        featureLevels, 3,        //特征等级
        D3D11_SDK_VERSION,
        &amp;DirectxDevice,        //获取返回的设备，特征等级，上下文
        &amp;curLevel,
        &amp;DirectxDeviceContext
    );
</code></pre><h3 id="检测多重采样等级"><a href="#检测多重采样等级" class="headerlink" title="检测多重采样等级"></a>检测多重采样等级</h3><pre><code>//检查4X多重采样质量等级
    UINT m4xMsaaQualiy;
    DirectxDevice-&gt;CheckMultisampleQualityLevels(DXGI_FORMAT_R8G8B8A8_UNORM, 4, &amp;m4xMsaaQualiy);
</code></pre><h3 id="描述交换链"><a href="#描述交换链" class="headerlink" title="描述交换链"></a>描述交换链</h3><p>创建交换链前，我们需要填充DXGI_SWAP_CHAIN_DESC结构来描述交换链特性</p>
<pre><code>typedef struct DXGI_SWAP_CHAIN_DESC {
  DXGI_MODE_DESC   BufferDesc;
  DXGI_SAMPLE_DESC SampleDesc;
  DXGI_USAGE       BufferUsage;
  UINT             BufferCount;
  HWND             OutputWindow;
  BOOL             Windowed;
  DXGI_SWAP_EFFECT SwapEffect;
  UINT             Flags;
} DXGI_SWAP_CHAIN_DESC;
</code></pre><ol>
<li><strong>BufferDesc</strong>：该结构体描述了我们所要创建的后台缓冲区的属性。我们主要关注的属性有：宽度、高度和像素格式</li>
<li><strong>SampleDesc</strong>：多重采样数量和质量级别</li>
<li><strong>BufferUsage</strong>：设为 <strong>DXGI_USAGE_RENDER_TARGET_OUTPUT</strong>，因为我们要将场景渲染到后台缓冲区</li>
<li><strong>BufferCount</strong>：交换链中的后台缓冲区数量；我们一般只用一个后台缓冲区来实现双缓存。</li>
<li><strong>OutputWindow</strong>：我们将要渲染到的窗口的句柄。</li>
<li><strong>Windowed</strong>：当设为 <strong>true</strong> 时，程序以窗口模式运行；当设为 <strong>false</strong> 时，程序以全屏 （full-screen）模式运行。</li>
<li><strong>SwapEffect</strong>：设为 <strong>DXGI_SWAP_EFFECT_DISCARD</strong>，让显卡驱动程序选择最高效的显示模式。</li>
<li><strong>Flags</strong>：可选参数，主要是全屏模式下的设置</li>
</ol>
<p><strong>DXGI_MODE_DESC</strong>是另外一个结构体</p>
<pre><code>typedef struct DXGI_MODE_DESC {
  UINT                     Width;
  UINT                     Height;
  DXGI_RATIONAL            RefreshRate;
  DXGI_FORMAT              Format;
  DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;
  DXGI_MODE_SCALING        Scaling;
} DXGI_MODE_DESC, *LPDXGI_MODE_DESC;
</code></pre><ol>
<li><strong>Width</strong>：后台缓冲区宽度</li>
<li><strong>Height</strong>：后台缓冲区高度</li>
<li><strong>RefreshRate</strong>：显示刷新率</li>
<li><strong>Format</strong>：后台缓冲区像素格式</li>
</ol>
<pre><code>    //描述交换链
    DXGI_SWAP_CHAIN_DESC chainDesc;
    chainDesc.BufferDesc.Width = 640;
    chainDesc.BufferDesc.Height = 480;
    chainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;        //设置缓冲区格式
    chainDesc.BufferDesc.RefreshRate.Numerator = 60;        //刷新率
    chainDesc.BufferDesc.RefreshRate.Denominator = 1;
    chainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;        //固定参数
    chainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;

    chainDesc.BufferCount = 1;        //缓冲区个数
    chainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;        //为渲染目标Output
    chainDesc.Flags = 0;
    chainDesc.OutputWindow = hwnd;        //主窗口句柄
    chainDesc.SampleDesc.Count = 4;        //4x多重采样
    chainDesc.SampleDesc.Quality = m4xMsaaQualiy - 1;        //4x多重采样质量等级
    chainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;        //让显卡选择最高校显示模式
    chainDesc.Windowed = true;        //窗口模式
</code></pre><p><strong>注意</strong>：如果你想在运行时改变多重采样的设置，那么必须销毁然后重新创建交换链。 </p>
<p><strong>注意</strong>：因为大多数显示器不支持超过 24 位以上的颜色，再多的颜色也是浪费，所以我们将后台缓冲区的像素格式设置为 <strong>DXGI_FORMAT_R8G8B8A8_UNORM</strong>（红、绿、蓝、 alpha 各 8 位）。额外的 8 位 alpha 并不会输出在显示器上，但在后台缓冲区中可以用于特定的用途。</p>
<h3 id="创建交换链"><a href="#创建交换链" class="headerlink" title="创建交换链"></a>创建交换链</h3><p>通过<strong>IDXGIFactory::CreateSwapChain</strong> 方法创建交换链（<strong>IDXGISwapChain</strong>）</p>
<pre><code>HRESULT IDXGIFactory::CreateSwapChain( 
IUnknown *pDevice ,         // 指向 ID3D11Device 的指针 
DXGI_SWAP_CHAIN_DESC *pDesc,         // 指向一个交换链描述的指针 
IDXGISwapChain **ppSwapChain);         // 返回创建后的交换链
</code></pre><p>首先我们要通过COM查询来获得IDXGIFactory实例，然后再创建交换链，最后释放COM接口</p>
<pre><code>    //创建交换链
    IDXGISwapChain* dxgiSwapChain(NULL);
    //首先要获取接口IDXGIFactory实例
    IDXGIDevice* dxgiDevice(NULL);
    DirectxDevice-&gt;QueryInterface(__uuidof(IDXGIDevice), reinterpret_cast&lt;void**&gt;(&amp;dxgiDevice));
    IDXGIAdapter* dxgiAdapter(NULL);
    dxgiDevice-&gt;GetParent(__uuidof(IDXGIAdapter), reinterpret_cast&lt;void**&gt;(&amp;dxgiAdapter));
    IDXGIFactory* dxgiFactory(NULL);
    dxgiAdapter-&gt;GetParent(__uuidof(IDXGIFactory), reinterpret_cast&lt;void**&gt;(&amp;dxgiFactory));
    dxgiFactory-&gt;CreateSwapChain(DirectxDevice, &amp;chainDesc, &amp;dxgiSwapChain);

    //释放COM接口
    dxgiDevice-&gt;Release();
    dxgiAdapter-&gt;Release();
    dxgiFactory-&gt;Release();
</code></pre><h3 id="创建RenderTargetView"><a href="#创建RenderTargetView" class="headerlink" title="创建RenderTargetView"></a>创建RenderTargetView</h3><p>由于资源无法直接绑定到一个管线阶段，所以我们必须为资源创建资源视图，然后再把资源视图绑定到不同的管线阶段，尤其时把后台缓冲区绑定到管线输出合并阶段，我们必须要为后台缓冲区创建RenderTargetView</p>
<pre><code>    //创建资源
    ID3D11Texture2D* backBuffer;
    //获取后台缓冲区地址
    dxgiSwapChain-&gt;GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast&lt;void**&gt;(&amp;backBuffer));
    //创建RenderTargetView
    ID3D11RenderTargetView* renderTargetView;
    DirectxDevice-&gt;CreateRenderTargetView(backBuffer, 0, &amp;renderTargetView);
</code></pre><p>IDXGISwapChain::GetBuffer函数</p>
<pre><code>HRESULT GetBuffer(
  UINT   Buffer,    //获取Buffer的索引号，因为后台缓冲区数量可能会&gt;1,所以必须说明索引号
  REFIID riid,        //缓冲区的接口类型，通常是ID3D11Texture2D
  void   **ppSurface        //指向后台缓冲区的指针
);
</code></pre><p>CreateRenderTargetView函数</p>
<pre><code>HRESULT CreateRenderTargetView(
       ID3D11Resource *pResource,                //视图对应资源
       const D3D11_RENDER_TARGET_VIEW_DESC *pDesc,        //视图描述
       ID3D11RenderTargetView **ppRTView            //要创建的视图（指针的地址）
);
</code></pre><h3 id="创建深度-模板缓冲区及其视图"><a href="#创建深度-模板缓冲区及其视图" class="headerlink" title="创建深度/模板缓冲区及其视图"></a>创建深度/模板缓冲区及其视图</h3><p>深度缓冲区只是一个存储深度信息的2D纹理，创建纹理前，我们要填充<strong>D3D11_TEXTURE2D_DESC</strong> 结 构 体 来 描 述 所 要 创 建 的 纹 理 ，然后再调用 <strong>ID3D11Device::CreateTexture2D</strong> 方法。</p>
<pre><code>typedef struct D3D11_TEXTURE2D_DESC {
  UINT             Width;
  UINT             Height;
  UINT             MipLevels;        //这里不需要mipmap，设为1
  UINT             ArraySize;        //纹理数组才用，这里为1
  DXGI_FORMAT      Format;        //数据格式，一般为DXGI_FORMAT_D24_UNORM_S8_UINT,24位用于深度，8位用于模板
  DXGI_SAMPLE_DESC SampleDesc;        //多重采样，如前，前后务必保持一致！
  D3D11_USAGE      Usage;        //Usage，对于只让GPU读、写，应为D3D11_USAGE_DEFAULT
  UINT             BindFlags;        //绑定类型，为D3D11_BIND_DEPTH_STENCIL
  UINT             CPUAccessFlags;    //CPU不可访问，设为0
  UINT             MiscFlags;        //设为0
} D3D11_TEXTURE2D_DESC;
</code></pre><pre><code>    //描述深度模板纹理
    D3D11_TEXTURE2D_DESC DepthStencilDesc;
    DepthStencilDesc.Width = 640;
    DepthStencilDesc.Height = 480;
    DepthStencilDesc.MipLevels = 1;
    DepthStencilDesc.ArraySize = 1;
    DepthStencilDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
    DepthStencilDesc.SampleDesc.Count = 4;
    DepthStencilDesc.SampleDesc.Quality = m4xMsaaQualiy - 1;
    DepthStencilDesc.Usage = D3D11_USAGE_DEFAULT;
    DepthStencilDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
    DepthStencilDesc.CPUAccessFlags = 0;
    DepthStencilDesc.MiscFlags = 0;

    //创建深度模板纹理
    ID3D11Texture2D* depthStencilBuffer;
    DirectxDevice-&gt;CreateTexture2D(&amp;DepthStencilDesc, 0, &amp;depthStencilBuffer);
    //创建深度模板视图
    ID3D11DepthStencilView* depthStencilView;
    DirectxDevice-&gt;CreateDepthStencilView(depthStencilBuffer, 0, &amp;depthStencilView);


    //将视图绑定到管线的输出合并阶段
    DirectxDeviceContext-&gt;OMSetRenderTargets(1, &amp;renderTargetView, depthStencilView);
</code></pre><h3 id="设置视口Viewport"><a href="#设置视口Viewport" class="headerlink" title="设置视口Viewport"></a>设置视口Viewport</h3><p>同样需要先设置D3D11_VIEWPORT属性</p>
<pre><code>typedef struct D3D11_VIEWPORT {
  FLOAT TopLeftX;        //视口左上角在屏幕上x坐标，一般视口占满屏幕的，所以为0
  FLOAT TopLeftY;        //y坐标，同上
  FLOAT Width;            //视口宽度，一般与后缓冲区一致，以保持图像不变形
  FLOAT Height;            //高度，同上
  FLOAT MinDepth;        //最小深度值：0.0f
  FLOAT MaxDepth;        //最大深度值：1.0f
} D3D11_VIEWPORT;
</code></pre><pre><code>    //最后设置Viewport阶段
    D3D11_VIEWPORT viewPort;
    viewPort.TopLeftX = 0.0f;
    viewPort.TopLeftY = 0.0f;
    viewPort.Width = static_cast&lt;FLOAT&gt;(640);
    viewPort.Height = static_cast&lt;FLOAT&gt;(480);
    viewPort.MinDepth = 0.0f;
    viewPort.MaxDepth = 1.0f;
    DirectxDeviceContext-&gt;RSSetViewports(1, &amp;viewPort);
</code></pre><h3 id="绘制场景"><a href="#绘制场景" class="headerlink" title="绘制场景"></a>绘制场景</h3><p>进入主循环渲染函数绘制场景</p>
<pre><code>        //进入主循环绘制场景
        XMVECTORF32 color = { 0.0f,1.0f,0.0f,1.0f };
        DirectxDeviceContext-&gt;ClearRenderTargetView(renderTargetView, reinterpret_cast&lt;float*&gt;(&amp;color));
        DirectxDeviceContext-&gt;ClearDepthStencilView(depthStencilView, D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);
        dxgiSwapChain-&gt;Present(0, 0);
</code></pre><p>得到结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217205550695.png" alt="image-20201217205550695"></p>
]]></content>
      <categories>
        <category>DirectX11</category>
      </categories>
      <tags>
        <tag>DirectX11</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(一)</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="创建项目和基本操作"><a href="#创建项目和基本操作" class="headerlink" title="创建项目和基本操作"></a>创建项目和基本操作</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00005.png" alt="HighresScreenshot00005"></p>
<a id="more"></a>
<p>左上角文件 —- 新建，因为我打算把贴图到UE4尝试，所以选择的模板为UE4</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201110539670.png" alt="image-20201201110539670"></p>
<p>Alt + 鼠标左键旋转视图    Alt + 鼠标滚轮平移视图    Shift + 右键旋转HDR环境改变光照</p>
<h2 id="玻璃材质"><a href="#玻璃材质" class="headerlink" title="玻璃材质"></a>玻璃材质</h2><p>纹理集列表就是在三维软件中设置的材质ID，你分了多少个材质，在SP就会显示多少个</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201111210864.png" alt="image-20201201111210864"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201111454415.png" alt="image-20201201111454415"></p>
<p>为glass材质新建一个Shader重命名为Glass，并且在纹理集设置添加opaticy通道</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201111611371.png" alt="image-20201201111611371"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201111754424.png" alt="image-20201201111754424"></p>
<p>因为Glass shader使用的还是pbr-meta-rough并不会造成透明效果，所以我们要在着色器设置里修改为pbr-metal-rough-with-alpha-blending</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201111947608.png" alt="image-20201201111947608"></p>
<p>接下来新建一个填充图层，并且只输出opacity通道</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201112044502.png" alt="image-20201201112044502"></p>
<p>达到效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201112056726.png" alt="image-20201201112056726"></p>
<h2 id="烘焙贴图"><a href="#烘焙贴图" class="headerlink" title="烘焙贴图"></a>烘焙贴图</h2><p>纹理集设置 —- 烘焙贴图，由于我们没有高模，所以没必要烘焙Normal，厚度贴图要用到的地方比如次表面散射，所以不必要烘焙，同时为了烘焙材质ID贴图，所以教程特意复制了一个同样的模型，并为模型赋予基本颜色</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201113416434.png" alt="image-20201201113416434"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201113709879.png" alt="image-20201201113709879"></p>
<h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><p>由于我们选择的烘焙方式是默认烘焙，所以会容易出现投射错误</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201113921529.png" alt="ID"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201113944633.png" alt="曲率"></p>
<p>所以我们要修改Match方式为By Mesh，按照Mesh来进行投射烘焙，他对于模型的匹配时根据后缀来进行的，所以命名一定要规范，不然会错误</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201114222490.png" alt="image-20201201114222490"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201114243344.png" alt="命名规范"></p>
<p>得到正确的结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201114503788.png" alt="image-20201201114503788"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(五)</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)/</url>
    <content><![CDATA[<h2 id="使用id贴图和多边形填充工具制作遮罩"><a href="#使用id贴图和多边形填充工具制作遮罩" class="headerlink" title="使用id贴图和多边形填充工具制作遮罩"></a>使用id贴图和多边形填充工具制作遮罩</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00005.png" alt="HighresScreenshot00005"></p>
<a id="more"></a>
<h3 id="金属材质"><a href="#金属材质" class="headerlink" title="金属材质"></a>金属材质</h3><p>制作金属材质，添加base基础颜色layer，使用rough dirty作为粗糙度贴图</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202143149042.png" alt="image-20201202143149042"></p>
<p>调整粗糙度通道的色阶，暗部更暗，亮部更亮</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202145655888.png" alt="image-20201202145655888"></p>
<p>添加边缘颜色遮罩，同样用mask editor来获取边缘遮罩，并且添加多一个划痕贴图增加细节，混合模式最亮Max</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202150022928.png" alt="image-20201202150022928"></p>
<h3 id="利用id贴图进行金属材质和非金属材质的区分"><a href="#利用id贴图进行金属材质和非金属材质的区分" class="headerlink" title="利用id贴图进行金属材质和非金属材质的区分"></a>利用id贴图进行金属材质和非金属材质的区分</h3><p>右键图层添加颜色选择遮罩</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202150227192.png" alt="image-20201202150227192"></p>
<p>可以看到金属材质没有铁锈，需要调整rust材质的位置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202150550248.png" alt="image-20201202150550248"></p>
<p>可以看到铁锈有点暗，这是因为我们的rust材质没有输出metal信息，所以使用的是金属材质输出的metal信息导致颜色变暗</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202150852015.png" alt="image-20201202150852015"></p>
<p>解决方法也很简单，只要rust材质输出metal信息就好了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202150932135.png" alt="image-20201202150932135"></p>
<p>接下来就是给其他模型上金属材质效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202151238490.png" alt="image-20201202151238490"></p>
<h3 id="灯芯材质"><a href="#灯芯材质" class="headerlink" title="灯芯材质"></a>灯芯材质</h3><p>首先新建一个灯芯材质，首先要确定哪个地方是灯芯，利用几何体填充可以快速选择物体，这样白色的区域就是灯芯</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202155208477.png" alt="image-20201202155208477"></p>
<p>在灯芯材质文件夹下新建base基础颜色layer，height信息为Fabric贴图，baseColor则为梯度渐变贴图，营造一种下黑上白的渐变效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202155348592.png" alt="image-20201202155348592"></p>
<p>接下来为灯芯添加AO，Gradient滤镜，同时添加painterlayer手动修改遮罩，这里没有搞懂Gradient的运作方式有点迷，先跟着做</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202155811610.png" alt="image-20201202155811610"></p>
<h2 id="创建污垢和玻璃材质"><a href="#创建污垢和玻璃材质" class="headerlink" title="创建污垢和玻璃材质"></a>创建污垢和玻璃材质</h2><p>同样新建一个Dirt文件夹，base基础颜色新建黑色遮罩，用Dirt绘制遮罩，同时用Grunge concrete old来打散遮罩，混合模式为Mul</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202163557630.png" alt="image-20201202163557630"></p>
<p>现在再添加一个dirt_top层，他是作用在所有朝上的表面上，这时候就用到mask editor的方位渐变了，得到的mask效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202165722981.png" alt="image-20201202165722981"></p>
<p>最后添加concrete old 打散添加细节</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202170058251.png" alt="image-20201202170058251"></p>
<p>这样Dirt材质就做好了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202170542796.png" alt="image-20201202170542796"></p>
<h3 id="玻璃材质"><a href="#玻璃材质" class="headerlink" title="玻璃材质"></a>玻璃材质</h3><p>新建一个Glasslayer，用于遮挡图层1的透明效果，由于准备进入渲染阶段，所以可以关闭透明效果的显示</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202171816849.png" alt="image-20201202171816849"></p>
<p>再新建一个rough调节layer，用于调整玻璃的粗糙度变化</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202173442953.png" alt="image-20201202173442953"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(二)</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    <content><![CDATA[<h2 id="创建基础材质"><a href="#创建基础材质" class="headerlink" title="创建基础材质"></a>创建基础材质</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00005.png" alt="HighresScreenshot00005"></p>
<a id="more"></a>
<p>创建基础颜色base，这里我们只输出color，rough，metal信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201121157424.png" alt="image-20201201121157424"></p>
<h3 id="脏迹"><a href="#脏迹" class="headerlink" title="脏迹"></a>脏迹</h3><p>新建一个填充层控制rough，同时生成黑色遮罩，为黑色遮罩dirt生成器</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201121523720.png" alt="image-20201201121523720"></p>
<p>可以看到生成的Mask遮罩图在UV接缝处有很强烈的不连接感，可以使用三面投射解决</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201121639864.png" alt="image-20201201121639864"></p>
<p>第一层效果，有一种脏迹的感觉了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201121801376.png" alt="image-20201201121801376"></p>
<p>为黑色遮罩添加第二个填充层，选取一张程序化的划痕图，同样为了避免UV接缝选择三面映射，调整一下平衡和对比度</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201122510511.png" alt="image-20201201122510511"></p>
<p>这里我们可以发现这个新加的填充层覆盖了dirt层，我们只要调整混合模式为Max最亮即可，这样就添加了许多细节</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201133513430.png" alt="image-20201201133513430"></p>
<h3 id="油漆斑点"><a href="#油漆斑点" class="headerlink" title="油漆斑点"></a>油漆斑点</h3><p>新建一个填充图层，重命名为height高度</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201135204394.png" alt="image-20201201135204394"></p>
<p>为高度层新建一个黑色遮罩，并且赋予Bnw splots程序化纹理，调整平衡和对比度，这里与教程有点出入的是SP2018是有直方图的可以调整的，但是新版本用平衡和对比度替换掉了直方图</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201135424547.png" alt="教程"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201135447659.png" alt="新版本"></p>
<p>得到效果，有点油漆凸起的效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201135605084.png" alt="image-20201201135605084"></p>
<h3 id="边缘效果"><a href="#边缘效果" class="headerlink" title="边缘效果"></a>边缘效果</h3><p>同样操作，新建一个边缘效果图层，新建黑色遮罩，由于我们想要做边缘效果，所以我们需要一个边缘的Mask，这个可以用生成器mask editor来达到效果，这里需要将曲率拉满</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201140635232.png" alt="image-20201201140635232"></p>
<p>可以看到mask editor的基础是靠烘焙贴图来完成，所以烘焙贴图很重要</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201140724364.png" alt="image-20201201140724364"></p>
<p>达到效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201140759615.png" alt="image-20201201140759615"></p>
<p>可以看到这边缘效果太整齐划一了，可以再添加一层noise效果细化 </p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201141348276.png" alt="image-20201201141348276"></p>
<h3 id="其他颜色"><a href="#其他颜色" class="headerlink" title="其他颜色"></a>其他颜色</h3><p>为了让整体颜色更加丰富，可以再添加一层颜色细化，混合模式为overlay，亮的更亮，暗的更暗（混合模式太多了，我也不大清楚）</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201141936934.png" alt="image-20201201141936934"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini地形总结</title>
    <url>/2020/11/11/Houdini%E5%9C%B0%E5%BD%A2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201112104702922.png" alt="image-20201112104702922"></p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先利用HoudiniField 创建基本地形，HeightFieldNoise 对地形进行扰动，HeightFieldDistort对地形再次轻微扭曲失真添加细节，最后用HeightFieldErode模拟水力侵蚀和热力侵蚀。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111205217529.png" alt="image-20201111205217529"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111205229801.png" alt="image-20201111205229801"></p>
<p>利用HeightField slump 和HeightField flow 获取泥土坍塌堆积和水流流向Mask贴图，由于这两个节点的OutLayout名字都叫flowdir，为避免重复，需要用到heightField copylayout和heightfield Layer重新传递图层信息。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111205730008.png" alt="image-20201111205730008"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111205741959.png" alt="image-20201111205741959"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111205755804.png" alt="image-20201111205755804"></p>
<p>利用maskByfeature，顾名思义是利用地形特点获取mask图，这里先获取平坦地面的mask图，然后利用blur和noise节点为平坦地面添加凹凸细节</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111211908052.png" alt="image-20201111211908052"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111211844494.png" alt="image-20201111211844494"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111212100019.png" alt="image-20201111212100019"></p>
<h3 id="开始构造岩石，土壤，草地Mask"><a href="#开始构造岩石，土壤，草地Mask" class="headerlink" title="开始构造岩石，土壤，草地Mask"></a>开始构造岩石，土壤，草地Mask</h3><p> 底层是岩石，中间是土壤，最上层是草地，三者互不重叠</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201105144214013.png" alt="image-20201105144214013"></p>
<h4 id="草地"><a href="#草地" class="headerlink" title="草地"></a>草地</h4><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213252547.png" alt="image-20201111213252547"></p>
<p>首先利用maskByFeature节点获取平坦地方的Mask，只用到了坡度来获取Mask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111212520982.png" alt="image-20201111212520982"></p>
<p>可以法线获取到的Mask存在瑕疵，居然山顶上也有Mask，所以我还需要下一个maskByFeature进行处理</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111212556907.png" alt="image-20201111212556907"></p>
<p>这里模式为Subtract，即用上一个Mask图减去此节点得到的Mask，这里用到了Height和Valleys</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111212751592.png" alt="image-20201111212751592"></p>
<p>可以看到效果好了许多，得到最基本的GrassMask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111212837053.png" alt="image-20201111212837053"></p>
<h4 id="土壤"><a href="#土壤" class="headerlink" title="土壤"></a>土壤</h4><p>土壤利用flow层级信息获取最基本的土壤信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213235215.png" alt="image-20201111213235215"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213322478.png" alt="image-20201111213322478"></p>
<h4 id="岩石"><a href="#岩石" class="headerlink" title="岩石"></a>岩石</h4><p>岩石基础Mask比较简单，因为岩石是最底层，所以肯定为1全部覆盖，用maskbyClear即可得到</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214259233.png" alt="image-20201111214259233"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214246075.png" alt="image-20201111214246075"></p>
<h4 id="土壤和草地混合Mask"><a href="#土壤和草地混合Mask" class="headerlink" title="土壤和草地混合Mask"></a>土壤和草地混合Mask</h4><p>为了得到更加随机混合的效果，我们需要将之前得到的土壤和草地BaseMask进行合并</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213512156.png" alt="image-20201111213512156"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213458102.png" alt="image-20201111213458102"></p>
<p>得到效果如下</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213545071.png" alt="image-20201111213545071"></p>
<p>依然利用blur，remap获取一个新的草地Mask，然后利用maskByFeature的Valleys去除一部分草地的Mask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213902857.png" alt="image-20201111213902857"></p>
<p>得到的最终草地Mask，土壤Mask用合并的Mask再减去新的草地Mask即可得到</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213959576.png" alt="最终草地Mask"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214029285.png" alt="最终土壤Mask"></p>
<p>岩石Mask也是减去土壤和草地合并Mask即可得到</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214138824.png" alt="最终岩石Mask"></p>
<h4 id="存储得到的rock，soil，grass层级信息"><a href="#存储得到的rock，soil，grass层级信息" class="headerlink" title="存储得到的rock，soil，grass层级信息"></a>存储得到的rock，soil，grass层级信息</h4><p>利用copyLayout来生成新的层级来存储Mask，然后利用HeightFieldLayout存储刚才得到的层级信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214453245.png" alt="image-20201111214453245"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214537997.png" alt="image-20201111214537997"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214723898.png" alt="image-20201111214723898"></p>
<h3 id="开始散布点"><a href="#开始散布点" class="headerlink" title="开始散布点"></a>开始散布点</h3><p>树肯定是分布在grass层级，所以我们要在grass层级上copy生成一个tree层级，然后scatter散布点</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215158189.png" alt="image-20201111215158189"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215205219.png" alt="tree层级"></p>
<p>利用HeightFieldScatter进行点的散布</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215315583.png" alt="image-20201111215315583"></p>
<p>这里根据CoverageMask进行覆盖，Coverage调整覆盖度（数量），剩下的OuterRadius和Falloff不大清楚是用来干嘛的，iteration大概是点生成的迭代次数，迭代越多越精准</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215352253.png" alt="image-20201111215352253"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215715422.png" alt="得到效果"></p>
<p>散布完树的点之后，就要散布灌木，这里注意Tag名称，由于我们规定灌木要生长在树的周边，而我们之前生成好的树点都带有tree标签，我们根据Tag进行生成即可</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215813278.png" alt="image-20201111215813278"></p>
<p>分别控制生成数量，生成范围，生成大小</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215954770.png" alt="image-20201111215954770"></p>
<p>其他物体的生成也是如此推算即可。</p>
<h3 id="生成HDA导入到UE4"><a href="#生成HDA导入到UE4" class="headerlink" title="生成HDA导入到UE4"></a>生成HDA导入到UE4</h3><p>首先把全部节点打包为一个subnet，右键生成HDA</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220320744.png" alt="image-20201111220320744"></p>
<p>可以暴露参数到UE4里面进行修改</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220422258.png" alt="image-20201111220422258"></p>
<p>这里暴露了HeightField的Size和GridSpace属性，这样在UE4就可以修改地形的大小</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220440315.png" alt="image-20201111220440315"></p>
<p>在UE4引擎中开启Houdini插件即可，<strong>注意：需要安装对应版本的Houdini才会有这个插件出现</strong></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220624308.png" alt="image-20201111220624308"></p>
<h3 id="地形材质LandScape"><a href="#地形材质LandScape" class="headerlink" title="地形材质LandScape"></a>地形材质LandScape</h3><p>主要用到节点LandScapeUV，LayerBlend</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220820996.png" alt="image-20201111220820996"></p>
<p>这里对应的图层信息为Houdini的图层名称，否则会出错</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220846653.png" alt="image-20201111220846653"></p>
<p>这里我学到一个新的种草技能，利用LandScapeOutPut进行物体的在指定图层的摆放。这里就在Grass种草和种花</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111221039097.png" alt="image-20201111221039097"></p>
<p>需要landSpaceGrassTye</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111221205436.png" alt="image-20201111221205436"></p>
<h3 id="进行模型的替换"><a href="#进行模型的替换" class="headerlink" title="进行模型的替换"></a>进行模型的替换</h3><p>这里有两种选择，一种在UE4进行手动替换</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111221407109.png" alt="image-20201111221407109"></p>
<p>第二种在Houdini里用代码规定好，例如利用attributeCreate规定地形的材质，利用AttributeWrangle设定模型</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111221516447.png" alt="image-20201111221516447"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111221842452.png" alt="image-20201111221842452"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Houdini地形创建先创造基本地形，然后利用各种Mask节点来构造土壤，岩石，草地的Mask分层，最后利用HeightFieldScatter进行点的散布，导进UE4进行地形材质的构造，种草种花完美结束。</p>
]]></content>
      <categories>
        <category>Houdini</category>
      </categories>
      <tags>
        <tag>Houdini</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(六)---最终成果</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)/</url>
    <content><![CDATA[<h2 id="渲染作品图片"><a href="#渲染作品图片" class="headerlink" title="渲染作品图片"></a>渲染作品图片</h2><p>Iray，只渲了两分钟电脑实在顶不住了<img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/%E6%B8%B2%E6%9F%93%E6%88%90%E5%9B%BE.jpg" alt="渲染成图"></p>
<a id="more"></a>
<p>UE4由于没有添加任何效果可能看起来有点难看，但问题不大</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00004.png" alt="HighresScreenshot00004"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00003.png" alt="HighresScreenshot00003"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(四)</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/</url>
    <content><![CDATA[<h2 id="理解笔刷系统"><a href="#理解笔刷系统" class="headerlink" title="理解笔刷系统"></a>理解笔刷系统</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00005.png" alt="HighresScreenshot00005"></p>
<a id="more"></a>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>ctrl + 鼠标右键左右移动控制笔刷大小</p>
<p>ctrl + 鼠标右键上下移动控制笔刷软硬</p>
<p>ctrl + 鼠标左键左右控制笔刷透明度</p>
<p>ctrl + 鼠标左键上下控制笔刷旋转</p>
<p>左上的画笔调节栏</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201221236504.png" alt="image-20201201221236504"></p>
<p>当我们把笔刷透明度调整为少于100的时候，他会自动叠加到100透明度的效果，如果不想叠加可以按着A + 鼠标左键进行绘制</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/%E7%AC%94%E5%88%B7%E9%80%8F%E6%98%8E%E5%BA%A6.gif" alt="笔刷透明度"></p>
<p>平滑笔刷可以绘制曲线的时候变得很漂亮平滑</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202115810636.png" alt="image-20201202115810636"></p>
<p>跟随路径作用是让绘制的图案跟随曲线的旋转而旋转</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202120102297.png" alt="image-20201202120102297"></p>
<p>绘画面板右键可以看到有：创建工具预设，创建材质预设，创建笔刷预设</p>
<p>工具预设：保存材质和笔刷</p>
<p>材质预设：只保存材质</p>
<p>笔刷预设：只保存笔刷</p>
<p>根据校准的选择会造成绘制的不同</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202132143033.png" alt="image-20201202132143033"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202132341569.png" alt="image-20201202132341569"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202132400295.png" alt="image-20201202132400295"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202132413256.png" alt="image-20201202132413256"></p>
<p>添加绘制模板Stencil，其实就是提供一个基于屏幕空间的遮罩</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202132739768.png" alt="image-20201202132739768"></p>
<h2 id="使用绘画特效，映射和克隆工具"><a href="#使用绘画特效，映射和克隆工具" class="headerlink" title="使用绘画特效，映射和克隆工具"></a>使用绘画特效，映射和克隆工具</h2><p>绘画特效其实就是人为绘制遮罩，X快速切换绘制的黑白颜色</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202133248432.png" alt="image-20201202133248432"></p>
<p>映射工具就是基于屏幕空间的纹理绘制</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202133551413.png" alt="image-20201202133551413"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202133716766.png" alt="image-20201202133716766"></p>
<p>克隆工具就是PS的仿制图章，需要将用到的通道混合模式都设置为Passthrough才有效，按V键对源区域进行采样</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202134301094.png" alt="image-20201202134301094"></p>
<h2 id="使用锚定点"><a href="#使用锚定点" class="headerlink" title="使用锚定点"></a>使用锚定点</h2><p>锚定点是一种在一个图层中设置目标通道，让其他图层使用的工具</p>
<p>添加文字layer，需要将笔刷的Alpha选为文字贴图Font Chathura</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202134640596.png" alt="image-20201202134640596"></p>
<p>切换到AO通道，可以看到刚才添加的文字层并没有AO信息，所以我们可以为其添加AO信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202134848402.png" alt="image-20201202134848402"></p>
<p>添加HBAO滤镜就可以为文字layer的AO信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202135059369.png" alt="image-20201202135059369"></p>
<p>最后添加一下Blur滤镜</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202135451556.png" alt="image-20201202135451556"></p>
<p>可以看到我们的文字并没有和rust铁锈材质进行结合，因为rust铁锈材质的遮罩是根据模型烘焙好的信息进行区分的，但是文字layer的height信息和AO信息都是后面加的，并没有存在烘焙好的贴图上，这时候锚定点的作用就来了。</p>
<p>首先为文字layer右键添加一个锚定点</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202140128258.png" alt="image-20201202140128258"></p>
<p>在rust的mask editor中微高度添加锚定点，由于我们文字layer只输出height信息，所以引用通道也要选择为Height</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202140503858.png" alt="image-20201202140503858"></p>
<p>其次在微细节中进行细节的调整，并打开微高度开关，可以看到文字上也有了铁锈的痕迹</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202140857193.png" alt="image-20201202140857193"></p>
<p>添加个人标记嘻嘻嘻</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202142517637.png" alt="image-20201202142517637"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4---Flowmap燃烧溶解笔记</title>
    <url>/2021/01/04/UE4---Flowmap%E7%87%83%E7%83%A7%E6%BA%B6%E8%A7%A3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-4%2019-06-03.gif" alt="GIF 2021-1-4 19-06-03"></p>
<a id="more"></a>
<p>由于时间有点紧张，所以就没有去细化效果，有点难看说实话哈哈哈</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/222500848" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/222500848</a></p>
<p><a href="https://deepspacebanana.github.io/deepspacebanana.github.io/blog/shader/art/unreal%20engine/Flowmapped-Burn-Shader" target="_blank" rel="noopener">https://deepspacebanana.github.io/deepspacebanana.github.io/blog/shader/art/unreal%20engine/Flowmapped-Burn-Shader</a></p>
<h2 id="FlowMap"><a href="#FlowMap" class="headerlink" title="FlowMap"></a>FlowMap</h2><p>FlowMap其实就是UV动画，常用于制作流动效果，只有RG通道，存储的是流动的方向，下面就是存储了顺时针流动方向的Flowmap</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104143838673.png" alt="image-20210104143838673"></p>
<h3 id="处理FlowMap"><a href="#处理FlowMap" class="headerlink" title="处理FlowMap"></a>处理FlowMap</h3><p>FlowMap导入UE4需要取消勾选sRGB，压缩设置为向量置换贴图，否则会因为压缩出像质量损失问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104144114189.png" alt="image-20210104144114189"></p>
<p>由于图片无法保存负数信息，所以将信息保存到0-1之间，所以我们需要手动去还原信息，与法线贴图的方法一致</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104144429412.png" alt="image-20210104144429412"></p>
<p>我们还要反转R通道才能得到正确的方向，当然如果你在FlowPainter勾选了FilpR那就不用在UE4里再次翻转了</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104144534648.png" alt="image-20210104144534648"></p>
<p>因为要动起来，所以我们需要将刚才得到的偏移方向与时间相乘，为了让Time更好的控制偏移，我们需要将Time连接Frac节点，这样得到在0-1不断循环的区间</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104145600411.png" alt="image-20210104145600411"></p>
<p>可以看到有很明显的割裂感，不是gif录制造成的嗷</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-4%2014-56-31.gif" alt="GIF 2021-1-4 14-56-31"></p>
<p>这是因为Frac(Time)这里过度不顺滑</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104150347088.png" alt="image-20210104150347088"></p>
<p>所以我们需要两段UV动画进行缓和，达到比较平缓的过度，让Time+0.5就可以得到第二段动画</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104155023312.png" alt="image-20210104155023312"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104155037627.png" alt="image-20210104155037627"></p>
<p>现在需要将两端UV动画进行Lerp淡入淡出，将Frac之后的Time缩放到-1到1再绝对值，既可以得到下面函数表示，完美过渡了0-1的割裂感</p>
<p><img src="https://pic3.zhimg.com/v2-36d58a1fb5c230ee77c5178ed697d5ca_b.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-4%2015-54-29.gif" alt="GIF 2021-1-4 15-54-29"></p>
<p>这里原作者的flowmap感觉是为了更好的在UE4中控制燃烧的流向，所以FlowMap感觉差不多是同一个方向，所最终材质蓝图如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104162452311.png" alt="image-20210104162452311"></p>
<h2 id="SphereMask"><a href="#SphereMask" class="headerlink" title="SphereMask"></a>SphereMask</h2><p>利用SphereMask来决定然后燃烧范围，通过材质参数集来传递SphereMask的中心以及半径</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104163901721.png" alt="image-20210104163901721"></p>
<p>我们将中心设置为0，0，0，可以看到黑色区域随着半径的增大而增大</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-4%2016-40-32.gif" alt="GIF 2021-1-4 16-40-32"></p>
<p>最后与上面得到FlowMap灰度图进行相减，并限制范围在0-1</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104164144436.png" alt="image-20210104164144436"></p>
<p>得到一个有燃烧流向的Mask图</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-4%2016-42-36.gif" alt="GIF 2021-1-4 16-42-36"></p>
<p>按照道理来说，燃烧是以中心点开始往四周燃烧的，如果我们不将SphereMask乘2将得到下面的结果，可以看到与球体中心距离较远的地方都变黑了，这是不正常的，所以要乘2</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104164733054.png" alt="image-20210104164733054"></p>
<h2 id="边缘发光和烧焦"><a href="#边缘发光和烧焦" class="headerlink" title="边缘发光和烧焦"></a>边缘发光和烧焦</h2><p>利用Distance节点来获取边缘Mask</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104171030049.png" alt="image-20210104171030049"></p>
<p>得到如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104171112042.png" alt="image-20210104171112042"></p>
<p>原理分析，首先我们得到SphereMask与FlowMap处理过后Mask贴图颜色分析如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104171438318.png" alt="image-20210104171438318"></p>
<p>那么我们将图连接Distance 0.45，中心得到的颜色则是abs（0 - 0.45）,边缘得到的颜色是abs（0.45-0.45），为燃烧区域则是abs（1-0.45）,结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104171738730.png" alt="image-20210104171738730"></p>
<p>接下来我们确定边缘Mask的范围，并缩放到0-1区间，比如我们除以0.1，那么0-0.1边缘区间就会缩放为0-1，而其他不相干区域就会变为大于1，到时候连接1-节点，就可以得到真正的边缘Mask</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104172436798.png" alt="image-20210104172436798"></p>
<p>烧焦会比辉光更前一些，所以Distance为0.5</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104173443524.png" alt="image-20210104173443524"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104173500963.png" alt="image-20210104173500963"></p>
<h2 id="Editor模式下运行ActorTick方法"><a href="#Editor模式下运行ActorTick方法" class="headerlink" title="Editor模式下运行ActorTick方法"></a>Editor模式下运行ActorTick方法</h2><p>只需要重载Actor的ShouldTickIfViewportsOnly()函数，令其返回true，这样就会在Edtor下调用该类型对象的Tick()函数</p>
<p>参考文章：<a href="https://chriszuko.com/ue4-how-to-editor-tick/" target="_blank" rel="noopener">https://chriszuko.com/ue4-how-to-editor-tick/</a></p>
<p>结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-4%2019-01-04.gif" alt="GIF 2021-1-4 19-01-04"></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4---RayMarch史莱姆</title>
    <url>/2021/01/03/UE4---%E5%8F%B2%E8%8E%B1%E5%A7%86%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103023008823.png" alt="image-20210103023008823"></p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.利用RayMarch先绘制个球</p>
<p>2.处理材质与其他模型交界过硬问题</p>
<p>3.构建法线</p>
<p>4.平滑合并</p>
<h3 id="绘制球"><a href="#绘制球" class="headerlink" title="绘制球"></a>绘制球</h3><p>同样是首先传入CameraDir和WorldPos，MAX_Step，构建距离场，渲染距离场，屏幕射线与物体进行求交</p>
<pre><code>float4 finalCol = 0.0f;
float3 pos = WorldPos;

for (int i = 0; i&lt;MAX_Step; i++)
{
    //球体距离场
    float distance = length(pos) - 50.0f;

    //判断距离是否足够接近
    if (distance&lt;0.01f)
    {
        finalCol = 1.0f;
        break;
    }

    //累加距离
    pos += CameraDir * distance;
}

return finalCol;
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102155523945.png" alt="image-20210102155523945"></p>
<p>现在还有一个问题就是，我们RayMarch绘制得到的球体不会跟随物体的移动而移动</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-2%2015-57-15.gif" alt="GIF 2021-1-2 15-57-15"></p>
<p>解决方法：我们添加一个ObjectPostion的偏移即可，ObjectPostion其实就是场景物体的中心轴位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102155925606.png" alt="image-20210102155925606"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102155939867.png" alt="image-20210102155939867"></p>
<p>只要把ObjectPostion节点传入usf进行处理即可</p>
<pre><code>float distance = length(pos - ObjectPos) - 50.0f;
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102160234169.png" alt="image-20210102160234169"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-2%2016-01-22.gif" alt="GIF 2021-1-2 16-01-22"></p>
<h3 id="处理材质与其他模型交界过硬问题"><a href="#处理材质与其他模型交界过硬问题" class="headerlink" title="处理材质与其他模型交界过硬问题"></a>处理材质与其他模型交界过硬问题</h3><p>可以看到交界非常的硬，我们解决这个问题一般使用SceneDepth解决</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102162741467.png" alt="image-20210102162741467"></p>
<p>在for循环中添加以下代码</p>
<pre><code>    //处理与其他模型交界过硬问题
    if (SceneDepth &lt; length(pos - CameraPos))
    {
        break;
    }
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102162817759.png" alt="image-20210102162817759"></p>
<p>物体在屏幕中间时显示正常，当物体移动到屏幕边缘时，球体会出现严重的变形</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-2%2020-14-37.gif" alt="GIF 2021-1-2 20-14-37"></p>
<p>出现问题的原因：当我们摄像机往左移动时候，场景深度并没有改变都是一样的，但是我们的length(pos - CameraPos)由于我们摄像机的移动是变大了，所以造成畸变变小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102201739300.png" alt="image-20210102201739300"></p>
<p>相对于摄像机平面同一条直线上的场景深度是一样，这可以我们可以看渲染管线的变换可以知道，当然我这里选择用材质来证明，可以看到同一直线上的颜色一致的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102202259011.png" alt="image-20210102202259011"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102202322138.png" alt="image-20210102202322138"></p>
<p>解决方法：用一个trick对SceneDepth进行弥补，其实就是用CameraVector和CameraDirectionVector进行弥补</p>
<p>CameraVector像素指向Camera的方向</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/CameraVectorImage.png" alt="img"></p>
<p>CameraDirectionVector摄像机面对的方向</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102204629558.png" alt="image-20210102204629558"></p>
<p>通过点积即可完成对边缘SceneDepth的弥补操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102204843678.png" alt="image-20210102204843678"></p>
<p>最后结果，可以看出畸变情况好了很多</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-2%2020-49-16.gif" alt="GIF 2021-1-2 20-49-16"></p>
<h3 id="构建法线"><a href="#构建法线" class="headerlink" title="构建法线"></a>构建法线</h3><p>思路和上一篇文章一样，代码如下，<strong>注意定义多个函数需要把函数放入结构体内</strong>    </p>
<pre><code>struct FunctionStruct
{
    //构建球体距离场
    float sphere(float3 pos)
    {
        return length(pos) - 50.0f;

    }

    //计算法线方向
    float3 CalNormal(float3 pos)
    {
        float D_value = 0.01f;
        return normalize(float3(
        sphere(float3(pos.x + D_value, pos.y, pos.z)) - sphere(float3(pos.x - D_value, pos.y, pos.z)),
        sphere(float3(pos.x, pos.y + D_value, pos.z)) - sphere(float3(pos.x, pos.y - D_value, pos.z)),
        sphere(float3(pos.x, pos.y, pos.z + D_value)) - sphere(float3(pos.x, pos.y, pos.z - D_value))
        ));

    }
};

FunctionStruct FS;
float hit = 0.0f;
float3 pos = WorldPos;
float3 normal = 0.0f;

for (int i = 0; i&lt;MAX_Step; i++)
{

    //处理与其他模型交界过硬问题
    if (SceneDepth &lt; length(pos - CameraPos))
    {
        break;
    }

    //球体距离场
    float distance = FS.sphere(pos - ObjectPos);

    //判断距离是否足够接近
    if (distance&lt;0.01f)
    {
        hit = 1.0f;
        normal = FS.CalNormal(pos - ObjectPos);
        break;
    }


    //累加距离
    pos += CameraDir * distance;
}

return float4(normal,hit);
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102211839166.png" alt="image-20210102211839166"></p>
<p>获取法线之后要传入UE4材质就可以享受UE4的光照效果，需要着色模型为默认光照，光照模式为体积方向，取消勾选切线空间法线</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102212252727.png" alt="image-20210102212252727"></p>
<h3 id="平滑合并"><a href="#平滑合并" class="headerlink" title="平滑合并"></a>平滑合并</h3><p>平滑函数</p>
<pre><code>float smin( float a, float b, float k){
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);
    return lerp( b, a, h) - k*h*(1.0-h);
}
</code></pre><p>这里就有一个问题，平滑函数需要a,b两个距离场参数，但是我们只有到球体的距离场，那怎么获取b参数呢？</p>
<p>原视频作者给出了两种方案。</p>
<h4 id="方案1（不太明白）"><a href="#方案1（不太明白）" class="headerlink" title="方案1（不太明白）"></a>方案1（不太明白）</h4><p>利用SceneDepth - length(pos - CameraPos)得到b参数，然后进行平滑合并</p>
<pre><code>    float a = FS.sphere(pos - ObjectPos);
    float b = SceneDepth - length(pos - CameraPos);
    float distance = FS.smin(a,b,Smooth);
</code></pre><p>如果我们将合并到的distance直接累加到pos，虽然球体与其他模型边缘会平滑，但是整体的效果会是错误的，用于存放球体的模型都会被渲染出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103014640415.png" alt="image-20210103014640415"></p>
<p>因为得到的distance只有接近边缘时才会正确，所以我们不以distance进行累加，而是让pos每次循环沿屏幕射线前进1(感觉非常耗性能)</p>
<pre><code>for (int i = 0; i&lt;MAX_Step; i++)
{

    //处理与其他模型交界过硬问题
    if (SceneDepth &lt; length(pos - CameraPos))
    {
        break;
    }

    //球体距离场
    float a = FS.sphere(pos - ObjectPos);
    float b = SceneDepth - length(pos - CameraPos);
    float distance = FS.smin(a,b,Smooth);

    //判断距离是否足够接近
    if (distance&lt;0.01f)
    {
        hit = 1.0f;
        normal = FS.CalNormal(pos - ObjectPos);
        break;
    }


    //累加距离
    pos += CameraDir * 1;
}
</code></pre><p>这样就得到一个非常漂亮的史莱姆了</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103015700192.png" alt="image-20210103015700192"></p>
<p>创建材质实例更容易进行调节</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103015759196.png" alt="image-20210103015759196"></p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>UE4是支持生成网格距离场的，项目设置—-distance</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103015956546.png" alt="image-20210103015956546"></p>
<p>可以看到为正方体和存放球体的模型以及平面都生成了距离场，但是分辨率不高</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103020419152.png" alt="image-20210103020419152"></p>
<p>这里我们没必要为存放球体模型生成距离场，取消勾选距离场光照</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103020518820.png" alt="image-20210103020518820"></p>
<p>在世界场景设置中设置距离场精细度</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103020723548.png" alt="image-20210103020723548"></p>
<p>通过DistanceToNeareastSurface节点获取最近平面距离</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103020906402.png" alt="image-20210103020906402"></p>
<p>如果我们需要在自己的usf中使用该节点，可以查看HLSL代码查看函数名称，如果带有global则全局可用</p>
<pre><code>for (int i = 0; i&lt;MAX_Step; i++)
{

    //处理与其他模型交界过硬问题
    if (SceneDepth &lt; length(pos - CameraPos))
    {
        break;
    }

    //球体距离场
    float a = FS.sphere(pos - ObjectPos);
    //float b = SceneDepth - length(pos - CameraPos);
    float b = GetDistanceToNearestSurfaceGlobal(pos);
    float distance = FS.smin(a,b,Smooth);

    //判断距离是否足够接近
    if (distance&lt;Stop)
    {
        hit = 1.0f;
        normal = FS.CalNormal(pos - ObjectPos);
        break;
    }


    //累加距离
    pos += CameraDir * 1;
}
</code></pre><p>得到漂亮的小球</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103022635893.png" alt="image-20210103022635893"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>感觉RayMarching太耗性能了，而且近看有因为精细度造成的锯齿问题，还有有很好的数学能力才会绘制出好看的场景</p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4---RayMarching笔记</title>
    <url>/2021/01/02/UE4---RayMarching%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102144520239.png" alt="image-20210102144520239"></p>
<a id="more"></a>
<h2 id="UE4Shader环境设置"><a href="#UE4Shader环境设置" class="headerlink" title="UE4Shader环境设置"></a>UE4Shader环境设置</h2><p>usf和ush是UE4的shader文件格式，相当于C++的.cpp和.h。那么这些文件该存在哪里我们才能在customNode节点里面引入使用呢？我这里先随便先弄#include一个usf</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20201230175543818.png" alt="image-20201230175543818"></p>
<p>可以看到由于我们存放到指定Map的位置，这些Shader文件是无法被正确#include的，所以接下来我们的操作就是要新建一个插件用于存储Shader，并且在插件导入的时候让UE4正确识别Shader文件的路径</p>
<h3 id="新建插件"><a href="#新建插件" class="headerlink" title="新建插件"></a>新建插件</h3><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20201230175958026.png" alt="image-20201230175958026"></p>
<p>cpp文件修改如下</p>
<pre><code>
#include &quot;OpdaShaderPlugin.h&quot;
#include &lt;Interfaces\IPluginManager.h&gt;

#define LOCTEXT_NAMESPACE &quot;FOpdaShaderPluginModule&quot;

void FOpdaShaderPluginModule::StartupModule()
{
    //获取插件下的Shader文件夹
    FString ShaderDirectory = FPaths::Combine(IPluginManager::Get().FindPlugin(&quot;OpdaShaderPlugin&quot;)-&gt;GetBaseDir()
        , TEXT(&quot;Shaders&quot;));
    UE_LOG(LogLoad, Warning, TEXT(&quot;%s&quot;),*ShaderDirectory);
    //将这个文件夹添加到Shader的虚拟路径上
    AddShaderSourceDirectoryMapping(&quot;/Opda&quot;, ShaderDirectory);
    // This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module
}

void FOpdaShaderPluginModule::ShutdownModule()
{
    ResetAllShaderSourceDirectoryMappings();
    // This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
    // we call this function before unloading the module.

}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FOpdaShaderPluginModule, OpdaShaderPlugin)
</code></pre><p>在插件的Build.cs添加依赖模块</p>
<pre><code>// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class OpdaShaderPlugin : ModuleRules
{
    public OpdaShaderPlugin(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicIncludePaths.AddRange(
            new string[] {
                // ... add public include paths required here ...
            }
            );


        PrivateIncludePaths.AddRange(
            new string[] {
                // ... add other private include paths required here ...
            }
            );


        PublicDependencyModuleNames.AddRange(
            new string[]
            {
                &quot;Core&quot;,
                &quot;RenderCore&quot;,
                &quot;RHI&quot;,
                // ... add other public dependencies that you statically link with here ...
            }
            );


        PrivateDependencyModuleNames.AddRange(
            new string[]
            {
                &quot;CoreUObject&quot;,
                &quot;Engine&quot;,
                &quot;Slate&quot;,
                &quot;SlateCore&quot;,
                &quot;Projects&quot;,
                // ... add private dependencies that you statically link with here ...    
            }
            );


        DynamicallyLoadedModuleNames.AddRange(
            new string[]
            {
                // ... add any modules that your module loads dynamically here ...
            }
            );
    }
}
</code></pre><p>记得要在插件文件夹下新建Shaders文件夹，否则编译会报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20201230193701738.png" alt="image-20201230193701738"></p>
<p>创建一个最简单的usf文件</p>
<pre><code>return Col;
</code></pre><p>非常完美</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20201230201139323.png" alt="image-20201230201139323"></p>
<h2 id="RayMarch"><a href="#RayMarch" class="headerlink" title="RayMarch"></a>RayMarch</h2><p>RayMarch主要分为3个步骤，<strong>构建距离场</strong>，<strong>渲染距离场</strong>，<strong>SDF渲染</strong>。RayMarch主要通过摄像机发出屏幕射线根据与物体的距离进行渲染，适合制作云等需要大量顶点构建的物体。</p>
<h3 id="构建距离场"><a href="#构建距离场" class="headerlink" title="构建距离场"></a>构建距离场</h3><p>构建一个简单的球体距离场，return回一个正值则表面pos在球体外面，返回一个负值则证明在球体的里面</p>
<pre><code>    //构建球体距离场
    float sphere(float3 pos, float3 sphereCenter, float sphereRadius)
    {
        return distance(pos, sphereCenter) - sphereRadius;
    }
</code></pre><p>其次场景中可能有多个不同物体的距离场，所以我们需要SceneSDF来统一管理距离场</p>
<pre><code>    //将多个距离场合并，操作
    float sceneSDF(float3 pos)
    {
        float sphere_1 = sphere(pos, float3(0.0f, 0.0f, 0.0f), 100.0f);
        float sphere_2 = sphere(pos, float3(100.0f, 0.0f, 0.0f), 50.0f);
        return min(sphere_1,sphere_2);

    }
</code></pre><h3 id="距离场渲染"><a href="#距离场渲染" class="headerlink" title="距离场渲染"></a>距离场渲染</h3><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102141752621.png" alt="image-20210102141752621"></p>
<p>首先我们需要摄像机位置，射线方向，最大步长数，最大距离，通过屏幕射线与物体求交得到场景的距离场</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/v2-5b11047910c82cbd4ea73eeb08500c5c_b.webp" alt="img"></p>
<pre><code>//屏幕射线与物体表面求交
    float2 RayMarch(float3 cameraPos, float3 direction, float MAX_Step, float MAX_Distance)
    {
        float d0 = 0.0f; //SDF值
        int hit = 0; //用于判断是否撞击成功

        for (int i = 0; i &lt; MAX_Step; i++)
        {
            float3 pos = cameraPos + direction * d0; //更新当前发出射线之后的位置
            float distance = sceneSDF(pos); //检测当前pos与场景的距离值

            d0 += distance; //累计SDF

        //当距离值足够小的时候，就可以认为射线撞击到了物体
            if (distance &lt; 0.1f)
            {
                hit = 1;
                break;
            }
        //当距离值足够大但依然没有物体存在，那就可以打断循环
            else if (distance &gt; MAX_Distance)
            {
                hit = 0;
                break;
            }

        }

    //返回SDF
        return float2(d0,hit);
    }
</code></pre><p>返回的d0就代表着摄像机各个像素到物体的距离，我们可以利用d0来进行很多操作了。</p>
<h3 id="SDF渲染"><a href="#SDF渲染" class="headerlink" title="SDF渲染"></a>SDF渲染</h3><p>物体的位置我们可以通过一下方法求得，通过摄像机pos + 屏幕射线*d0则可以得到物体的pos</p>
<pre><code>float2 d = FS.RayMarch(CameraPos,Direction,MAX_Step,MAX_Distance);
float3 pos = CameraPos + Direction * d.x;
</code></pre><p>接下来我们可以通过计算相邻xyz点的SDF差值来的到近似的法线方向</p>
<pre><code>    //计算法线
    float3 GetNormal(float3 pos)
    {
        //通过计算xyz三个方向的差值，归一化得到近似的法线方向
        float D_value = 0.001f;
        return normalize(float3(
        sceneSDF(float3(pos.x + D_value, pos.y, pos.z)) - sceneSDF(float3(pos.x - D_value, pos.y, pos.z)),
        sceneSDF(float3(pos.x, pos.y + D_value, pos.z)) - sceneSDF(float3(pos.x, pos.y - D_value, pos.z)),
        sceneSDF(float3(pos.x, pos.y, pos.z + D_value)) - sceneSDF(float3(pos.x, pos.y, pos.z - D_value))
        ));

    }
</code></pre><p>得到法线之后，我们就可以进行漫反射+高光，但是我们可以将法线方向交给UE4材质，就可以享受UE4的光照效果了</p>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102143521881.png" alt="image-20210102143521881"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>首先新建一个ush和usf文件，ush用于存放方法，<strong>注意如果需要定义多个方法，我们需要将方法都放进一个struct里面才能使用，否则会报错</strong></p>
<pre><code>#pragma once    
struct FunctionStruct
{
    //构建球体距离场
    float sphere(float3 pos, float3 sphereCenter, float sphereRadius)
    {
        return distance(pos, sphereCenter) - sphereRadius;
    }


    //将多个距离场合并，操作
    float sceneSDF(float3 pos)
    {
        float sphere_1 = sphere(pos, float3(0.0f, 0.0f, 0.0f), 100.0f);
        float sphere_2 = sphere(pos, float3(100.0f, 0.0f, 0.0f), 50.0f);
        return min(sphere_1,sphere_2);

    }

//屏幕射线与物体表面求交
    float2 RayMarch(float3 cameraPos, float3 direction, float MAX_Step, float MAX_Distance)
    {
        float d0 = 0.0f; //SDF值
        int hit = 0; //用于判断是否撞击成功

        for (int i = 0; i &lt; MAX_Step; i++)
        {
            float3 pos = cameraPos + direction * d0; //更新当前发出射线之后的位置
            float distance = sceneSDF(pos); //检测当前pos与场景的距离值

            d0 += distance; //累计SDF

        //当距离值足够小的时候，就可以认为射线撞击到了物体
            if (distance &lt; 0.1f)
            {
                hit = 1;
                break;
            }
        //当距离值足够大但依然没有物体存在，那就可以打断循环
            else if (distance &gt; MAX_Distance)
            {
                hit = 0;
                break;
            }

        }

    //返回SDF
        return float2(d0,hit);
    }

    //计算法线
    float3 GetNormal(float3 pos)
    {
        //通过计算xyz三个方向的差值，归一化得到近似的法线方向
        float D_value = 0.001f;
        return normalize(float3(
        sceneSDF(float3(pos.x + D_value, pos.y, pos.z)) - sceneSDF(float3(pos.x - D_value, pos.y, pos.z)),
        sceneSDF(float3(pos.x, pos.y + D_value, pos.z)) - sceneSDF(float3(pos.x, pos.y - D_value, pos.z)),
        sceneSDF(float3(pos.x, pos.y, pos.z + D_value)) - sceneSDF(float3(pos.x, pos.y, pos.z - D_value))
        ));

    }

    //计算光照
    float3 CalLight(float3 pos ,float3 normal)
    {
        float3 lightPos = float3(1.0f, 1.0f, 0.0f);
        float3 diffuse = dot(normal, normalize(lightPos)) / 2 + 0.5;
        return diffuse;

    }
};
</code></pre><pre><code>#include &quot;MyFirstShader.ush&quot;

FunctionStruct FS;

float2 d = FS.RayMarch(CameraPos,Direction,MAX_Step,MAX_Distance);
float3 pos = CameraPos + Direction * d.x;
float3 normal = FS.GetNormal(pos);
return float4(normal,d.y);
</code></pre><p>材质中记得要把切线空间法线取消勾选，否则会出现奇怪效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210102143853340.png" alt="image-20210102143853340"></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>知乎大佬：<a href="https://zhuanlan.zhihu.com/p/95547912" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/95547912</a></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4---雨点和水滴滑落效果笔记</title>
    <url>/2021/01/05/UE4---%E9%9B%A8%E6%BB%B4%E5%92%8C%E6%B0%B4%E6%BB%B4%E6%BB%91%E8%90%BD%E6%95%88%E6%9E%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%2021-32-16.gif" alt="GIF 2021-1-5 21-32-16"></p>
<a id="more"></a>
<h3 id="涟漪Mask制作"><a href="#涟漪Mask制作" class="headerlink" title="涟漪Mask制作"></a>涟漪Mask制作</h3><p>贴图的R通道存储的是涟漪的范围，涟漪中心为最亮，往四周渐变为黑色</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105180330662.png" alt="image-20210105180330662"></p>
<p>利用Texture.R - （1 - frac （time * 涟漪变化速度）得到沿涟漪中心往外伸展的效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105180706389.png" alt="image-20210105180706389"></p>
<p><img src="https://deepspacebanana.github.io/deepspacebanana.github.io//assets/img/blog/post08_img/nodes_01_vis.gif" alt="img"></p>
<p>利用同样的Distance获取涟漪的边缘，并缩放到0-1，最后取反</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105180806279.png" alt="image-20210105180806279"></p>
<p>可以看到，涟漪的而结束很生硬，没有淡入淡出</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%2018-09-32.gif" alt="GIF 2021-1-5 18-09-32"></p>
<p>利用数学运算创造一个过度平缓的函数周期，实现淡入淡出效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105181434294.png" alt="image-20210105181434294"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105181531663.png" alt="image-20210105181531663"></p>
<p>最后要解决的就是涟漪的连续问题，同样解决的方法与Flowmap相同，创建两个涟漪动画，一个涟漪动画偏移一段时间，然后用Lerp函数将两端动画进行融合</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105183831136.png" alt="image-20210105183831136"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105183843705.png" alt="image-20210105183843705"></p>
<p>就是重复感有点强烈</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%2018-45-17.gif" alt="GIF 2021-1-5 18-45-17"></p>
<h3 id="各种混合"><a href="#各种混合" class="headerlink" title="各种混合"></a>各种混合</h3><p>得到涟漪Mask之后一切就好做很多了，接下来就是各种属性混合</p>
<p>涟漪法线Lerp的Alpha用的是Mask动画融合的Alpha，与输入法线混合用的是涟漪Mask</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105184733930.png" alt="image-20210105184733930"></p>
<p>基础颜色混合，输入的基础颜色与水颜色，水亮度相乘得到的就是水涟漪颜色，大多数金属材质在潮湿的情况下回变暗，所以下面的基础颜色根据金属度进行一定的Lerp操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105184948291.png" alt="image-20210105184948291"></p>
<p>金属度和粗糙度混合</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105185326642.png" alt="image-20210105185326642"></p>
<h3 id="最终涟漪"><a href="#最终涟漪" class="headerlink" title="最终涟漪"></a>最终涟漪</h3><p>这里我随便找了一个UE4自带金属材质连接MF_RainSurface进行测试</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105185553502.png" alt="image-20210105185553502"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%2018-56-30.gif" alt="GIF 2021-1-5 18-56-30"></p>
<h3 id="水滴滑落材质"><a href="#水滴滑落材质" class="headerlink" title="水滴滑落材质"></a>水滴滑落材质</h3><p>水滴滑落大多数会出现倾斜的情况，以正方体为例，雨水从上方落下，那么滑落情况只会出现在侧面</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105200534777.png" alt="image-20210105200534777"></p>
<p>我们从这个方面开始入手，用世界空间位置作为水滴滑落纹理的采样UV，由于只是需要侧面进行正确的采样，所以我们只需要在xz平面和yz平面进行贴图采样，根据顶点法线的X轴Mask进行lerp操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105201116876.png" alt="image-20210105201116876"></p>
<p>得到效果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105201142251.png" alt="image-20210105201142251"></p>
<p>法线也用同样的UV去采样，同样的Alpha去Lerp</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105210347108.png" alt="image-20210105210347108"></p>
<p>同样我们需要采样贴图的B通道，得到的是向下移动块状的渐变图</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105210948360.png" alt="image-20210105210948360"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105211030445.png" alt="image-20210105211030445"></p>
<p>我们将从G通道获取的水滴图减去B通道得到的块状渐变图，可以形成水滴滑落的错觉</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105211349933.png" alt="image-20210105211349933"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%2021-14-59.gif" alt="GIF 2021-1-5 21-14-59"></p>
<p>将水滴法线与正常的法线方向根据水滴滑落Mask进行混合（0.5,0.5,1），才能得到正确的法线</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105211605556.png" alt="image-20210105211605556"></p>
<h3 id="水滴滑落效果和涟漪结合"><a href="#水滴滑落效果和涟漪结合" class="headerlink" title="水滴滑落效果和涟漪结合"></a>水滴滑落效果和涟漪结合</h3><p>首先要获取永远朝上的Mask贴图，其实就是将法线方向从切线空间切换到世界空间，只获取B通道</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105211951450.png" alt="image-20210105211951450"></p>
<p>后面与1.1相乘是为减弱水滴拉伸的出现，可以看到当平面轻微倾斜的时候，会出现水平拉伸的情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105212902536.png" alt="image-20210105212902536"></p>
<p>得到Z轴Mask贴图之后，将涟漪和水滴滑落Mask做最后的混合</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105213026999.png" alt="image-20210105213026999"></p>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%2021-32-16.gif" alt="GIF 2021-1-5 21-32-16"></p>
<p>全家福</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105213337560.png" alt="image-20210105213337560"></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4---科幻扫描线效果笔记</title>
    <url>/2021/01/05/UE4---%E7%A7%91%E5%B9%BB%E6%89%AB%E6%8F%8F%E7%BA%BF%E6%95%88%E6%9E%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%2014-44-25.gif" alt="GIF 2021-1-5 14-44-25"></p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>根据Z轴生成0-1Mask贴图</li>
<li>控制顶部顶点的世界位置偏移</li>
<li>抖动效果</li>
<li>屏幕空间条</li>
<li>菲涅尔和CameraFade</li>
<li>输入不透明度</li>
</ol>
<h3 id="根据Z轴生成0-1Mask贴图"><a href="#根据Z轴生成0-1Mask贴图" class="headerlink" title="根据Z轴生成0-1Mask贴图"></a>根据Z轴生成0-1Mask贴图</h3><p>将世界空间坐标转换为模型空间，只取Z通道，QbjectBounds返回的是模型的边界，我们除以Z通道就可以得到模型从底部到顶点0-1的Mask遮罩</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105011904542.png" alt="image-20210105011904542"></p>
<p>预览Divide</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105012049880.png" alt="image-20210105012049880"></p>
<h3 id="控制顶部顶点的世界位置偏移"><a href="#控制顶部顶点的世界位置偏移" class="headerlink" title="控制顶部顶点的世界位置偏移"></a>控制顶部顶点的世界位置偏移</h3><p>生成的Z轴Mask遮罩是用于控制WorldPositionOffset</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105012235486.png" alt="image-20210105012235486"></p>
<p>同样将顶点的世界空间Pos转换到模型空间，并将位置进行归一化，只取RG通道，这个RG通道其实就是顶点在XY平面移动的方向</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105012625863.png" alt="image-20210105012625863"></p>
<p>那么Z通道自然用于是Z轴方向上的移动</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105012739210.png" alt="image-20210105012739210"></p>
<p>通过在这两个方向上的位移，我们可以实现模型的压缩（激活全息）和顶部扩大（缩放半径），当激活全息为0时是压扁状态，为1则是全息状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%201-30-38.gif" alt="GIF 2021-1-5 1-30-38"></p>
<h3 id="抖动效果"><a href="#抖动效果" class="headerlink" title="抖动效果"></a>抖动效果</h3><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105014109050.png" alt="image-20210105014109050"></p>
<p>通过ScreenPosition的屏幕UV将V轴缩放到0-100，再Floor，分成100个不同的矩形区域，这里为了方便展示，我设置为0-10区间，再缩放回0-1区间，可以看到整个屏幕给分成了若干个矩形区域，并不是根据模型来切分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%201-38-52.gif" alt="GIF 2021-1-5 1-38-52"></p>
<p>我们继续连接MF_FloatNoise节点，这个节点使用传入Noise种子和一个2D向量输出一个随机值，材质函数如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105014231451.png" alt="image-20210105014231451"></p>
<p>得到一直在随机变化的矩形条    </p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%201-43-22.gif" alt="GIF 2021-1-5 1-43-22"></p>
<p>控制抖动用于开关抖动效果，为0开启，为1关闭，在世界空间上进行一定的抖动偏移</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105014556245.png" alt="image-20210105014556245"></p>
<p>结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%201-47-16.gif" alt="GIF 2021-1-5 1-47-16"></p>
<h3 id="屏幕空间条"><a href="#屏幕空间条" class="headerlink" title="屏幕空间条"></a>屏幕空间条</h3><p>同样是利用ScreenPosition的UV进行操作，但是上面可以看到，随着摄像机的距离，映射在模型上面的UV区域是不会变化的，一直是以屏幕为标准。</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105015229996.png" alt="image-20210105015229996"></p>
<p>这样根据摄像机与物体的距离来决定生成的UV条的数量，符合了我们的要求</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-5%201-54-08.gif" alt="GIF 2021-1-5 1-54-08"></p>
<h3 id="菲涅尔和CameraFade"><a href="#菲涅尔和CameraFade" class="headerlink" title="菲涅尔和CameraFade"></a>菲涅尔和CameraFade</h3><p>菲涅尔用于边缘的透明，CameraFade用于靠近Mesh时透明</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105143118294.png" alt="image-20210105143118294"></p>
<h3 id="输入不透明度"><a href="#输入不透明度" class="headerlink" title="输入不透明度"></a>输入不透明度</h3><p>将基于屏幕空间的空间条与菲涅尔，CameraFade，激活全息进行相结合，输入不透明度</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105143446247.png" alt="image-20210105143446247"></p>
<h3 id="用于网格的Scifi材质"><a href="#用于网格的Scifi材质" class="headerlink" title="用于网格的Scifi材质"></a>用于网格的Scifi材质</h3><p>网格的Scifi材质只要修改抖动，以及输入的不透明度，删除CameraFade即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105144134572.png" alt="image-20210105144134572"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210105144144952.png" alt="image-20210105144144952"></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4--材质大师课程笔记</title>
    <url>/2020/01/11/UE4--%E6%9D%90%E8%B4%A8%E5%A4%A7%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="压缩和内存"><a href="#压缩和内存" class="headerlink" title="压缩和内存"></a>压缩和内存</h2><p>一般来说纹理导入UE4都是经过压缩的，压缩方式有BC(Block Compression块压缩)/DXTC(Directx Texture Compression DirectX纹理压缩)两种，其实都是用于PC的Directx平台的格式。但是法线贴图有点特殊，是无法通过这两种方式进行压缩的。</p>
<a id="more"></a>
<p>​    如下图所示就是贴图导入UE4后所选择的压缩方式。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/压缩方式.png" alt></p>
<p>压缩方式后面所带的数字表明是不同的压缩格式，例如BC3(DXTC5)表示带透明度的纹理，BC1(DXTC1)表示不带透明度的纹理。</p>
<p>法线贴图的压缩方式是通过剔除蓝色通道的方式进行压缩，这样可以存储更多的数据，同时对红色和绿色通道进行轻度压缩。最后通过对红绿色进行蓝色通道的复原，这些都是UE4内部自己调用的，不用我们去调整。如下图只是进行蓝色通道复原的演示。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/法线贴图.png" alt></p>
<p>注意的是，法线贴图的导入方式必须是选择NormalMap。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/法线贴图压缩方式.png" alt></p>
<h3 id="为什么要对纹理进行压缩"><a href="#为什么要对纹理进行压缩" class="headerlink" title="为什么要对纹理进行压缩"></a>为什么要对纹理进行压缩</h3><p>最主要是因为受限于内存和带宽，如果不对纹理进行压缩，可能导致卡顿。但帧率过低一般和纹理压缩没有什么关系。可以通过查看统计数据，来查看场景中哪些纹理在内存中的大小。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/统计数据.png" alt></p>
<h2 id="多级渐进纹理-纹理尺寸和纹理池"><a href="#多级渐进纹理-纹理尺寸和纹理池" class="headerlink" title="多级渐进纹理 纹理尺寸和纹理池"></a>多级渐进纹理 纹理尺寸和纹理池</h2><h3 id="纹理池"><a href="#纹理池" class="headerlink" title="纹理池"></a>纹理池</h3><p>UE4在计算机内存中，会为纹理暴保留一定的空间，这个空间就是纹理池，我们可以手动调整纹理池的大小，当纹理池大小不够用的时候，会导致贴图的分辨率降低，效果下降。</p>
<p>打开控制台，输入r.Streaming.PoolSize查看纹理池大小，并且可以进行修改。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/调整纹理池.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/过小纹理池.png" alt></p>
<h3 id="Mipmaps-多级渐进纹理"><a href="#Mipmaps-多级渐进纹理" class="headerlink" title="Mipmaps(多级渐进纹理)"></a>Mipmaps(多级渐进纹理)</h3><p>Mipmaps为原始纹理的副本，大小为1/4左右,使用Mipmaps的原因是为了减少噪点的生成。</p>
<p>左侧是使用了Mipmaps，右边没有使用，可以看出右边的噪点非常多，所以Mipmaps可以看成我们手动进行模糊</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Mipmaps.png" alt></p>
<p>UE4会对远处使用不同的Mipmaps来模拟模糊的效果，如下图离镜头最近的就使用Mipmaps0原始纹理，然后随着离镜头越来越远，使用不同的Mipmaps。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/MipmapsLerp.png" alt></p>
<p>可以在贴图的LOD选择中进行Mipmaps的设置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Mipmaps设置.png" alt></p>
<h4 id="注意纹理尺寸"><a href="#注意纹理尺寸" class="headerlink" title="注意纹理尺寸"></a>注意纹理尺寸</h4><p>使用Mipmaps可以提高我们的性能，加快渲染速度和减少纹理锯齿，但注意不适于2的幂数的纹理无法生成Mipmaps，但是UI纹理可以是任意分辨率，因为UI纹理不会从远处到近处，所以没必要使用Mipmaps。</p>
<h3 id="材质的纹理数限制"><a href="#材质的纹理数限制" class="headerlink" title="材质的纹理数限制"></a>材质的纹理数限制</h3><p>UE4的每个材质的纹理可采样数是16个，加上内部的光影贴图，其实我们可以用的大概是13个左右，其实已经够用了，但是如果要突破这个限制的话，我们可以把不同的贴图合成RGB通道就成为一张贴图，到使用的的时候就可以分RGB通道分为3张贴图。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/贴图合成.png" alt></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4学习笔记(1)——简单框架</title>
    <url>/2019/11/06/UE4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>纪录自己的UE4学习之路</p>
 <a id="more"></a> 
<h1 id="UE4的简单框架"><a href="#UE4的简单框架" class="headerlink" title="UE4的简单框架"></a>UE4的简单框架</h1><blockquote>
<p> UE创世，万物皆UObject，接着有Actor 。</p>
</blockquote>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/1.png" alt="继承关系"> </p>
<h2 id="Uobject"><a href="#Uobject" class="headerlink" title="Uobject"></a>Uobject</h2><p>Uobject是UE4中最基础的类，具有 元数据、反射生成、GC垃圾回收、序列化、编辑器可见，Class Default Object等功能。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/2.png" alt> </p>
<h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><p>Actor是UE4中最基本的场景元素，与Unity3D的gameobject相似，本身是一个容器，但是与unity不同的是，Actor没有任何可视化属性，甚至连位置属性也没有。但是也是与Unity相似，可以挂在多个可视化的组件( Component)，以达到各种功能，Actor也可以有子Actor。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/3.png" alt></p>
<p>Actor继承至Uobject，多了 Replication（网络复制）,Spawn（生生死死），Tick(有了心跳)等功能。</p>
<h2 id="组件-Component"><a href="#组件-Component" class="headerlink" title="组件(Component)"></a>组件(Component)</h2><p>组件挂在Actor身上发挥功能，例如位置组件，Actor的最终位置来至于他的根组件。组件也可以有根组件。</p>
<h2 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h2><p>Pawn是可以被控制的物体，相当于有controller的大脑，他可以是交通工具，鱼等，可以默认为生物的基类。</p>
<h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><p>Character是人形的Actor，继承于Pawn， 默认拥有一个用于碰撞的胶囊体组件(CapsuleComponent)和运动相关的组件(CharacterMoveMentComponent)，并具有一些动画相关的功能。可以认为是人性动物的基类。 </p>
<h2 id="控制器-Controller"><a href="#控制器-Controller" class="headerlink" title="控制器(Controller)"></a>控制器(Controller)</h2><p>控制器用于控制Pawn的行为， 一般分为AIController和PlayerController。控制器也是从Actor派生的，因此也可以加入到场景中。 </p>
<h3 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h3><p> 玩家控制器。是Pawn和控制其的玩家之间的桥梁，PlayerController代表了人类玩家的意愿。 </p>
<h3 id="AIController"><a href="#AIController" class="headerlink" title="AIController"></a>AIController</h3><p> 用于控制NPC的控制器，决定了NPC如何与玩家互动。 </p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><h3 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h3><p>UI, 显示玩家的名字，血条，得分等信息。 </p>
<h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><p> 每个PlayerConroller都有一个PlayerCameraManager，代表了玩家的视角。 </p>
<h2 id="游戏规则和状态"><a href="#游戏规则和状态" class="headerlink" title="游戏规则和状态"></a>游戏规则和状态</h2><h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><p> 游戏模式。处理游戏的规则，只存在与服务器端，因此客户端相关的逻辑不能存放在GameMode中。 </p>
<h3 id="GameState"><a href="#GameState" class="headerlink" title="GameState"></a>GameState</h3><p>游戏状态， 记录游戏的数据，比如当前游戏的进度，世界任务的完成状态等，会自动同步到各个客户端。 </p>
<h3 id="PlayerState"><a href="#PlayerState" class="headerlink" title="PlayerState"></a>PlayerState</h3><p> 玩家状态。记录玩家个人的数据，比如名字分数等，会自动同步到各个客户端。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>GamePlay框架使用了MVC架构，其中Pawn是视图，PlayerState是数据模型，PlayerController是控制器。</p>
<p>一个游戏由游戏规则(GameMode)和游戏状态组成(GameState)；玩家在游戏里的化身是Pawn，玩家通过PlayerConroller控制着自己的化身，通过PlayerCameraManager观察世界，PlayerState记录了玩家的数据，HUD显示了这些状态；NPC则由AIConroller去控制，与玩家进行互动。 </p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/GameFramework.jpg" alt="GameFramework"></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4学习笔记(2)---蓝图接口-标签</title>
    <url>/2019/11/13/UE4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)---%E8%93%9D%E5%9B%BE%E6%8E%A5%E5%8F%A3-%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="蓝图接口"><a href="#蓝图接口" class="headerlink" title="蓝图接口"></a>蓝图接口</h1><p> <strong>蓝图接口（Blueprint Interface）</strong> 是一个或多个函数的集合 - 只有名称，没有实现。可以添加到其他蓝图中。任何添加了该接口的蓝图都保证拥有这些函数。接口的函数 可以在添加它的每个蓝图中提供功能。在本质上，这类似于一般编程中的接口概念， 它允许多个不同类型的对象通过一个公共接口 共享和被访问。简单地说，蓝图接口允许不同的蓝图相互共享和发送数据。 </p>
<a id="more"></a>
<h2 id="创建蓝图接口"><a href="#创建蓝图接口" class="headerlink" title="创建蓝图接口"></a>创建蓝图接口</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/1.png" alt></p>
<p>新建函数和函数的输入输出值</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/2.png" alt></p>
<p>要使用蓝图接口，就必须继承该接口，并且实现。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/3.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/4.png" alt></p>
<p>实现接口之后，其他蓝图类就可以调用此方法，实现了蓝图之间的通信。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/5.png" alt></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>在调用蓝图接口方法前，先使用标签来判断是敌人还是友军，其实我感觉UE4的标签和Unity的标签还是挺相似的</p>
<h3 id="标签的设置方法"><a href="#标签的设置方法" class="headerlink" title="标签的设置方法"></a>标签的设置方法</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/6.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/7.png" alt></p>
<h2 id="调用蓝图接口方法"><a href="#调用蓝图接口方法" class="headerlink" title="调用蓝图接口方法"></a>调用蓝图接口方法</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/8.png" alt></p>
<p>就这样完成了蓝图接口的调用</p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4材质大师课程笔记(二)---RenderTarget</title>
    <url>/2020/02/19/UE4%E6%9D%90%E8%B4%A8%E5%A4%A7%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0(%E4%BA%8C)---RenderTarget/</url>
    <content><![CDATA[<h1 id="RenderTarget"><a href="#RenderTarget" class="headerlink" title="RenderTarget"></a>RenderTarget</h1><p>UE4的RenderTarget感觉和Unity的差不多，都是获得一个摄像机的渲染结果，然后存在RenderTarget里面进行读取使用。</p>
<a id="more"></a>
<p>在UE4中要使用RenderTarget，首先要添加SceneCapture2D组件或者SceneCapture Cube组件，前者获取2D，后者获取Cube立方体贴图。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget组件.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget新建RenderTarget.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget赋值RenderTarget.png" alt></p>
<h2 id="RenderTarget的使用"><a href="#RenderTarget的使用" class="headerlink" title="RenderTarget的使用"></a>RenderTarget的使用</h2><h3 id="渲染材质"><a href="#渲染材质" class="headerlink" title="渲染材质"></a>渲染材质</h3><p>在UE4中过程化生成噪点纹理是比较昂贵的，所以通常的做法是将材质绘制到RenderTarget中。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetNoise.png"></p>
<p>可以看出以上这个需要529条指令<img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetNoise指令.png" alt></p>
<p>将材质绘制到RenderTarget</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget将材质渲染到RenderTarget.png" alt></p>
<p>得到左边的RenderTarget噪点图了，然后右键创建静态纹理则可以得到可以用的Texture纹理了。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200109210329543.png" alt></p>
<p>指令就变为了34，效率得到了提升。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200109210452008.png" alt></p>
<h3 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h3><h4 id="高度图"><a href="#高度图" class="headerlink" title="高度图"></a>高度图</h4><p>效果如下，随着鼠标左键的按下，在平面生成不同的高度。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110182834948.png" alt></p>
<p>1.首先我们要创建MAT_HeightfieldPainter材质，设置如下，注意要把shading Model改为Unlit无光照模式。这个材质主要用于控制物体在Z轴的世界偏移。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110183116238.png" alt></p>
<p>2.创建MAT_ForceSplat材质，设置如下，主要用于处理鼠标点击平面所产生的uv坐标，通过下面的计算获得一个关于这个uv坐标为圆心的渐变圆形贴图</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110183515861.png" alt></p>
<p>3.新建一个HeightFieldPainter的Actor蓝图，设置如下</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110200935951.png" alt></p>
<p>然后在构造函数里面进行动态材质的设置，这里主要针对我们上面的材质创建动态材质。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110201017886.png" alt></p>
<p>新建TraceFromCamera函数，函数用于从摄像头方向射出射线，进行射线检测，如果检测到碰撞物体，就进行伤害传递。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110204023291.png" alt></p>
<p>Begin函数，首先我们要为新建一个RenderTexture并保存，同时将RT传递给Z轴偏移的MAT_HeightfieldPainter材质。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110204531617.png" alt></p>
<p>最后处理伤害函数，传递参数给MAT_ForceSplat材质，例如点击的uv坐标，力度，大小，最后要用Draw Material to Render Target函数将材质绘制到RT里面，这样HeighfieldPainter材质才会根据RT图进行Z轴的偏移。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110204555551.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget将材质渲染到RenderTarget.png" alt></p>
<p>这里注意，这种方法只适用于平面，计算点击位置的uv坐标也比较简单，首先获取点击位置的世界坐标，然后获取静态网格的worldTransform,然后通过Invert Transform获得从世界坐标到静态网格本地坐标的变换矩阵，将点击位置从世界空间转换为静态网格的本地空间，当然我们也要将得到的本地坐标转为uv坐标，就要除于网格的长宽，映射到【0，1】，这样就得到了正确的uv坐标。</p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4还原CRT像素效果笔记</title>
    <url>/2021/01/03/UE4%E8%BF%98%E5%8E%9FCRT%E5%83%8F%E7%B4%A0%E6%95%88%E6%9E%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210104003141990.png" alt="image-20210104003141990"></p>
<a id="more"></a>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s/DbEbPRdmo_uaITfLROJAUg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DbEbPRdmo_uaITfLROJAUg</a></p>
<h2 id="效果分解"><a href="#效果分解" class="headerlink" title="效果分解"></a>效果分解</h2><p>远看像素化，近看充满着像素点，画面不断抖动，有不断从上到下的刷新</p>
<h3 id="图片像素化"><a href="#图片像素化" class="headerlink" title="图片像素化"></a>图片像素化</h3><p>首先UV0-1区间是会和图像相对应的，图像的每个像素都会有相对应的UV区间</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103183503865.png" alt="image-20210103183503865"></p>
<p>比如512X512的一张贴图，左上角第一个像素对应的UV区间是0-0.00195（1/512）</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103183556380.png" alt="image-20210103183556380"></p>
<p>所以像素化的方法只要我们将UV划分为若干个举行区域，那么每个区域都会填充相同颜色</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103183833564.png" alt="image-20210103183833564"></p>
<p>可以看到被划分了16X16个区域</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103183807712.png" alt="image-20210103183807712"></p>
<p>这样像素化就完成了</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103183948978.png" alt="image-20210103183948978"></p>
<h3 id="像素点"><a href="#像素点" class="headerlink" title="像素点"></a>像素点</h3><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/640" alt="图片"></p>
<p>利用frac节点将UV分成多个0-1不断重复地块</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103201346595.png" alt="image-20210103201346595"></p>
<p>与像素化结果相结合</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103201424096.png" alt="image-20210103201424096"></p>
<p>将以上功能进行打包成一个材质函数MF_Pixel</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103205748466.png" alt="image-20210103205748466"></p>
<p>方便重复利用</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103202000689.png" alt="image-20210103202000689"></p>
<h3 id="像素隔行错位"><a href="#像素隔行错位" class="headerlink" title="像素隔行错位"></a>像素隔行错位</h3><p>主要思路：准备两套UV，一套UV不偏移，一套UV偏移一定距离，然后隔行进行切换</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103205101024.png" alt="image-20210103205101024"></p>
<p>假设我们像素分辨率为8，那么我们UV相乘之后会扩充到0-8区间，我们用Mask将G通道取出来会得到下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103204309087.png" alt="image-20210103204309087"></p>
<p>再连接Sine，你会发现了总行数会变成16行，这是因为UE4中sine节点输入1就代表输入2Pi，一个循环，所以我们0-1区间就变成了两行，一黑一白，原本8个区间，所以总行数变成16行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103204812013.png" alt="image-20210103204812013"></p>
<p>这与我们的像素分辨率不符，所以我们必须除以2，得到正确的行数Mask图</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103205212938.png" alt="image-20210103205212938"></p>
<p>没有加上像素细节的效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103210525134.png" alt="image-20210103210525134"></p>
<h3 id="像素化效果切换"><a href="#像素化效果切换" class="headerlink" title="像素化效果切换"></a>像素化效果切换</h3><p>如果我们将视角拉的足够远，那么将会出现严重的摩尔纹</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103211914605.png" alt="image-20210103211914605"></p>
<p>所以我们将使用SphereMask根据摄像机的距离进行像素化和像素素材的效果切换</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103212040780.png" alt="image-20210103212040780"></p>
<h3 id="色条，明度，抖动"><a href="#色条，明度，抖动" class="headerlink" title="色条，明度，抖动"></a>色条，明度，抖动</h3><p>色条主要混合了不同速度和比例的UV，最终将输出rgb色条与原图进行Mul</p>
<p>明度也靠色条的UV与原图相加</p>
<p>抖动将混合了不同速度比例的UV与像素化UV直接Add</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>这gif录制好像有点问题，忽略红点就好了</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/GIF%202021-1-4%200-29-55.gif" alt="GIF 2021-1-4 0-29-55"></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity VEG实现烟花效果</title>
    <url>/2019/11/01/Unity-VEG%E5%AE%9E%E7%8E%B0%E7%83%9F%E8%8A%B1%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次利用VEG实现普通烟花效果。</p>
 <a id="more"></a> 
<h2 id="主粒子"><a href="#主粒子" class="headerlink" title="主粒子"></a>主粒子</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/1.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/2.png" alt></p>
<p>设置主粒子的速度，位置，周期等参数。</p>
<h3 id="Position-Line"><a href="#Position-Line" class="headerlink" title="Position(Line)"></a>Position(Line)</h3><p>用于设置粒子的初始化位置，从Start到End随机生成一个位置点。</p>
<h2 id="烟花粒子"><a href="#烟花粒子" class="headerlink" title="烟花粒子"></a>烟花粒子</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/3.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/4.png" alt></p>
<p>这里利用GPU Event当主粒子消亡时生成新的眼花粒子。</p>
<h3 id="GPU-Event"><a href="#GPU-Event" class="headerlink" title="GPU Event"></a>GPU Event</h3><p> GPU事件由系统在特定条件下触发，并且可以被其他系统捕获以生成新粒子。 可以通过读取Source或使用Inherit Source节点在子系统中访问事件数据。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/5.png" alt></p>
<h2 id="主粒子的拖尾粒子"><a href="#主粒子的拖尾粒子" class="headerlink" title="主粒子的拖尾粒子"></a>主粒子的拖尾粒子</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/6.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/7.png" alt></p>
<h2 id="烟花粒子的拖尾"><a href="#烟花粒子的拖尾" class="headerlink" title="烟花粒子的拖尾"></a>烟花粒子的拖尾</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/8.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/9.png" alt></p>
<p>就这样我们的烟花就完成啦</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/10.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/11.png" alt></p>
<p>现在看起来还是有点难看的，但问题不大，给它加点后处理就好了，PostProcessVolume</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/12.png" alt></p>
<p>就这样，好看多了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/13.png" alt></p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>可能后面还想加点其他的功能，所以未完待续。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4高斯模糊后处理</title>
    <url>/2021/01/03/UE4%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E5%90%8E%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103163949472.png" alt="image-20210103163949472"></p>
<a id="more"></a>
<h2 id="去饱和测试"><a href="#去饱和测试" class="headerlink" title="去饱和测试"></a>去饱和测试</h2><pre><code>return dot(SceneTexture,float3(0.3,0.59,0.11));
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103150452328.png" alt="image-20210103150452328"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103150502447.png" alt="image-20210103150502447"></p>
<h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>首先我们需要将SceneTexture节点转换为HLSL，为了方便我们后续的操作，查看着色器代码可以看到HLSL代码</p>
<pre><code>SceneTextureLookup(GetDefaultSceneTextureUV(Parameters, 14), 14, false);
</code></pre><h3 id="SceneTextureLookup"><a href="#SceneTextureLookup" class="headerlink" title="SceneTextureLookup"></a>SceneTextureLookup</h3><pre><code>float4 SceneTextureLookup(float2 UV, int SceneTextureIndex, bool Filtered)
</code></pre><p>uv:采样UV</p>
<p>SceneTextureIndex:要采样的贴图Index</p>
<p>Filtered:是否需要双线性过滤</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/unreal-engine-shaders-10.jpg" alt="虚幻引擎着色器"></p>
<p>这时候如果我们直接断开SceneTexture，并修改Gaussain.usf中修改为</p>
<pre><code>return SceneTextureLookup(GetDefaultSceneTextureUV(Parameters, 8), 8, false);
</code></pre><p>报错了，是因为SceneTextureLookup需要引入头文件才能使用，所以我们需要连接SceneTexture用于引入头文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103153204226.png" alt="image-20210103153204226"></p>
<p>恢复正常</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103153345798.png" alt="image-20210103153345798"></p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>首先确定好高斯模糊公式，接受-1到1的输入，输出0到1的值。可以看出和平均模糊不同，距离当前像素越远，那么对中心的越小</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/gif.latex" alt="\LARGE f(x) = e^{-0.5(\pi x)^{2}"></p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103162825939.png" alt="image-20210103162825939"></p>
<pre><code>struct FunctionStruct
{
    //计算一维高斯模糊
    float Cal_1DGaussian(float x)
    {
        return exp(-0.5f * pow(3.141 * x, 2));
    }
};
</code></pre><p>初始化数据</p>
<pre><code>FunctionStruct FS;

//需要获得的场景贴图index
static const int SceneTextureID = 14;
//纹素大小，比如一张512 X 512大小的纹理，那么纹素大小为（1/512）
//用于UV的偏移
float2 TexelSize = View.ViewSizeAndInvSize.zw;
//获取当前像素的UV
float2 UV = GetDefaultSceneTextureUV(Parameters, SceneTextureID);
//用于存储累积的颜色
float3 PixelSum = float3(0, 0, 0);
//累积权重值
float WeightSum = 0;
</code></pre><p>用两个for循环来进行水平和垂直的模糊处理</p>
<pre><code>//水平与垂直模糊
for (int x = -BlurRadius;x&lt;=BlurRadius;x++)
{
    for (int y = -BlurRadius;y&lt;=BlurRadius;y++)
    {
        //计算偏移的UV
        float2 offsetUV = UV + float2(x,y)*TexelSize;
        //采样偏移后的贴图颜色
        float3 PixelColor = SceneTextureLookup(offsetUV,SceneTextureID,false).rgb;
        //计算采样像素的权重，/Raduis的原因是为了限制输入范围为-1到1
        float weight = FS.Cal_1DGaussian(x / BlurRadius) * FS.Cal_1DGaussian(y / BlurRadius);
        //累加颜色
        PixelSum += PixelColor*weight;
        //累加权重值
        WeightSum += weight;
    }
}

//返回加权平均值
return PixelSum / WeightSum;
</code></pre><p>蓝图传递BlurRadius，其实就是卷积核大小范围，比如传入了BlurRadius为2，那么卷积核大小为5x5。</p>
<p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103163620243.png" alt="image-20210103163620243"></p>
<h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><p><img src="https://cdn.jsdelivr.net/gh/opda777/opdaBlogImage/image/image-20210103163705080.png" alt="image-20210103163705080"></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>Win32入门笔记(一)</title>
    <url>/2020/12/15/Win32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201215100931578.png" alt="image-20201215100931578" style="zoom:50%;"></p>
<a id="more"></a>
<h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><p>首先win32窗口的创建主要分为两个步骤，注册一个窗口类<strong>（注意窗口类并不是C++类，只是一个Window的数据结构）</strong>，实现一个窗口实例。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201214144740309.png" alt="image-20201214144740309"></p>
<p>WinMain entry point入口函数</p>
<p>CALLBACK 修饰符告诉编译器如何调用这个函数 ，stdcall</p>
<p>hInstance 实例的句柄</p>
<p>hPrevInstance 没有任何意义？</p>
<p>pCmdLine 命令行参数</p>
<p>nCmdShow 用于设置窗口被创建之后应该如何展示</p>
<pre><code>INT CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PSTR pCmdLine, INT nCmdShow)
{
    return 0;
}
</code></pre><p>在注册窗口类之前，我们需要填充WNDCLASSEX结构</p>
<p>cbsize：wc数据接口的大小</p>
<p>style：窗口风格，CS_OWNDC意思为每个窗口都可以独立渲染，多用于同时绘制多个窗口</p>
<p>lpfnWndProc：指向WINPROC函数的指针，这个函数处理所有有关这个窗口的信息，这个函数非常重要，因为窗口信息决定了窗口的行为，同时决定了窗口的样式，毕竟里面有Draw功能绘制窗口</p>
<p>cbClsExtra：可用来存储数据</p>
<p>cbWndExtra：用于为每个窗口实例分配字节</p>
<p>hIcon：定义应用程序图标</p>
<p>hIconsm：定义窗口标题栏图标</p>
<p>hCursor：定义鼠标</p>
<p>hbrBackground：定义背景，由于我们绘制由DirectX来执行，所以这里不需要背景</p>
<p>lpszMenuName：菜单名称</p>
<p>lpszClassName：窗口类名称，我定义为 Opda Window Class</p>
<p>设置好属性之后就可以进行注册窗口类了。</p>
<pre><code>    // 注册窗口类

    WNDCLASSEX wc = {};

    // 窗口类名
    const wchar_t CLASS_NAME[] = L&quot;Opda Window Class&quot;;

    // 设置属性
    wc.cbSize = sizeof(wc);
    wc.style = CS_OWNDC;
    wc.lpfnWndProc = DefWindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = nullptr;
    wc.hIconSm = nullptr;
    wc.hCursor = nullptr;
    wc.hbrBackground = nullptr;
    wc.lpszMenuName = nullptr;
    wc.lpszClassName = CLASS_NAME;

    RegisterClassEx(&amp;wc);
</code></pre><p>接下来我们需要创建窗口实例</p>
<pre><code>    //创建窗口实例
    HWND hwnd = CreateWindowEx(
        0, CLASS_NAME, L&quot;Hello World&quot;,
        WS_CAPTION | WS_MINIMIZEBOX | WS_SYSMENU,
        200,200,640,480,
        nullptr,nullptr,hInstance,nullptr
        );
</code></pre><pre><code>HWND CreateWindowExA(
  DWORD     dwExStyle,    窗口扩展样式
  LPCSTR    lpClassName,    实例窗口类的名称，与wc的lpszClassName相对应
  LPCSTR    lpWindowName,    窗口名称
  DWORD     dwStyle,    窗口样式
  int       X,    窗口位置X，Y
  int       Y,
  int       nWidth,        窗口宽度
  int       nHeight,    窗口高度
  HWND      hWndParent,    窗口的父窗口
  HMENU     hMenu,    窗口菜单
  HINSTANCE hInstance,    实例
  LPVOID    lpParam    可以用来存储传递数据
);
</code></pre><p>最后我们需要将窗口显示出来</p>
<pre><code>    ShowWindow(hwnd,SW_SHOW);
    while (true);
    return 0;
</code></pre><p>得到效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201214162127020.png" alt="image-20201214162127020"></p>
<h2 id="窗口消息"><a href="#窗口消息" class="headerlink" title="窗口消息"></a>窗口消息</h2><p>事件驱动编程，窗口消息本质上来说就是事件Event</p>
<p>窗口会处理比如鼠标移动，鼠标点击消息事件，把消息按顺序放进队列里，我们利用GetMessage获取队列的消息，利用TranslateMsg进行消息的转换<strong>（比如将键盘点击转换为字符）</strong>，DispatchMessage将消息返回到WndProc进行消息处理</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201214210636986.png" alt="image-20201214210636986"></p>
<p>首先我们需要一个消息结构体，用于保存消息数据，然后把这个结构体指针传进GetMessage</p>
<p>如果hwnd为null，则所有窗口的消息都会被接受</p>
<pre><code>BOOL GetMessage(
  LPMSG lpMsg,    消息指针
  HWND  hWnd,    处理消息的窗口指针
  UINT  wMsgFilterMin,    过滤选项，用于过滤得到想要的消息
  UINT  wMsgFilterMax
);
</code></pre><p>消息结构体</p>
<pre><code>typedef struct tagMSG {
  HWND   hwnd;    窗口指针
  UINT   message;    消息类型
  WPARAM wParam;    保存数据    
  LPARAM lParam;
  DWORD  time;    消息发布的时间
  POINT  pt;    鼠标的位置
  DWORD  lPrivate;
} MSG, *PMSG, *NPMSG, *LPMSG;
</code></pre><p>只要GetMessage返回数值 &gt; 0则表明信息接收没有问题，继续循环，当返回0时表示窗口关闭退出循环</p>
<pre><code>//消息循环
    MSG message;
    while (GetMessage(&amp;message,nullptr,0,0) &gt; 0)
    {
        TranslateMessage(&amp;message);
        DispatchMessage(&amp;message);
    }
</code></pre><p>这时候会出现一个问题，当你关掉窗口之后，窗口只是被最小化还会在后台运行，所以我们要自定义winProc解决问题，同时需要将窗口结构体的lpfnWndProc设置为我们自定义的windowProc</p>
<p>wParam和lParam包含与消息相关的数据，主要取决与消息的类型</p>
<p>比如WM_QUIT message的wParam是PostQuitMessage给出的数字69，lParam则没有是用到的</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201214220730551.png" alt="image-20201214220730551"></p>
<pre><code>// 自定义WindowProc
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_CLOSE:    //接受到关闭窗口消息就结束进程
        PostQuitMessage(69);
    default:
        break;
    }

    //处理完特定的消息之后，进行默认消息处理
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

.....

wc.lpfnWndProc = WindowProc;

.....


    //出现错误
    if (gResult == -1)
    {
        return -1;
    }
    else
    {
        return message.wParam;    //返回69
    }
</code></pre><p>得到可以拖动，正常关闭结束进程的窗口</p>
<p>全部代码</p>
<pre><code>#include &quot;Windows.h&quot;

// 自定义WindowProc
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_CLOSE:    //接受到关闭窗口消息就结束进程
        PostQuitMessage(69);
    default:
        break;
    }

    //处理完特定的消息之后，进行默认消息处理
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


// 创建WinMain entry point
int CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PSTR pCmdLine, int nCmdShow)
{
    // 注册窗口类

    WNDCLASSEX wc = {};

    // 窗口类名
    const wchar_t CLASS_NAME[] = L&quot;Opda Window Class&quot;;

    // 设置属性
    wc.cbSize = sizeof(wc);
    wc.style = CS_OWNDC;
    wc.lpfnWndProc = WindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = nullptr;
    wc.hIconSm = nullptr;
    wc.hCursor = nullptr;
    wc.hbrBackground = nullptr;
    wc.lpszMenuName = nullptr;
    wc.lpszClassName = CLASS_NAME;

    RegisterClassEx(&amp;wc);

    //创建窗口实例
    HWND hwnd = CreateWindowEx(
        0, CLASS_NAME, L&quot;Hello World&quot;,
        WS_CAPTION | WS_MINIMIZEBOX | WS_SYSMENU,
        200,200,640,480,
        nullptr,nullptr,hInstance,nullptr
        );

    ShowWindow(hwnd,SW_SHOW);

    //消息循环
    MSG message;
    //用于保存GetMessage返回的结果
    BOOL gResult;
    while (gResult = GetMessage(&amp;message,nullptr,0,0) &gt; 0)
    {
        TranslateMessage(&amp;message);
        DispatchMessage(&amp;message);
    }

    //出现错误
    if (gResult == -1)
    {
        return -1;
    }
    else
    {
        return message.wParam;
    }
}
</code></pre>]]></content>
      <categories>
        <category>Win32</category>
      </categories>
      <tags>
        <tag>Win32</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Visual Effect Graph初探</title>
    <url>/2019/10/31/Unity-Visual-Effect-Graph%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近为了实现动画课程设计的烟花效果，所以要学习一下Unity的新特效工具Visual Effect Graph，特此记录学习的过程，避免以后会忘记。</p>
 <a id="more"></a> 
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>目前Visual Effect Graph只能在HDRP中使用，也就是说必须使用Unity2018.3以上的版本。</p>
</blockquote>
<h2 id="为什么要使用VEF"><a href="#为什么要使用VEF" class="headerlink" title="为什么要使用VEF"></a>为什么要使用VEF</h2><p>我们已经有传统的Particle System系统，那为什么要用VEF呢？</p>
<p>其实VEF能比传统的Particle System能做出更加复杂酷炫的特效，具体可以查看Unity的官方文档。而且我们认为VEF还有一个更加巨大有点就是可视化，我刚开始接触Particle System的时候，看到这么多参数，头都晕了….这次VEF的工作流非常的清楚。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/24.jpg" alt="VEF和传统Particle System区别"></p>
<h2 id="VEF的工作流"><a href="#VEF的工作流" class="headerlink" title="VEF的工作流"></a>VEF的工作流</h2><p>关于VEF的安装和配置就不说了，官方文档有详细的讲解。</p>
<p>首先我们来看一下VEF的画面，可以看出和shader Graph非常的相似。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/1.png" alt="VEG"></p>
<p>VEF默认模板由4个流程构成(VEF称为Context)，包含着多个Block，整个VEF工作流抽象成4个部分</p>
<h3 id="Spawn"><a href="#Spawn" class="headerlink" title="Spawn"></a>Spawn</h3><p>负责生成粒子，右键点击添加的Block都是与粒子生成相关。</p>
<h3 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h3><p>初始化模块，负责初始化粒子的属性，如初始速度，生命周期。</p>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>每帧对粒子的参数进行更新，比如重力，移动速度，坐标等。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>主要负责粒子的渲染，如颜色，形状等。</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>每个Context连接并不是唯一，比如一个Spawn可连接多个Initialize，朝多个方向发射</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/2.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/3.png" alt></p>
<h2 id="VEF的使用"><a href="#VEF的使用" class="headerlink" title="VEF的使用"></a>VEF的使用</h2><h3 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h3><p>VEF的小测试，以粒子的初始速度为基准设置粒子的颜色</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/4.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/5.png" alt></p>
<p>实现以原点为圆心，半径为1，圆以内的呈绿色，圆以外的呈紫色。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/6.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/7.png" alt></p>
<p>也可添加Get Attribute：Color结点获取粒子原本的颜色，达到新效果。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/8.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/9.png" alt></p>
<h3 id="Point-Cache-bake-tool-点阵缓存烘焙器"><a href="#Point-Cache-bake-tool-点阵缓存烘焙器" class="headerlink" title="Point Cache bake tool(点阵缓存烘焙器)"></a>Point Cache bake tool(点阵缓存烘焙器)</h3><p>这个是VEG添加的新工具，它的作用是把一张图或者Mesh的信息，烘焙成一张点阵图，然后再VEG中使用，可烘焙的信息有颜色，法线，位置，UV信息等。</p>
<p>首先点开烘焙工具，烘焙工具在上方Window—-Visual Effects—-Utilities—-Point Cache bake tool,选择要烘焙的网格和信息，这里我选择胶囊体作为测试。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/10.png" alt></p>
<p>在VEG中使用以下两个节点，即可得到一个粒子形成的胶囊体</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/11.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/12.png" alt></p>
<h3 id="Vector-Field-Force-矢量场力"><a href="#Vector-Field-Force-矢量场力" class="headerlink" title="Vector Field Force(矢量场力)"></a>Vector Field Force(矢量场力)</h3><p>官方文档解释：矢量场力施加从包含矢量数据的3D纹理中获取的力。我也不是很明白，以后有机会再研究。通过结合矢量场力和Point Cache我们可以实现粒子物体爆掉的感觉。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/13.png" alt></p>
<h3 id="VFX-Binder脚本，参数与事件的绑定"><a href="#VFX-Binder脚本，参数与事件的绑定" class="headerlink" title="VFX Binder脚本，参数与事件的绑定"></a>VFX Binder脚本，参数与事件的绑定</h3><p>为了在游戏运行时根据游戏内的逻辑来实时动态改变VEG，我们可以用VFX Binder绑定脚本。</p>
<h4 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h4><p>首先，我们为VFX添加VFX Parameter binder脚本</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/14.png" alt></p>
<p>在Hierarchy面板新建一个Cube，这个Cube用于传递位置参数进VEG，实时更新粒子喷发的位置。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/15.png" alt></p>
<p>进入VEG在参数面板新建一个Vector3用于存储Cube的位置参数，并传递给粒子。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/18.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/17.png" alt="最终结果"></p>
<h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>在VEG里事件作为一个单独的Context，不能附加任何的Block并且只能和Spawn相连，作用是管理Spawn的发射开关。</p>
<p>现在做鼠标点击位置生成粒子效果</p>
<p>首先新建一个Plane作为脚本的载体，并且绑定VFX Mouse Event Blinder事件,拖入新建的VFX</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/22.png" alt></p>
<p>双击VEX，新建一个Event，注意名字要和脚本上的EventName要一致。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/21.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/23.png" alt></p>
<h5 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h5><p>Location为Source的Attribute只能用在Initializes中的Block上</p>
<p>最后我们就能实现鼠标点击位置生成粒子的效果了。</p>
<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>第一次尝试这样做笔记，比较痛苦，但成就感也是满满的。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity实现玉石效果学习笔记</title>
    <url>/2020/12/17/Unity%E5%AE%9E%E7%8E%B0%E7%8E%89%E7%9F%B3%E6%95%88%E6%9E%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C.gif" alt="最终效果"></p>
<a id="more"></a>
<p>学习文章地址：<a href="http://walkingfat.com/simple-subsurface-scatterting-for-mobile-%ef%bc%88%e4%b8%80%ef%bc%89%e9%80%9a%e9%80%8f%e6%9d%90%e8%b4%a8%e7%9a%84%e6%ac%a1%e8%a1%a8%e9%9d%a2%e6%95%a3%e5%b0%84/" target="_blank" rel="noopener">http://walkingfat.com/simple-subsurface-scatterting-for-mobile-%ef%bc%88%e4%b8%80%ef%bc%89%e9%80%9a%e9%80%8f%e6%9d%90%e8%b4%a8%e7%9a%84%e6%ac%a1%e8%a1%a8%e9%9d%a2%e6%95%a3%e5%b0%84/</a></p>
<p>这个博主真的太强了！！！就是存在的问题是你的调参能力要非常强，不然就算代码完全一摸一样可能都达不到博主的效果…..</p>
<h2 id="制作思路"><a href="#制作思路" class="headerlink" title="制作思路"></a>制作思路</h2><p>将平行光源的方向反转，相当于背对光源的那一面的光照由反转的虚拟光源提供，达到了一种次表面散射的效果。同时利用表面法线对反向光源进行一定偏移代表不同散射强度。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/wps1.jpg" alt="img"></p>
<p>然后添加漫反射，高光，边缘光，调成参数达到一个比较好的效果。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217211954161.png" alt="image-20201217211954161"></p>
<p>因为模型不同的厚薄程度会影响次表面散射的效果，所以我把模型导入substancePainter中烘焙出thickess贴图来代表模型的厚度。左边为没有厚度图效果，右边厚度图效果。</p>
<p>​                                                                    <img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217211721182.png" alt="image-20201217211721182"><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217211818301.png" alt="image-20201217211818301"></p>
<p>最后，我添加了Bloom和AO的后处理效果。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201217211752569.png" alt="image-20201217211752569"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code>Shader &quot;Unlit/SSS_Shader&quot;
{
    Properties
    {
        _AOTex(&quot;AO贴图&quot;,2D) = &quot;white&quot; {}
        _subsurfaceParam(&quot;散射偏移&quot;,float) = 1
        [HDR]_scatteringColor(&quot;散射颜色&quot;,Color) = (1,1,1,1)
        _diffuse(&quot;漫反射颜色&quot;,color) = (1,1,1,1)
        _specular(&quot;高光颜色&quot;,color) = (1,1,1,1)
        _specularPower(&quot;高光区域范围&quot;,float) = 1
        _rimPower(&quot;边缘光区域范围&quot;,float) = 1
        _rimIntensity(&quot;边缘光强度&quot;,float) = 1
        _thickness(&quot;厚度修改值&quot;,float) = 0.2
        _power(&quot;power&quot;,float) = 1
        _scale(&quot;scale&quot;,float) = 1
    }
    SubShader
    {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
        LOD 100

        Pass
        {
            Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;}
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // make fog work
            #pragma multi_compile_fog

            #include &quot;UnityLightingCommon.cginc&quot;
            #include &quot;UnityCG.cginc&quot;

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
                float3 normalDir : NORMAL;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float3 worldNormalDir : TEXCOORD1;
                float3 worldViewDir : TEXCOORD2;
                float3 worldLightDir : TEXCOORD3;
                float4 worldPos : TEXCOORD4;
                UNITY_FOG_COORDS(5)
                float4 vertex : SV_POSITION;
            };

            sampler2D _AOTex;
            float _subsurfaceParam;
            float4 _scatteringColor;
            float4 _diffuse;
            float4 _specular;
            float _thickness;
            float _specularPower;
            float _rimPower;
            float _rimIntensity;
            float _power;
            float _scale;


            //次表面散射计算函数
            float SubsurfaceScattering(float3 viewDir,float3 lightDir, float3 normalDir,float subsurfaceParam)
            {
                //背面次表面反射
                float3 backLightDir = normalDir * subsurfaceParam + lightDir;
                //正面次表面反射
                float3 frontLightDir = normalDir * subsurfaceParam - lightDir;
                float result = pow(saturate(dot(viewDir,-backLightDir))+saturate(dot(viewDir,-frontLightDir))*0.5,_power)*_scale;
                return result;
            }

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                //计算worldPos
                o.worldPos = mul(unity_ObjectToWorld,v.vertex);
                //计算normal,view,light等方向
                o.worldNormalDir = UnityObjectToWorldNormal(v.normalDir);
                o.worldViewDir = normalize(UnityWorldSpaceViewDir(o.worldPos));
                o.worldLightDir = normalize(UnityWorldSpaceLightDir(o.worldPos));
                UNITY_TRANSFER_FOG(o,o.vertex);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                // sample the texture
                fixed4 col = tex2D(_AOTex, i.uv);

                float sssValue = SubsurfaceScattering(i.worldViewDir,i.worldLightDir,i.worldNormalDir,_subsurfaceParam);
                //获得次表面散射颜色
                fixed3 sssColor = lerp(_scatteringColor,_LightColor0,sssValue)*sssValue;

                //计算diffuse颜色
                float diff = max(0,dot(i.worldNormalDir,i.worldLightDir));
                float3 unlitCol = _diffuse * _scatteringColor * 0.5;//暗部颜色
                float3 diffuse_color = lerp(unlitCol,_diffuse,diff);

                //计算高光
                float3 H = normalize(i.worldLightDir+i.worldViewDir);
                float3 specular_color = _LightColor0*_specular*pow(max(0,dot(normalize(i.worldNormalDir),H)),_specularPower);

                //计算边缘光
                float rim = 1.0 - max(0,dot(i.worldNormalDir,i.worldViewDir));
                float rimValue = lerp(rim,0,sssValue);
                float3 rimColor =max(0, lerp(_scatteringColor,_LightColor0,rimValue)*pow(rimValue,_rimPower)*_rimIntensity);
                //将sssColor和diffuse_color相加
                float3 finalColor = sssColor*(saturate((1-col.r)+_thickness))+diffuse_color+specular_color+rimColor;
                // apply fog
                UNITY_APPLY_FOG(i.fogCoord, col);
                return fixed4(finalColor,1);
            }
            ENDCG
        }
    }
    Fallback &quot;Specular&quot;
}
</code></pre>]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity实现米哈游的Mesh变换转场效果</title>
    <url>/2019/11/13/Unity%E5%AE%9E%E7%8E%B0%E7%B1%B3%E5%93%88%E6%B8%B8%E7%9A%84Mesh%E5%8F%98%E6%8D%A2%E8%BD%AC%E5%9C%BA%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前看过米哈游大佬制作的桃源恋歌MMD，被其中的Mesh变换转场效果所折服了，所以自己想模仿着实现这个效果，幸好kerjiro技术美术大神开源了这方面的视觉特效项目，感觉自己如果想成为TA还有好长的路要走。。。</p>
 <a id="more"></a> 
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>首先让我们来看一下最终效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/Effect.gif" alt="Effect"></p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>其实这个效果是通过几何着色器来实现的，主要思路就是通过几何着色器对三角面片的顶点进行添加，构成一个Cube。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF.png" alt="实现思路"></p>
<h2 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h2><p>相信大家接触的最多的应该是顶点着色器和像素着色器，那么什么是几何着色器呢？</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在顶点和片段着色器之间有一个可选的着色器，叫做几何着色器(Geometry Shader)。几何着色器以一个或多个表示为一个单独基本图形（primitive）即图元的顶点作为输入，比如可以是一个点或者三角形。几何着色器在将这些顶点发送到下一个着色阶段之前，可以将这些顶点转变为它认为合适的内容。<strong>几何着色器有意思的地方在于它可以把（一个或多个）顶点转变为完全不同的基本图形（primitive），从而生成比原来多得多的顶点。</strong> </p>
<h3 id="使用几何着色器进行图元转换"><a href="#使用几何着色器进行图元转换" class="headerlink" title="使用几何着色器进行图元转换"></a>使用几何着色器进行图元转换</h3><p>声明着色器</p>
<pre><code>#pragma geometry geom
</code></pre><p>设置输出顶点数量，其中N为几何着色器为单个调用输出的顶点最大数量，几何着色器每次输出的顶点数量是可变的，但是不能超过定义的最大值， 出于性能考虑，最大顶点数应尽可能小; 当GS输出在1到20个标量之间时，可以实现GS的性能峰值，如果GS输出在27-40个标量之间，则性能下降50％。每次调用的标量输出数是最大顶点输出数和输出顶点类型结构中的标量数的乘积。 </p>
<pre><code>[maxvertexcount(N)]
</code></pre><p>声明输入和输出的Struct</p>
<pre><code>            //传递给几何着色器的数据
            struct v2g
            {
                float4 vertex:POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv:TEXCOORD1;

            };

            //传递给像素着色器的数据
            struct g2f
            {
                float4 pos : SV_POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv : TEXCOORD1;
                float4 color:COLOR;
            };
</code></pre><p>设置几何着色器输入参数和输出参数，</p>
<p>其中“triangle”为输入的图元类型， 输入参数一定为顶点数组 。</p>
<pre><code class="lang-ruby">输入图元类型 | 所需顶点数  
-|-
point | 输入1个点的1个顶点
line | 输入1条直线的2个顶点 
lineadj | 输入1条具有邻接(lists或strips)的线段的4个顶点 
triangle | 输入1个三角形的3个顶点
triangleadj | 输入1个具有邻接(lists或strips)的三角形的6个顶点
</code></pre>
<p>TriangleStream为流类型(stream type)对象，还有 LineStream 和 PointStream ,存储着由几何着色器输出的几何体顶点列表。内置Append用于向输出流添加顶点序列， 若想扩展输入的图元，也可以用内置Append向输出流添加多出来的顶点。 </p>
<p>当指定uint primID:SV_PrimitiveID时，输入汇编阶段会为每个图元自动生成一个图元ID。当调用draw方法绘制n个图元时，ID号为0到n-1，这里用到的原因是为了随机Cube化。</p>
<pre><code>void geom(triangle v2g input[3], uint pid : SV_PrimitiveID, inout TriangleStream&lt;g2f&gt; outStream)
{
    //shader body
}
</code></pre><p>将输出顶点传送至输出stream上</p>
<pre><code>OutputStream.Append(o);
</code></pre><h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><h3 id="CPU传递数据给Shader"><a href="#CPU传递数据给Shader" class="headerlink" title="CPU传递数据给Shader"></a>CPU传递数据给Shader</h3><p>首先我们需要新建一个脚本用于传递数据给Shader，以下就是K神的传递脚本，我已经写好注释。挂在一个空物体上面即可。</p>
<pre><code>using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//在编辑器模式下也可运行
[ExecuteInEditMode]
public class Voxelizer : MonoBehaviour
{
    //SerializeField用于面板上显示非Public的参数
    //Range(0,1)控制可滑选的范围

    //控制生成方块的密度
    [SerializeField, Range(0, 1)] float _density = 0.05f;
    //控制生成方块的大小
    [SerializeField, Range(0, 10)] float _scale = 3;


    //动画参数
    //用于控制方块变形后的长度
    [SerializeField, Range(0, 20)] float _stretch = 5;
    //用于控制方块变形后上升的最大距离
    [SerializeField, Range(0, 1000)] float _fallDistance = 1;
    //用于控制方块变形后的随机移动范围
    [SerializeField, Range(0, 10)] float _fluctuation = 1;

    //颜色参数
    [SerializeField, ColorUsage(false, true)] Color _emissionColor1 = Color.black;
    [SerializeField, ColorUsage(false, true)] Color _emissionColor2 = Color.black;
    [SerializeField, ColorUsage(false, true)] Color _transitionColor = Color.white;
    [SerializeField, ColorUsage(false, true)] Color _lineColor = Color.white;

    //用于Mesh变换物体的Renderer
    [SerializeField] Renderer[] _renderers = null;


    //效果平面的位置与距离
    Vector4 EffectorPlane
    {
        get
        {
            //获取向前的方向
            var fwd = transform.forward / transform.localScale.z;
            //获取向前方向上的移动距离
            var dist = Vector3.Dot(fwd, transform.position);
            return new Vector4(fwd.x, fwd.y, fwd.z, dist);
        }
    }


    //将RGB颜色模型转为HSV颜色模型
    Vector4  ColorToHsvm(Color color)
    {
        //获取颜色的分量最大值
        var max = color.maxColorComponent;
        float h, s, v;
        Color.RGBToHSV(color / max, out h, out s, out v);
        return new Vector4(h, s, v, max);
    }


    //获取着色器属性的唯一标识符
    //优点：使用属性标识符比将字符串传递给所有材料属性函数更有效。
    //例如，如果您经常调用Material.SetColor或使用MaterialPropertyBlock，
    //则最好只获取一次所需属性的标识符。

    static class ShaderIDs
    {
        public static readonly int VoxelParams = Shader.PropertyToID(&quot;_VoxelParams&quot;);
        public static readonly int AnimParams = Shader.PropertyToID(&quot;_AnimParams&quot;);
        public static readonly int EmissionHsvm1 = Shader.PropertyToID(&quot;_EmissionHsvm1&quot;);
        public static readonly int EmissionHsvm2 = Shader.PropertyToID(&quot;_EmissionHsvm2&quot;);
        public static readonly int TransitionColor = Shader.PropertyToID(&quot;_TransitionColor&quot;);
        public static readonly int LineColor = Shader.PropertyToID(&quot;_LineColor&quot;);
        public static readonly int EffectorPlane = Shader.PropertyToID(&quot;_EffectorPlane&quot;);
        public static readonly int PrevEffectorPlane = Shader.PropertyToID(&quot;_PrevEffectorPlane&quot;);
        public static readonly int LocalTime = Shader.PropertyToID(&quot;_LocalTime&quot;);
    }

    //在要使用相同材质但属性稍有不同的多个对象绘制的情况下使用MaterialPropertyBlock。
    MaterialPropertyBlock _sheet;
    Vector4 _prevEffectorPlane = Vector3.one * 1e+5f;

    private void LateUpdate()
    {
        //查看渲染列表是否为空
        if (_renderers == null || _renderers.Length == 0) return;
        //创建新的MaterialPropertyBlock
        if (_sheet == null) _sheet = new MaterialPropertyBlock();

        var plane = EffectorPlane;
        // Filter out large deltas.
        //过滤掉大的三角面片
        if ((_prevEffectorPlane - plane).magnitude &gt; 100) _prevEffectorPlane = plane;

        //存储参数
        var vparams = new Vector2(_density, _scale);
        var aparams = new Vector3(_stretch, _fallDistance, _fluctuation);
        var emission1 = ColorToHsvm(_emissionColor1);
        var emission2 = ColorToHsvm(_emissionColor2);

        //将参数传递给shader
        foreach (var renderer in _renderers)
        {
            if (renderer == null) continue;
            renderer.GetPropertyBlock(_sheet);
            _sheet.SetVector(ShaderIDs.VoxelParams, vparams);
            _sheet.SetVector(ShaderIDs.AnimParams, aparams);
            _sheet.SetVector(ShaderIDs.EmissionHsvm1, emission1);
            _sheet.SetVector(ShaderIDs.EmissionHsvm2, emission2);
            _sheet.SetColor(ShaderIDs.TransitionColor, _transitionColor);
            _sheet.SetColor(ShaderIDs.LineColor, _lineColor);
            _sheet.SetVector(ShaderIDs.EffectorPlane, plane);
            _sheet.SetVector(ShaderIDs.PrevEffectorPlane, _prevEffectorPlane);
            //_sheet.SetFloat(ShaderIDs.LocalTime, time);
            renderer.SetPropertyBlock(_sheet);
            print(plane);
        }
    }


    //进行gizmo编辑器的实现,用于可视化Debug
    Mesh _gridMesh;

    void OnDestroy()
    {
        if (_gridMesh != null)
        {
            if (Application.isPlaying)
                Destroy(_gridMesh);
            else
                DestroyImmediate(_gridMesh);
        }
    }

    void OnDrawGizmos()
    {
        if (_gridMesh == null) InitGridMesh();

        //矩阵用于控制Gizmos跟随物体的移动而移动
        Gizmos.matrix = transform.localToWorldMatrix;

        Gizmos.color = new Color(1, 1, 0, 0.5f);
        Gizmos.DrawWireMesh(_gridMesh, Vector3.zero);
        Gizmos.DrawWireMesh(_gridMesh, Vector3.forward);

        Gizmos.color = new Color(1, 0, 0, 0.5f);
        Gizmos.DrawWireCube(Vector3.forward / 2, new Vector3(0.02f, 0.02f, 1));
    }

    void InitGridMesh()
    {
        const float ext = 0.5f;
        const int columns = 10;

        var vertices = new List&lt;Vector3&gt;();
        var indices = new List&lt;int&gt;();

        for (var i = 0; i &lt; columns + 1; i++)
        {
            var x = ext * (2.0f * i / columns - 1);

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(x, -ext, 0));

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(x, +ext, 0));

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(-ext, x, 0));

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(+ext, x, 0));
        }

        _gridMesh = new Mesh { hideFlags = HideFlags.DontSave };
        _gridMesh.SetVertices(vertices);
        _gridMesh.SetNormals(vertices);
        _gridMesh.SetIndices(indices.ToArray(), MeshTopology.Lines, 0);
        _gridMesh.UploadMeshData(true);
    }
}
</code></pre><h3 id="MaterialPropertyBlock"><a href="#MaterialPropertyBlock" class="headerlink" title="MaterialPropertyBlock"></a>MaterialPropertyBlock</h3><p>研究代码的时候发现了MaterialPropertyBlock，查阅文档才发现是用于节约性能。实际应用可以查看这篇文章<a href="https://blog.csdn.net/liweizhao/article/details/81937590" target="_blank" rel="noopener">MaterialPropertyBlock</a>。</p>
<h3 id="Shader的实现"><a href="#Shader的实现" class="headerlink" title="Shader的实现"></a>Shader的实现</h3><pre><code>// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;

// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;

Shader &quot;Custom/MeshShader&quot;
{

    Properties
    {
        _MainTex(&quot;主纹理贴图&quot;,2D)=&quot;white&quot;{}
    }
    SubShader
    {
        Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
        LOD 100
        Pass
        {
            Tags{&quot;LightMode&quot;=&quot;ForwardBase&quot;}
            CGPROGRAM

            //声明着色器
            #pragma vertex vert 
            #pragma geometry geom
            #pragma fragment frag

            #include &quot;UnityCG.cginc&quot;
            #include &quot;Assets/My/SimplexNoise3D.hlsl&quot;
            //传递给顶点着色器的数据
            struct a2v
            {
                float4 vertex:POSITION;
                float3 normal:NORMAL;
                float4 texcoord:TEXCOORD0;
            };

            //传递给几何着色器的数据
            struct v2g
            {
                float4 vertex:POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv:TEXCOORD1;

            };

            //传递给像素着色器的数据
            struct g2f
            {
                float4 pos : SV_POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv : TEXCOORD1;
                float4 color:COLOR;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            //用于几何着色器的数据
            half2 _VoxelParams; // density, scale  密度，比例
            half3 _AnimParams;  // stretch, fall distance, fluctuation   伸展、下降距离、波动
            float4 _EffectorPlane;
            float4 _PrevEffectorPlane;

            //用于像素着色器的数据
            half4 _EmissionHsvm1;
            half4 _EmissionHsvm2;
            half3 _TransitionColor;
            half3 _LineColor;


            //顶点着色器
            void vert(inout v2g input)
            {

            }

            g2f VertexOutput(
                float3 position0, float3 position1,
                half3 normal0, half3 normal1, half param,
                half emission = 0, half random = 0, half2 baryCoord = 0.5
            )
            {
                g2f i;
                i.pos = UnityObjectToClipPos(float4(lerp(position0, position1, param),1));
                i.normal = normalize(lerp(normal0, normal1, param));
                i.color = float4(baryCoord, emission,random);
                return i;
            }

            // 计算方块的位置和大小
            void CubePosScale(
                float3 center, float size, float rand, float param,
                out float3 pos, out float3 scale
            )
            {
                const float VoxelScale = _VoxelParams.y;
                const float Stretch = _AnimParams.x;
                const float FallDist = _AnimParams.y;
                const float Fluctuation = _AnimParams.z;

                // Noise field
                //噪声场
                float4 snoise = snoise_grad(float3(rand * 2378.34, param * 0.8, 0));

                // Stretch/move param
                float move = saturate(param * 4 - 3);
                move = move * move;

                // Cube position
                pos = center + snoise.xyz * size * Fluctuation;
                pos.y += move * move * lerp(0.25, 1, rand) * size * FallDist;

                // Cube scale anim
                scale = float2(1 - move, 1 + move * Stretch).xyx;
                scale *= size * VoxelScale * saturate(1 + snoise.w * 2);
            }

            //哈希值，用于随机觉得面片是三角面片还是Cube
            float Hash(uint s)
            {
                s = s ^ 2747636419u;
                s = s * 2654435769u;
                s = s ^ (s &gt;&gt; 16);
                s = s * 2654435769u;
                s = s ^ (s &gt;&gt; 16);
                s = s * 2654435769u;
                return float(s) * rcp(4294967296.0); // 2^-32
            }

            //几何着色器
            [maxvertexcount(24)]
            void geom(triangle v2g input[3], uint pid : SV_PrimitiveID, inout TriangleStream&lt;g2f&gt; outStream)
            {
                //获取密度
                const float VoxelDensity = _VoxelParams.x;

                //获取传入顶点的位置
                float3 p0 = input[0].vertex.xyz;
                float3 p1 = input[1].vertex.xyz;
                float3 p2 = input[2].vertex.xyz;

                float3 p0_prev = p0;
                float3 p1_prev = p1;
                float3 p2_prev = p2;

                //获取传入顶点的法线
                float3 n0 = input[0].normal;
                float3 n1 = input[1].normal;
                float3 n2 = input[2].normal;

                //计算中心点
                float3 center = (p0 + p1 + p2) / 3;
                float size = distance(p0, center);

                //变形参数
                //将中心点变换到世界空间中
                float3 center_ws = mul(unity_ObjectToWorld, float4(center,1)).xyz;
                float param = 1 - dot(_EffectorPlane.xyz, center_ws) + _EffectorPlane.w;


                //如果变形还没开始那就将平常操作
                if (param &lt; 0)
                {
                    outStream.Append(VertexOutput(p0, 0, n0, 0, 0, 0, 0));
                    outStream.Append(VertexOutput(p1, 0, n1, 0, 0, 0, 0));
                    outStream.Append(VertexOutput(p2, 0, n2, 0, 0, 0, 0));
                    outStream.RestartStrip();
                    return;
                }


                //变形结束后，不传递任何数据，从而使物体隐身
                if (param &gt;= 1) return;

                // Choose cube/triangle randomly.
                //uint seed = float3(pid * 877, pid * 877, pid * 877);
                uint seed = pid * 877;
                if (Hash(seed) &lt; VoxelDensity)
                {
                    // -- Cube --

                    // Random numbers
                    float rand1 = Hash(seed + 1);
                    float rand2 = Hash(seed + 5);

                    // Cube position and scale
                    float3 pos, pos_prev, scale, scale_prev;
                    CubePosScale(center, size, rand1, param, pos, scale);

                    // Secondary animation parameters
                    float morph = smoothstep(0, 0.25, param);        

                    float em = smoothstep(0, 0.15, param) * 2; // initial emission
                    em = min(em, 1 + smoothstep(0.8, 0.9, 1 - param));
                    em += smoothstep(0.75, 1, param); // emission while falling

                    // Cube points calculation
                    float3 pc0 = pos + float3(-1, -1, -1) * scale;
                    float3 pc1 = pos + float3(+1, -1, -1) * scale;
                    float3 pc2 = pos + float3(-1, +1, -1) * scale;
                    float3 pc3 = pos + float3(+1, +1, -1) * scale;
                    float3 pc4 = pos + float3(-1, -1, +1) * scale;
                    float3 pc5 = pos + float3(+1, -1, +1) * scale;
                    float3 pc6 = pos + float3(-1, +1, +1) * scale;
                    float3 pc7 = pos + float3(+1, +1, +1) * scale;


                    // World space to object space conversion

                    // Vertex outputs
                    float3 nc = float3(-1, 0, 0);
                    outStream.Append(VertexOutput(p0, pc2, n0, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc0, n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p0, pc6, n0, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p2, pc4, n2, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(1, 0, 0);
                    outStream.Append(VertexOutput(p2, pc1, n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p1, pc3, n1, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p2, pc5, n2, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p1, pc7, n1, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, -1, 0);
                    outStream.Append(VertexOutput(p2, pc0, n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc1, n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p2, pc4, n2, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p2, pc5, n2, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, 1, 0);
                    outStream.Append(VertexOutput(p1, pc3, n1, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p0, pc2, n0, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p1, pc7, n1, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p0, pc6, n0, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, 0, -1);
                    outStream.Append(VertexOutput(p2, pc1, n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc0, n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p1, pc3, n1, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p0, pc2, n0, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, 0, 1);
                    outStream.Append(VertexOutput(p2, pc4, -n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc5, -n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p0, pc6, -n0, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p1, pc7, -n1, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();
                }
                else
                {
                    // -- Triangle --
                    half morph = smoothstep(0, 0.25, param);
                    //half morph = 0.25;
                    half em = smoothstep(0, 0.15, param) * 2;
                    outStream.Append(VertexOutput(p0, center, n0, n0, morph, em));
                    outStream.Append(VertexOutput(p1, center, n1, n1, morph, em));
                    outStream.Append(VertexOutput(p2, center, n2, n2, morph, em));
                    outStream.RestartStrip();
                }
            }

            //计算颜色
            half3 SelfEmission(g2f input)
            {
                half2 bcc = input.color.rg;
                half em1 = saturate(input.color.b);
                half em2 = saturate(input.color.b - 1);
                half rand = input.color.a;

                // Cube face color
                half3 face = lerp(_EmissionHsvm1.xyz, _EmissionHsvm2.xyz, rand);
                face *= lerp(_EmissionHsvm1.w, _EmissionHsvm2.w, rand);

                // Cube face attenuation
                face *= lerp(0.75, 1, smoothstep(0, 0.5, length(bcc - 0.5)));

                // Edge detection
                half2 fw = fwidth(bcc);
                half2 edge2 = min(smoothstep(0, fw * 2, bcc),
                    smoothstep(0, fw * 2, 1 - bcc));
                half edge = 1 - min(edge2.x, edge2.y);

                return
                    face * em1 +
                    _TransitionColor * em2 * face +
                    edge * _LineColor * em1;
            }

            half4 frag(g2f z):SV_Target
            {
                half4 col = half4(SelfEmission(z),1);
                return col;
            }
                ENDCG
        }
    }
    FallBack &quot;Diffuse&quot;
}
</code></pre><p>这里运用到了三维噪声的知识，这里我只是简单的调用了K神写好的噪声函数，并没有深究，其实我还是看过了一些关于噪声的文章，以后已机会把笔记总结出来。</p>
<h1 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h1><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/LastEffect.gif" alt="实现思路"></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这个效果对于模型也是有要求的，模型的面片不能太小，不然就会得到以下的结果…</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/Fail.gif" alt="失败效果"></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>作业说明</title>
    <url>/2021/10/05/%E6%97%A0%E6%A0%87%E9%A2%98Markdown/</url>
    <content><![CDATA[<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>高模Houdini渲染效果图</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="渲染效果图"></p>
<p>调整树叶的范围就是啊啊啊啊</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722010139997.png" alt></p>
<p>树叶低模效果，黑色区域可以烘焙Opacity贴图到游戏引擎内完成剔除。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722005100488.png" alt></p>
<p>树叶低模</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722005937330.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="石墙的构造"><a href="#石墙的构造" class="headerlink" title="石墙的构造"></a>石墙的构造</h3><p>首先创建grid，利用copy节点完成grid行列的复制，并在x轴方向随机偏移</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722010352397.png" alt></p>
<p>在面片撒点利用Voronoifracture形成破裂效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722010433962.png" alt></p>
<p>随机挤出的厚度以及缩放的大小，并用Noise去营造石块的磨损感</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722010543889.png" alt></p>
<p>利用面与面之间的最近点计算，进行遮挡点的删除</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722010730307.png" alt></p>
<p>通过VDB构建石墙的低模</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722010821048.png" alt></p>
<h3 id="叶子的构造"><a href="#叶子的构造" class="headerlink" title="叶子的构造"></a>叶子的构造</h3><p>首先通过trace节点完成叶子的建模</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722011053695.png" alt></p>
<p>利用刚体进行模拟叶子掉落的解算</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722011222222.png" alt></p>
<p>通过volumesampler进行SDF采样对于返回值大于0，既在体积外部的点都删除，得到基础的叶子整体模型</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722012615155.png" alt></p>
<p>最后讲叶子整体模型对地面以及石墙进行一定的贴近，并进行面数的删减</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20210722012921251.png" alt></p>
<p>最后利用labs maper Baker进行高低模的贴图烘焙</p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招总结</title>
    <url>/2020/10/12/%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本科双非，有一段腾讯的暑期实习经历，岗位是TA技术美术，因为实习的时候被深圳的物价和房价给吓到了，再加上家在广州，所以基本目标都在广州的游戏公司，也投了北京上海的游戏公司，原本想拿来练练手的，可能是双非学历再加上简历内容确实不太与游戏行业相关，所以基本石沉大海哈哈哈，根本不给机会</p>
 <a id="more"></a> 
<h2 id="投递公司"><a href="#投递公司" class="headerlink" title="投递公司"></a>投递公司</h2><div class="table-container">
<table>
<thead>
<tr>
<th>公司</th>
<th>进度</th>
</tr>
</thead>
<tbody>
<tr>
<td>网易互娱</td>
<td>意向书</td>
</tr>
<tr>
<td>诗悦网络</td>
<td>意向书</td>
</tr>
<tr>
<td>多益</td>
<td>意向书</td>
</tr>
<tr>
<td>西山居</td>
<td>通过了面试但还有训练营？？</td>
</tr>
<tr>
<td>4399</td>
<td>笔试完等面试，投得比较晚</td>
</tr>
<tr>
<td>完美世界</td>
<td>简历筛选</td>
</tr>
<tr>
<td>巨人网络</td>
<td>简历筛选</td>
</tr>
<tr>
<td>字节跳动</td>
<td>笔试考算法直接开溜</td>
</tr>
<tr>
<td>百奥</td>
<td>笔试考算法直接开溜</td>
</tr>
<tr>
<td>西山居剑心互娱</td>
<td>笔试之后没消息</td>
</tr>
<tr>
<td>心动网络</td>
<td>笔试挂</td>
</tr>
</tbody>
</table>
</div>
<p>TA这个岗位需求太少了，所以可投公司不多，也算尽自己的努力去得到一个最好的结果了，我其实也没想过一定要去大厂工作，只要是广州就好了。这里吐槽一下，由于TA这个岗位才刚出来，每家公司的招人标准都不一样，腾讯网易需要做测试题，字节百奥需要考算法，心动网络笔试考C++图形学基础，很混乱，导致需要准备很多东西，浪费时间。</p>
<p><strong>吐槽一下字节游戏</strong>，昨天HR还加我微信叫我投简历，第二天就将我简历给挂掉了，就离谱，还叫我转去三维美术。</p>
<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>​    我参加的第一场笔试好像就是心动网络的笔试，那时候我以为TA的笔试大家都一样做做测试题，所以就没有做什么特别准备。我笔试做了30分钟我就做不下去了，考了C++，图形学，1.抗锯齿问题 2.GPU性能问题等等，比较久了有点忘记题目。反正我考完立刻心态崩了，没想到TA笔试还能这样玩，所以我立刻查漏补缺，对我后面影响挺大的。</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>由于时间过了太久了，我记性也不是很好，只记住了一些印象深刻的问题</p>
<h3 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h3><p>​    面试阶段，网易就问了我测试题的细节问题，图形学也没怎么问，可能是因为我春招面试过了的原因吧，就是HR问了我春招为啥去了腾讯没来网易，哈哈哈有点尴尬</p>
<h3 id="诗悦-西山居"><a href="#诗悦-西山居" class="headerlink" title="诗悦 西山居"></a>诗悦 西山居</h3><p>​    这个就比较常规正常点了，诗悦一开头就问了我算法题，我直接放弃思考，然后就问我图形学方面的问题，大概是什么是DrawCall，抗锯齿，PBR相关内容，卡通渲染的要点（主要是我项目写了这个），批处理，基本上是UnityShader入门精要上面的内容，刷一遍就好，幸好图形学加分了，不然我直接GG。</p>
<p>​    西山居问的就比较难了，基本上是根据你简历的内容一直往下问，看到我简历写了PBR，就问我PBR的实现，答完之后问我知道IBL是什么吗？然后知道SDF距离场是什么？一套组合拳直接把我打懵。</p>
<h3 id="多益"><a href="#多益" class="headerlink" title="多益"></a>多益</h3><p>​    面试官直接跟我聊天，问我哪里人，能不能接受加班，HR小姐姐问我有没有女朋友，我说没有，面试官还给我补了一刀：你看他那么宅肯定没有女朋友的啦……</p>
<h2 id="学习历程"><a href="#学习历程" class="headerlink" title="学习历程"></a>学习历程</h2><p><strong>入门书籍</strong>：UnityShader入门精要，3D数学基础，龙书DX11（太厚了，我没看下去，引擎程序员可以看）</p>
<p>C++ Primer（感觉TA不是很看重C++内容，只要基础就行，可以面向面经学习）</p>
<p><strong>视频学习</strong>：GAMES101-现代计算机图形学入门，闫令琪大佬的现代图形学课程（真的非常好，帮我图形学知识重新梳理了一遍）</p>
<p>UE4教程B站杨一鸣大佬视频都挺好的，看着撸一遍，Unity可以看看Siki学院的教程</p>
<p><strong>关于数据结构和算法</strong>，不同公司不同标准，米哈游和字节的TA会考算法，但腾讯网易不会考算法，考测试题，我根本没刷算法题，所以考算法的公司直接开溜不考了，这里还是看要目标公司再决定算法要不要刷，毕竟需要的时间也是要很多的。</p>
<p><strong>TA很需要审美</strong>，毕竟这也跟引擎程序员的最大不同，要做出好看的东西（虽然我做的东西不好看哈哈，春招找实习的时候还被面试官diss），所以我最近买个数位板在学板绘提高审美</p>
<p>最后根据自己兴趣做几个游戏的demo，也可以写个光栅化渲染器（这个一般是引擎程序员干的）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这次秋招我感觉到实习经历非常重要，如果有一个好的大厂经历，秋招真的会好过很多。这里非常感谢我的师兄，如果没有他的分享我铁定今年春招的时候混吃等死，哪里会去找什么暑期实习，那秋招的时候双非学历可能简历都过不了。</p>
<p>​    有了春招的铺垫和历练，秋招就比较容易地过去了（虽然还是很焦虑），也拿到自己想要的offer，希望自己能继续学下去，不再混吃等死吧</p>
<p>​    最后，秋招终于结束辣，可以无忧无虑地看S赛了，LPL加油！</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>龙卷风Niagara效果</title>
    <url>/2020/11/02/%E9%BE%99%E5%8D%B7%E9%A3%8ENiagara%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>继续Niagara的学习，教程地址：<a href="https://www.youtube.com/watch?v=P9Bk1Ibd0YY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=P9Bk1Ibd0YY</a></p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/%E5%86%B0%E7%81%AB%E9%A3%8E%E6%9A%B4.gif" alt="冰火风暴"></p>
<a id="more"></a>
<h2 id="分析实现点"><a href="#分析实现点" class="headerlink" title="分析实现点"></a>分析实现点</h2><p>1.龙卷风的实现    2.龙卷风吹起来的漩涡石头</p>
<h2 id="龙卷风的实现"><a href="#龙卷风的实现" class="headerlink" title="龙卷风的实现"></a>龙卷风的实现</h2><p>首先需要准备好模型和相对应的贴图，模型为没封盖的圆柱体，贴图R通道是基本色，G通道是噪声图</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023015499.png" alt="image-20201102023015499"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023034241.png" alt="image-20201102023034241"></p>
<p>做好龙卷风的基本材质，蓝图系统就这点不好，没办法像代码一样复制粘贴</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023206240.png" alt="image-20201102023206240"></p>
<p>新建一个新的NiagaraSystem，创建Empty发射器。龙卷风最大的特点是下小上大，从底处慢慢升高，可以从这点进行着手。利用Scale Mesh Size完成曲线的从小到大的调整。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023421834.png" alt="image-20201102023421834"></p>
<p>现在我们要完成的就剩下从底升高，同样调整曲线设置粒子的Position达到效果。同时龙卷风还会左右摇摆，我们利用cos和sin在xy方向完成摇摆效果。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023600003.png" alt="image-20201102023600003"></p>
<p>再添加一点小细节，比如龙卷风底部的小漩涡效果和外部的亮度效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023855355.png" alt="image-20201102023855355"></p>
<h2 id="龙卷风吹起来的漩涡石头"><a href="#龙卷风吹起来的漩涡石头" class="headerlink" title="龙卷风吹起来的漩涡石头"></a>龙卷风吹起来的漩涡石头</h2><p>首先我们需要Add Rotational Velocity，因为石头被龙卷风吹起来，肯定是不停地进行旋转的。</p>
<h3 id="Add-Rotational-Velocity"><a href="#Add-Rotational-Velocity" class="headerlink" title="Add Rotational Velocity"></a>Add Rotational Velocity</h3><p>添加旋转加速度，要搭配Add Inital Forces 和 Solve Rotational Forces and Velocity模块使用</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102013736029.png" alt="image-20201102013736029"></p>
<h3 id="Votex-Force"><a href="#Votex-Force" class="headerlink" title="Votex Force"></a>Votex Force</h3><p>漩涡力，一般在粒子更新组里面使用，和其他加速度的模组一起使用会达到漩涡的效果，由Simulation Position升到Vortex Origin漩涡中心，在围绕着漩涡中心四处飘散</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102013130138.png" alt="image-20201102013130138"></p>
<h3 id="Add-Velocity-in-Cone-和-Cylinder-Location"><a href="#Add-Velocity-in-Cone-和-Cylinder-Location" class="headerlink" title="Add Velocity in Cone 和 Cylinder Location"></a>Add Velocity in Cone 和 Cylinder Location</h3><p>最后我们利用Add Velocity in Cone 和Cylinder Location 来完成石头的随机分散和初始随机力。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102024340085.png" alt="image-20201102024340085"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的效果比较简单，只做个人简单的笔记，建议看原油管Up主的视频教程更佳。</p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
</search>
