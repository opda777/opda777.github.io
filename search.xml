<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019年---小记</title>
    <url>/2020/01/07/2019%E5%B9%B4---%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    在三维动画，交互设计等等的课程实训，我掐指一算已经有两个月没有更新自己的笔记了，没办法，我也不知道为什么我这个专业的实训特别特别得多….其实早就放假啦，自己也摸鱼了一个星期恢复下元气。</p>
<p>​    对于2019我感觉还行，虽然没有参加什么比赛，但是在实训课程的过程中还是学到了很多东西，做出来的成品也让我感到满意，所以希望下一年也再接再厉，希望寒假没有摸鱼，能找到实习就最好了，哈哈哈。</p>
<p>​    加油！！！奥利给！！！</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记cover</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建过程(踩坑)</title>
    <url>/2019/10/30/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​         本文主要用来记录自己Hexo博客搭建过程中遇到的坑。</p>
 <a id="more"></a> 

<h1 id="个人域名篇"><a href="#个人域名篇" class="headerlink" title="个人域名篇"></a>个人域名篇</h1><p>​         这个个人域名的确有点坑，明明按着教程的操作一步一步来的，还是弄了一晚上，到最后才发现是校园网DNS的坑。。。</p>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><p>​        首先我们要购买一个属于自己的域名，可以去腾讯云，阿里云等网站进行购买，这里我在阿里云购买opda.tech，为什么不用com域名，因为这个便宜。</p>
<p>​    购买域名后我们还要得到github仓库的IP。通过cmd命令行，输入Ping 你的名字.github.io获取名字   </p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/2.png" alt></p>
<p>红色箭头所指就是你github仓库的IP，然后我们就可以进行DNS解析。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/1.png" alt></p>
<p>进去之后，点击新手引导，输入cmd获得的IP即可。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/4.png" alt></p>
<p>解析完的结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/11.png" alt></p>
<p>​    </p>
<h2 id="2-github的绑定"><a href="#2-github的绑定" class="headerlink" title="2.github的绑定"></a>2.github的绑定</h2><p>​        进入你创建的仓库内，点击Setting</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/5.png" alt></p>
<p>​        GitHub Pages设置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/6.png" alt></p>
<p>就这样github仓库的绑定就完成啦！</p>
<h2 id="3-最后一步"><a href="#3-最后一步" class="headerlink" title="3.最后一步"></a>3.最后一步</h2><p>我们还要在本地博客的source文件夹下新建一个CNAME.txt文本，在里面输入我们的自定义域名，修改完毕之后记得把CNAME的txt后缀去掉！！！不然会不行的（感谢猫桑的bug发现）</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/7.png" alt></p>
<p>最后我们Git Base重新部署一下博客就行啦！</p>
<pre><code class="base">hexo clean
hexo g
hexo d</code></pre>
<h2 id="4-深坑"><a href="#4-深坑" class="headerlink" title="4.深坑"></a>4.深坑</h2><p>​        如果你是校园网用户的话，你要小心校园网DNS这个坑，会让你无法访问你自己的域名，所以解决方法就是修改我们的DNS就好了。</p>
<p>打开我们的控制面板—网络共享中心</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/8.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/9.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Hexo-Build/10.png" alt></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini创建地形原型搭建工具(二)</title>
    <url>/2020/11/29/Houdini%E5%88%9B%E5%BB%BA%E5%9C%B0%E5%BD%A2%E5%8E%9F%E5%9E%8B%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用curve搭建模型，搭配object_merge在UE4中进行地形的构建，可以在引擎中使用此工具达到快速搭建的效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130154350820.png" alt="image-20201130154350820"></p>
<a id="more"></a>

<h3 id="Fill-shape"><a href="#Fill-shape" class="headerlink" title="Fill shape"></a>Fill shape</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221017033.png" alt="image-20201128221017033"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221031137.png" alt="image-20201128221031137"></p>
<p>首先curve节点创建基本点，点击curve节点然后enter进入编辑模式，esc退出编辑模式</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221116432.png" alt="image-20201128221116432"></p>
<p>add节点进行补面</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221138646.png" alt="image-20201128221138646"></p>
<p>利用thicken进行挤出，polyBevel进行倒角，fuse融合接近的点，得到一个fill shape</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221438367.png" alt="image-20201128221438367"></p>
<h3 id="sweep"><a href="#sweep" class="headerlink" title="sweep"></a>sweep</h3><p>同样利用curve确定基本点，然后switch选择补面或者不补面，这影响到sweep结果是否封闭，最后选择circle作为横截面输入到sweep节点</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221517056.png" alt="image-20201128221517056"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221532620.png" alt="没有补面"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221707965.png" alt="补面"></p>
<h3 id="copy-shape"><a href="#copy-shape" class="headerlink" title="copy shape"></a>copy shape</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221824366.png" alt="image-20201128221824366"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221846392.png" alt="在curve线上生成"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128221940837.png" alt="在curve围成的面上生成"></p>
<h4 id="curve线上"><a href="#curve线上" class="headerlink" title="curve线上"></a>curve线上</h4><p>比较简单，利用resample节点增加curve线上的点数量即可</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128222109485.png" alt="image-20201128222109485"></p>
<h4 id="curve围成面"><a href="#curve围成面" class="headerlink" title="curve围成面"></a>curve围成面</h4><p>同样首先利用add节点封面，divide三角面化，subdivide细分</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129130324379.png" alt="image-20201129130324379"></p>
<p>利用distance from border营造一种边缘点数量少，点都聚集再网格中心的效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129130442126.png" alt="image-20201129130442126"></p>
<p>sactter散布点，将Cd属性改名为pscale属性，这是为了让生成的物体中心高，边缘低</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129130629108.png" alt="image-20201129130629108"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>为了能在ue4中编辑curve属性，需要在属性面板将curve节点暴露出来</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129130810912.png" alt="image-20201129130810912"></p>
<p>剩下的看自己需求来暴露节点的属性进行修改了。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129130852851.png" alt="image-20201129130852851"></p>
<p>obejct_merge的Input类型要选择为Asset Input，因为我们的原型搭建工具是HDA</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129131147266.png" alt="image-20201129131147266"></p>
<p>最后结果，UE4的地形就能根据你摆放的原型搭建工具进行改变</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201129131236728.png" alt="image-20201129131236728"></p>
]]></content>
      <categories>
        <category>Houdini</category>
      </categories>
      <tags>
        <tag>Houdini</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini创建通道和铁路(三)</title>
    <url>/2020/11/30/Houdini%E5%88%9B%E5%BB%BA%E9%80%9A%E9%81%93%E5%92%8C%E9%93%81%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先利用curve节点绘制出道路和铁路的路径轨迹，利用ray节点将曲线投射在地形的表面，根据投射得到的Mask对道路和铁路的地形进行修改，最后copy to points节点将石块和铁轨放置在点上。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130154350820.png" alt="image-20201130154350820"></p>
<a id="more"></a>

<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130131722045.png" alt="image-20201130131722045"></p>
<h3 id="curve曲线投射地形"><a href="#curve曲线投射地形" class="headerlink" title="curve曲线投射地形"></a>curve曲线投射地形</h3><p>curve节点绘制出道路和铁路的基本形状</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130124839080.png" alt="image-20201130124839080"></p>
<p>ray节点将曲线投射在地形上，在此之前要将HeightField转换为geometry</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130125041029.png" alt="image-20201130125041029"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130125057280.png" alt="image-20201130125057280"></p>
<h3 id="利用投射曲线创造Mask并修改Mask地形"><a href="#利用投射曲线创造Mask并修改Mask地形" class="headerlink" title="利用投射曲线创造Mask并修改Mask地形"></a>利用投射曲线创造Mask并修改Mask地形</h3><p>curve节点随便构建一个用于sweep的横截面，要在前视图创建曲线，根据需求用Transfrom对曲线进行scale的修改</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130125402354.png" alt="image-20201130125402354"></p>
<p>sweep得到的图形</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130125457068.png" alt="image-20201130125457068"></p>
<p>为了让sweep构成的图形朝上的方向为Y轴，可能是为了平面更平，需要修改一下选项（虽然我也不知道这些东西有啥用）</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130131102923.png" alt="image-20201130131102923"></p>
<p>接下来就可以maskByObject得到道路和铁路的Mask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130131701548.png" alt="image-20201130131701548"></p>
<p>用project节点将道路和铁路的object投射到地形上，造成地形的不平坦</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130131939120.png" alt="image-20201130131939120"></p>
<p>可以看到project造成的地形拉起有一点过于明显，需要blur模糊一下</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130132129245.png" alt="image-20201130132129245"></p>
<p>同样mask遮罩也过于生硬，用maskblur进行模糊</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130132210644.png" alt="image-20201130132210644"></p>
<p>接下来就可以为道路和铁路的地形添加noise细节，更多的不平坦效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130132326994.png" alt="image-20201130132326994"></p>
<p>用blend混合模式来混合原有地形和noise地形的结合</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130132417556.png" alt="image-20201130132417556"></p>
<p>最后要对mask的区域进行erode侵蚀效果处理，由于我们只想要mask地区进行侵蚀而非全部heightField，我们需要blast节点删除我们不需要的信息层。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130142430191.png" alt="image-20201130142430191"></p>
<p>同时早erode节点开启mask on表示使用mask，否则还是会应用到全地形</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130142519084.png" alt="image-20201130142519084"></p>
<p>接下来就是将计算出来的mask层存储为Layer_03层级，在此之前我们需要将mask减去一些层级信息，最后maskclear</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130142753497.png" alt="image-20201130142753497"></p>
<p>地形就能处理好了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130142854698.png" alt="image-20201130142854698"></p>
<h3 id="利用点生成石块和铁轨"><a href="#利用点生成石块和铁轨" class="headerlink" title="利用点生成石块和铁轨"></a>利用点生成石块和铁轨</h3><p>同样先将我们的曲线resample，得到更多的点，可以修改Treat Polygons As 方法得到更加平滑的曲线</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130143101334.png" alt="image-20201130143101334"></p>
<p>利用rand函数随机删除几个点，达到不规则的效果，其次为了让物体跟随曲线的旋转而旋转，需要添加orientalongcurve节点计算，得到属性N和up，这两个属性共同控制物体的朝向和旋转，如果不这样做，就会出现一下错误结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130143712900.png" alt="错误结果"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130143754077.png" alt="正确结果"></p>
<p>同时为了让生成物体更好的卡在地形表面而非被地形淹没，我们需要将地形转换为geometry然后smooth重新计算法线，将法线N更改为up，attributetransfer将地形的up传递给曲线的up属性，这样得到的效果会更好</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130144120978.png" alt="image-20201130144120978"></p>
<p>同理铁路也一样的处理方式，最后我们可以利用Mask在道路和铁路周围散布植物的点云。</p>
<p>首先利用blur节点的expand方法将layer_03往外扩一点</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130144348579.png" alt="image-20201130144348579"></p>
<p>再减去利用maskByfeature得到的斜坡遮罩，最后减去layer_03得到植物的mask遮罩，scatter散布点即可</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130144520872.png" alt="image-20201130144520872"></p>
<p>生成模型合并在一起，得到最后结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130153048776.png" alt="image-20201130153048776"></p>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>OutPut总共分为3个，一个输出地形，一个输出生成的模型，一个输出点云</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130153318367.png" alt="image-20201130153318367"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130153328375.png" alt="image-20201130153328375"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130153338818.png" alt="image-20201130153338818"></p>
]]></content>
      <categories>
        <category>Houdini</category>
      </categories>
      <tags>
        <tag>Houdini</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini利用基本形状构建地形(一)</title>
    <url>/2020/11/28/Houdini%E5%88%A9%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%BD%A2%E7%8A%B6%E6%9E%84%E5%BB%BA%E5%9C%B0%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Houdini官方教程笔记，随手记录，会比较乱</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201130154350820.png" alt="image-20201130154350820"></p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>主要利用box搭建原型，然后细化，最后分层Mask导出</p>
<h3 id="利用HeightFieldProject投射构建基本地形"><a href="#利用HeightFieldProject投射构建基本地形" class="headerlink" title="利用HeightFieldProject投射构建基本地形"></a>利用HeightFieldProject投射构建基本地形</h3><p>首先利用box或者其他网格节点merge成自己想要的地形形状</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161006105.png" alt="image-20201128161006105"></p>
<p>得到结果，这里project的Max，根据你的网格进行拉伸</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161116638.png" alt="image-20201128161116638"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161023938.png" alt="image-20201128161023938"></p>
<p>也可以利用project的Mini进行网格映射的下沉，可以选择是否勾选HitFarthest，就是以最远面还是最近面来作为投射的结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161227502.png" alt="image-20201128161227502"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161238029.png" alt="image-20201128161238029"></p>
<p>得到基本的形状，然后就可以在这个基础上进行侵蚀，模糊等等操作</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161429075.png" alt="image-20201128161429075"></p>
<h3 id="基本地形的继续细化"><a href="#基本地形的继续细化" class="headerlink" title="基本地形的继续细化"></a>基本地形的继续细化</h3><p>使用blur会造成地形形状的软化缩小，所以为了在固定地形形状的前提下进行地形的blur，可以使用一下节点，<strong>Expand</strong>为扩大的意思，这样先扩大再blur即可保持基本形状的不变</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161854074.png" alt="image-20201128161854074"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128161913940.png" alt="image-20201128161913940"></p>
<p>接下来就是distort，添加noise让地形更加丰富</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128162230010.png" alt="image-20201128162230010"></p>
<p>得到的最终结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128162253237.png" alt="image-20201128162253237"></p>
<h3 id="模拟地形的侵蚀"><a href="#模拟地形的侵蚀" class="headerlink" title="模拟地形的侵蚀"></a>模拟地形的侵蚀</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128162505936.png" alt="image-20201128162505936"></p>
<p>利用erode模型流水和热力的侵蚀</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128162739054.png" alt="image-20201128162739054"></p>
<p>根据maskbyfeature来进行Slump坍塌侵蚀的模拟</p>
<h3 id="进行Mask分层"><a href="#进行Mask分层" class="headerlink" title="进行Mask分层"></a>进行Mask分层</h3><p>Mask层是在UE4中进行地形材质landscape的使用。首先我们要获得layer_02层，利用Mask by feature获得斜坡mask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128164755717.png" alt="image-20201128164755717"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128164804090.png" alt="image-20201128164804090"></p>
<p>再利用mask By feature 减去一些曲率mask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128164904279.png" alt="image-20201128164904279"></p>
<p>最后用copylayer将Mask层存储为layer_02层</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165104837.png" alt="image-20201128165104837"></p>
<p>再利用remap将Mask翻转同样操作得到Layer_01层，最后利用blast只保留我们需要的mask层信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165309831.png" alt="image-20201128165309831"></p>
<h3 id="赋予材质"><a href="#赋予材质" class="headerlink" title="赋予材质"></a>赋予材质</h3><p>这样导出到UE4时就可以自动赋予UE4材质而不需要手动去拉取材质了，但这个unreal_Material目前有Bug无法使用….</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165524432.png" alt="image-20201128165524432"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165405739.png" alt="image-20201128165405739"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165608747.png" alt="image-20201128165608747"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201128165620882.png" alt="image-20201128165620882"></p>
]]></content>
      <categories>
        <category>Houdini</category>
      </categories>
      <tags>
        <tag>Houdini</tag>
      </tags>
  </entry>
  <entry>
    <title>Houdini地形总结</title>
    <url>/2020/11/11/Houdini%E5%9C%B0%E5%BD%A2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201112104702922.png" alt="image-20201112104702922"></p>
<a id="more"></a>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先利用HoudiniField 创建基本地形，HeightFieldNoise 对地形进行扰动，HeightFieldDistort对地形再次轻微扭曲失真添加细节，最后用HeightFieldErode模拟水力侵蚀和热力侵蚀。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111205217529.png" alt="image-20201111205217529"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111205229801.png" alt="image-20201111205229801"></p>
<p>利用HeightField slump 和HeightField flow 获取泥土坍塌堆积和水流流向Mask贴图，由于这两个节点的OutLayout名字都叫flowdir，为避免重复，需要用到heightField copylayout和heightfield Layer重新传递图层信息。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111205730008.png" alt="image-20201111205730008"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111205741959.png" alt="image-20201111205741959"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111205755804.png" alt="image-20201111205755804"></p>
<p>利用maskByfeature，顾名思义是利用地形特点获取mask图，这里先获取平坦地面的mask图，然后利用blur和noise节点为平坦地面添加凹凸细节</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111211908052.png" alt="image-20201111211908052"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111211844494.png" alt="image-20201111211844494"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111212100019.png" alt="image-20201111212100019"></p>
<h3 id="开始构造岩石，土壤，草地Mask"><a href="#开始构造岩石，土壤，草地Mask" class="headerlink" title="开始构造岩石，土壤，草地Mask"></a>开始构造岩石，土壤，草地Mask</h3><p> 底层是岩石，中间是土壤，最上层是草地，三者互不重叠</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201105144214013.png" alt="image-20201105144214013"></p>
<h4 id="草地"><a href="#草地" class="headerlink" title="草地"></a>草地</h4><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213252547.png" alt="image-20201111213252547"></p>
<p>首先利用maskByFeature节点获取平坦地方的Mask，只用到了坡度来获取Mask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111212520982.png" alt="image-20201111212520982"></p>
<p>可以法线获取到的Mask存在瑕疵，居然山顶上也有Mask，所以我还需要下一个maskByFeature进行处理</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111212556907.png" alt="image-20201111212556907"></p>
<p>这里模式为Subtract，即用上一个Mask图减去此节点得到的Mask，这里用到了Height和Valleys</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111212751592.png" alt="image-20201111212751592"></p>
<p>可以看到效果好了许多，得到最基本的GrassMask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111212837053.png" alt="image-20201111212837053"></p>
<h4 id="土壤"><a href="#土壤" class="headerlink" title="土壤"></a>土壤</h4><p>土壤利用flow层级信息获取最基本的土壤信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213235215.png" alt="image-20201111213235215"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213322478.png" alt="image-20201111213322478"></p>
<h4 id="岩石"><a href="#岩石" class="headerlink" title="岩石"></a>岩石</h4><p>岩石基础Mask比较简单，因为岩石是最底层，所以肯定为1全部覆盖，用maskbyClear即可得到</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214259233.png" alt="image-20201111214259233"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214246075.png" alt="image-20201111214246075"></p>
<h4 id="土壤和草地混合Mask"><a href="#土壤和草地混合Mask" class="headerlink" title="土壤和草地混合Mask"></a>土壤和草地混合Mask</h4><p>为了得到更加随机混合的效果，我们需要将之前得到的土壤和草地BaseMask进行合并</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213512156.png" alt="image-20201111213512156"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213458102.png" alt="image-20201111213458102"></p>
<p>得到效果如下</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213545071.png" alt="image-20201111213545071"></p>
<p>依然利用blur，remap获取一个新的草地Mask，然后利用maskByFeature的Valleys去除一部分草地的Mask</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213902857.png" alt="image-20201111213902857"></p>
<p>得到的最终草地Mask，土壤Mask用合并的Mask再减去新的草地Mask即可得到</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111213959576.png" alt="最终草地Mask"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214029285.png" alt="最终土壤Mask"></p>
<p>岩石Mask也是减去土壤和草地合并Mask即可得到</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214138824.png" alt="最终岩石Mask"></p>
<h4 id="存储得到的rock，soil，grass层级信息"><a href="#存储得到的rock，soil，grass层级信息" class="headerlink" title="存储得到的rock，soil，grass层级信息"></a>存储得到的rock，soil，grass层级信息</h4><p>利用copyLayout来生成新的层级来存储Mask，然后利用HeightFieldLayout存储刚才得到的层级信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214453245.png" alt="image-20201111214453245"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214537997.png" alt="image-20201111214537997"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111214723898.png" alt="image-20201111214723898"></p>
<h3 id="开始散布点"><a href="#开始散布点" class="headerlink" title="开始散布点"></a>开始散布点</h3><p>树肯定是分布在grass层级，所以我们要在grass层级上copy生成一个tree层级，然后scatter散布点</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215158189.png" alt="image-20201111215158189"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215205219.png" alt="tree层级"></p>
<p>利用HeightFieldScatter进行点的散布</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215315583.png" alt="image-20201111215315583"></p>
<p>这里根据CoverageMask进行覆盖，Coverage调整覆盖度（数量），剩下的OuterRadius和Falloff不大清楚是用来干嘛的，iteration大概是点生成的迭代次数，迭代越多越精准</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215352253.png" alt="image-20201111215352253"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215715422.png" alt="得到效果"></p>
<p>散布完树的点之后，就要散布灌木，这里注意Tag名称，由于我们规定灌木要生长在树的周边，而我们之前生成好的树点都带有tree标签，我们根据Tag进行生成即可</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215813278.png" alt="image-20201111215813278"></p>
<p>分别控制生成数量，生成范围，生成大小</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111215954770.png" alt="image-20201111215954770"></p>
<p>其他物体的生成也是如此推算即可。</p>
<h3 id="生成HDA导入到UE4"><a href="#生成HDA导入到UE4" class="headerlink" title="生成HDA导入到UE4"></a>生成HDA导入到UE4</h3><p>首先把全部节点打包为一个subnet，右键生成HDA</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220320744.png" alt="image-20201111220320744"></p>
<p>可以暴露参数到UE4里面进行修改</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220422258.png" alt="image-20201111220422258"></p>
<p>这里暴露了HeightField的Size和GridSpace属性，这样在UE4就可以修改地形的大小</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220440315.png" alt="image-20201111220440315"></p>
<p>在UE4引擎中开启Houdini插件即可，<strong>注意：需要安装对应版本的Houdini才会有这个插件出现</strong></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220624308.png" alt="image-20201111220624308"></p>
<h3 id="地形材质LandScape"><a href="#地形材质LandScape" class="headerlink" title="地形材质LandScape"></a>地形材质LandScape</h3><p>主要用到节点LandScapeUV，LayerBlend</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220820996.png" alt="image-20201111220820996"></p>
<p>这里对应的图层信息为Houdini的图层名称，否则会出错</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111220846653.png" alt="image-20201111220846653"></p>
<p>这里我学到一个新的种草技能，利用LandScapeOutPut进行物体的在指定图层的摆放。这里就在Grass种草和种花</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111221039097.png" alt="image-20201111221039097"></p>
<p>需要landSpaceGrassTye</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111221205436.png" alt="image-20201111221205436"></p>
<h3 id="进行模型的替换"><a href="#进行模型的替换" class="headerlink" title="进行模型的替换"></a>进行模型的替换</h3><p>这里有两种选择，一种在UE4进行手动替换</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111221407109.png" alt="image-20201111221407109"></p>
<p>第二种在Houdini里用代码规定好，例如利用attributeCreate规定地形的材质，利用AttributeWrangle设定模型</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111221516447.png" alt="image-20201111221516447"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201111221842452.png" alt="image-20201111221842452"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Houdini地形创建先创造基本地形，然后利用各种Mask节点来构造土壤，岩石，草地的Mask分层，最后利用HeightFieldScatter进行点的散布，导进UE4进行地形材质的构造，种草种花完美结束。</p>
]]></content>
      <categories>
        <category>Houdini</category>
      </categories>
      <tags>
        <tag>Houdini</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(一)</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="创建项目和基本操作"><a href="#创建项目和基本操作" class="headerlink" title="创建项目和基本操作"></a>创建项目和基本操作</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00005.png" alt="HighresScreenshot00005"></p>
<a id="more"></a>

<p>左上角文件 — 新建，因为我打算把贴图到UE4尝试，所以选择的模板为UE4</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201110539670.png" alt="image-20201201110539670"></p>
<p>Alt + 鼠标左键旋转视图    Alt + 鼠标滚轮平移视图    Shift + 右键旋转HDR环境改变光照</p>
<h2 id="玻璃材质"><a href="#玻璃材质" class="headerlink" title="玻璃材质"></a>玻璃材质</h2><p>纹理集列表就是在三维软件中设置的材质ID，你分了多少个材质，在SP就会显示多少个</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201111210864.png" alt="image-20201201111210864"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201111454415.png" alt="image-20201201111454415"></p>
<p>为glass材质新建一个Shader重命名为Glass，并且在纹理集设置添加opaticy通道</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201111611371.png" alt="image-20201201111611371"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201111754424.png" alt="image-20201201111754424"></p>
<p>因为Glass shader使用的还是pbr-meta-rough并不会造成透明效果，所以我们要在着色器设置里修改为pbr-metal-rough-with-alpha-blending</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201111947608.png" alt="image-20201201111947608"></p>
<p>接下来新建一个填充图层，并且只输出opacity通道</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201112044502.png" alt="image-20201201112044502"></p>
<p>达到效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201112056726.png" alt="image-20201201112056726"></p>
<h2 id="烘焙贴图"><a href="#烘焙贴图" class="headerlink" title="烘焙贴图"></a>烘焙贴图</h2><p>纹理集设置 — 烘焙贴图，由于我们没有高模，所以没必要烘焙Normal，厚度贴图要用到的地方比如次表面散射，所以不必要烘焙，同时为了烘焙材质ID贴图，所以教程特意复制了一个同样的模型，并为模型赋予基本颜色</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201113416434.png" alt="image-20201201113416434"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201113709879.png" alt="image-20201201113709879"></p>
<h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><p>由于我们选择的烘焙方式是默认烘焙，所以会容易出现投射错误</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201113921529.png" alt="ID"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201113944633.png" alt="曲率"></p>
<p>所以我们要修改Match方式为By Mesh，按照Mesh来进行投射烘焙，他对于模型的匹配时根据后缀来进行的，所以命名一定要规范，不然会错误</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201114222490.png" alt="image-20201201114222490"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201114243344.png" alt="命名规范"></p>
<p>得到正确的结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201114503788.png" alt="image-20201201114503788"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>Maya简易控制器</title>
    <url>/2020/08/24/Maya%E7%AE%80%E6%98%93%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<p>Maya教程笔记，过程中会记录自己所遇到的问题和新知识</p>
<a id="more"></a>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>控制器的简易添加，缩放控制器，控制器的颜色选择</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/GIF%202020-8-24%2022-52-16.gif" alt="GIF 2020-8-24 22-52-16"></p>
<h2 id="QLabel"><a href="#QLabel" class="headerlink" title="QLabel"></a>QLabel</h2><p>QLabel提供了一个文本或者图像的显示，没有提供交互功能，在建议控制器中我利用QLabel进行了文字的显示和背景颜色显示</p>
<pre><code>self.controlScale_label = QtWidgets.QLabel(u&quot;控制器Scale&quot;,alignment=QtCore.Qt.AlignCenter)
#设置格式
self.controlScale_label.setStyleSheet(&quot;background-color:rgb(0,0,0,255)&quot;)</code></pre><h2 id="Constraints-约束"><a href="#Constraints-约束" class="headerlink" title="Constraints(约束)"></a>Constraints(约束)</h2><p>point constraints（点约束）：约束位移</p>
<p>orient constraints（反向约束）：约束旋转</p>
<p>parent constraints（父约束）：约束位移和旋转</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>1.首先要获取选中的物体，然后判断是否为joint骨骼类型，如果是则获取选中物体的所有子物体
2.根据joint数量生成一定的控制器，调整控制器的旋转和位置与joint一致
3.进行parent约束限制，这样生成的Circle就可以控制joints
4.利用Pyside2进行GUI的设置，完成交互</code></pre><h2 id="OverrideColor设置问题"><a href="#OverrideColor设置问题" class="headerlink" title="OverrideColor设置问题"></a>OverrideColor设置问题</h2><p>首先OverrideColor指的是Shape下的设置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20200824230019419.png" alt="image-20200824230019419"></p>
<p>这里我需要将颜色设置为RGB而非索引，所以需要一下代码,这里应该可以直接设置overrideColorRGB属性的，但不知道哪里出了问题，所以我就曲线救国</p>
<pre><code>            #获取选中物体的shape
            shape = cmds.listRelatives(tempControl,children=True)[0]
            cmds.setAttr(shape+&quot;.overrideEnabled&quot;,True)
            cmds.setAttr(shape+&quot;.overrideRGBColors&quot;,1)

            #设置颜色值
            cmds.setAttr(shape+&quot;.overrideColorR &quot;,self.color.redF())
            cmds.setAttr(shape + &quot;.overrideColorG &quot;, self.color.greenF())
            cmds.setAttr(shape + &quot;.overrideColorB &quot;, self.color.blueF())
            #print(cmds.getAttr(shape+&quot;.overrideColor&quot;))</code></pre><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20200824230220071.png" alt="image-20200824230220071"></p>
<h2 id="Circle-Scale问题"><a href="#Circle-Scale问题" class="headerlink" title="Circle Scale问题"></a>Circle Scale问题</h2><p>这里不是直接缩放Circle，而是缩放Circle的controlVertics（控制顶点），这样就可以直接连续缩放</p>
<pre><code>    def smallScale(self):
        #获得选中的物体
        selectionControl = cmds.ls(selection=True)
        #获取缩放值
        scaleFactor = self.scale_DoubleSpinBox.value()
        for tempControl in selectionControl:
            # Scale控制顶点
            cmds.scale(1-scaleFactor,1-scaleFactor,1-scaleFactor,tempControl+&quot;.cv[0:]&quot;)</code></pre><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code># -*- coding: GBK -*-
from PySide2 import QtWidgets,QtGui,QtCore
from shiboken2 import wrapInstance
from maya import OpenMayaUI as omui
import maya.cmds as cmds

#maya主窗口
def maya_main_window():
    main_window_ptr = omui.MQtUtil.mainWindow()
    return wrapInstance(long(main_window_ptr),QtWidgets.QWidget)

window_w = 200
window_h = 168


class RigTools_Dialog(QtWidgets.QDialog):

    def __init__(self,parent = maya_main_window()):
        super(RigTools_Dialog, self).__init__(parent)
        #设置默认颜色
        self.color = QtGui.QColor(&quot;#FFFFFF&quot;)
        self.control_list=[]
        self.offset_list=[]

        #设置窗口名称
        self.setWindowTitle(&quot;RigTools&quot;)
        #设置窗口大小
        self.setFixedWidth(window_w)
        self.setFixedHeight(window_h)
        #关闭问号按钮
        self.setWindowFlags(self.windowFlags() ^ QtCore.Qt.WindowContextHelpButtonHint)

        self.createWidgets()
        self.createLayouts()
        self.createConnects()


    def createWidgets(self):
        self.rig_btn = QtWidgets.QPushButton(&quot;Rig&quot;)
        self.rig_btn.setFixedWidth(window_w)
        self.rig_btn.setFixedHeight(40)

        self.controlScale_label = QtWidgets.QLabel(u&quot;控制器Scale&quot;,alignment=QtCore.Qt.AlignCenter)
        #设置格式
        self.controlScale_label.setStyleSheet(&quot;background-color:rgb(0,0,0,255)&quot;)

        self.scale_DoubleSpinBox = QtWidgets.QDoubleSpinBox()
        #设置范围，经度，步长
        self.scale_DoubleSpinBox.setRange(0,1)
        self.scale_DoubleSpinBox.setDecimals(2)
        self.scale_DoubleSpinBox.setSingleStep(0.05)
        self.smallScale_btn = QtWidgets.QPushButton(&quot;Small&quot;)
        self.bigScale_btn = QtWidgets.QPushButton(&quot;Big&quot;)

        self.controlColor_label = QtWidgets.QLabel(u&quot;控制器颜色&quot;,alignment=QtCore.Qt.AlignCenter)
        self.controlColor_label.setStyleSheet(&quot;background-color:rgb(0,0,0,255)&quot;)

        self.color_pick_label = QtWidgets.QLabel()
        self.color_pick_label.setStyleSheet(&quot;background-color:rgb(255,255,255,255)&quot;)
        self.color_pick_btn = QtWidgets.QPushButton(u&quot;颜色选择&quot;)

        self.color_set_btn = QtWidgets.QPushButton(u&quot;颜色设置&quot;)


        pass

    def createLayouts(self):
        #主层级
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setMargin(0)
        main_layout.setSpacing(0)

        main_layout.addWidget(self.rig_btn)

        main_layout.addWidget(self.controlScale_label)

        HLayout = QtWidgets.QHBoxLayout()
        main_layout.setSpacing(5)
        HLayout.addWidget(self.scale_DoubleSpinBox)
        HLayout.addWidget(self.smallScale_btn)
        HLayout.addWidget(self.bigScale_btn)
        main_layout.addLayout(HLayout)

        main_layout.addWidget(self.controlColor_label)

        H_Color_Layout = QtWidgets.QHBoxLayout()
        H_Color_Layout.addWidget(self.color_pick_label)
        H_Color_Layout.addWidget(self.color_pick_btn)
        main_layout.addLayout(H_Color_Layout)

        main_layout.addWidget(self.color_set_btn)

        pass

    def createConnects(self):
        self.rig_btn.clicked.connect(self.rig_function)
        self.smallScale_btn.clicked.connect(self.smallScale)
        self.bigScale_btn.clicked.connect(self.bigScale)
        self.color_pick_btn.clicked.connect(self.color_pick)
        self.color_set_btn.clicked.connect(self.color_set)

    def smallScale(self):
        #获得选中的物体
        selectionControl = cmds.ls(selection=True)
        #获取缩放值
        scaleFactor = self.scale_DoubleSpinBox.value()
        for tempControl in selectionControl:
            # Scale控制顶点
            cmds.scale(1-scaleFactor,1-scaleFactor,1-scaleFactor,tempControl+&quot;.cv[0:]&quot;)
        pass

    def bigScale(self):
        # 获得选中的物体
        selectionControl = cmds.ls(selection=True)
        # 获取缩放值
        scaleFactor = self.scale_DoubleSpinBox.value()
        print(scaleFactor)
        for tempControl in selectionControl:
            #Scale控制顶点
            cmds.scale(1.0 + scaleFactor, 1.0 + scaleFactor, 1.0 + scaleFactor, tempControl+&quot;.cv[0:]&quot;)

        pass

    def color_pick(self):
        #获取颜色选择
        color = QtWidgets.QColorDialog.getColor()
        self.color = color
        self.color_pick_label.setStyleSheet(&quot;background-color: {0}&quot;.format(color.name()))

    def color_set(self):
        #获取选中的物体
        selectionControl = cmds.ls(selection=True)
        #设置颜色值
        for tempControl in selectionControl:
            #获取选中物体的shape
            shape = cmds.listRelatives(tempControl,children=True)[0]
            cmds.setAttr(shape+&quot;.overrideEnabled&quot;,True)
            cmds.setAttr(shape+&quot;.overrideRGBColors&quot;,1)

            #设置颜色值
            cmds.setAttr(shape+&quot;.overrideColorR &quot;,self.color.redF())
            cmds.setAttr(shape + &quot;.overrideColorG &quot;, self.color.greenF())
            cmds.setAttr(shape + &quot;.overrideColorB &quot;, self.color.blueF())
            #print(cmds.getAttr(shape+&quot;.overrideColor&quot;))
        pass


    def rig_function(self):
        # 获取选中的物体
        selected = cmds.ls(selection=True)

        # 判断选择物体是否为空
        if len(selected) == 0:
            cmds.warning(u&quot;请选中物体!!!&quot;)
            QtWidgets.QMessageBox.warning(self,u&quot;警告&quot;,u&quot;请选中物体!!!&quot;)
        elif len(selected) &gt; 1:
            cmds.warning(u&quot;只能选中一个物体！！！&quot;)
            QtWidgets.QMessageBox.warning(self, u&quot;警告&quot;, u&quot;只能选中一个物体！！！&quot;)
        else:
            # 判断类型是否为joint骨骼
            if cmds.objectType(selected[0]) != &quot;joint&quot;:
                cmds.warning(u&quot;选择物体类型不为joint！！！&quot;)
                QtWidgets.QMessageBox.warning(self, u&quot;警告&quot;, u&quot;选择物体类型不为joint！！！&quot;)

            else:
                # 选择该物体的包含的所有子物体和自身
                cmds.select(selected[0], hierarchy=True)
                # 获取选择的物体
                all_Joints = cmds.ls(selection=True)
                # 骨骼数
                joints_number = len(all_Joints)


                # 循环生成circle控制器
                for i in range(joints_number - 1):
                    # 生成circle
                    control = cmds.circle(name=all_Joints[i] + &quot;_control&quot;)
                    # 旋转变换
                    cmds.rotate(0, 90, 0, control[0])

                    # 冻结变换
                    cmds.makeIdentity(apply=True)
                    # 删除变换历史
                    cmds.DeleteHistory()

                    # 创建group组
                    offset_grp = cmds.group(name=all_Joints[i] + &quot;_offset&quot;, empty=True)
                    # 设置父类
                    cmds.parent(control[0], offset_grp)

                    # 获取骨骼的位置Position
                    joint_position = cmds.xform(all_Joints[i], query=True, translation=True, worldSpace=True)
                    # 将控制器移动到骨骼位置
                    cmds.xform(offset_grp, translation=joint_position)

                    # 利用orient约束将圆环旋转到骨骼方向一致
                    orient_cons = cmds.orientConstraint(all_Joints[i], offset_grp)
                    # 删除旋转约束
                    cmds.delete(orient_cons)

                    # parent约束，用于控制器控制骨骼移动
                    cmds.parentConstraint(control[0], all_Joints[i])

                    # 添加到list
                    self.control_list.append(control[0])
                    self.offset_list.append(offset_grp)

                # 重新设置父类关系
                for i in range(joints_number - 2):
                    cmds.parent(self.offset_list[i + 1], self.control_list[i])


if __name__ == &#39;__main__&#39;:
    try:
        rigTools_dialog.close()
        rigTools_dialog.deleteLater()
    except:
        pass

    rigTools_dialog = RigTools_Dialog()
    rigTools_dialog.show()</code></pre>]]></content>
      <categories>
        <category>Maya</category>
      </categories>
      <tags>
        <tag>Maya</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(三)</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/</url>
    <content><![CDATA[<h2 id="完成漆面材质和创建铁锈材质"><a href="#完成漆面材质和创建铁锈材质" class="headerlink" title="完成漆面材质和创建铁锈材质"></a>完成漆面材质和创建铁锈材质</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00005.png" alt="HighresScreenshot00005"></p>
<a id="more"></a>

<h3 id="灯光效果"><a href="#灯光效果" class="headerlink" title="灯光效果"></a>灯光效果</h3><p>新建一个灯光效果填充，并添加Light生成器，将灯源的角度为从上往下投射，将灯光效果图层混合效果改为Value(这可能就是艺术家的直觉吧)</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201144027771.png" alt="image-20201201144027771"></p>
<p>灯光太平了，添加noise细节</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201144227025.png" alt="image-20201201144227025"></p>
<p>最后为了让灯光效果集中在某些区域，添加生成器dirt来限制区域</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201144538852.png" alt="image-20201201144538852"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201144643555.png" alt="image-20201201144643555"></p>
<h3 id="铁锈效果"><a href="#铁锈效果" class="headerlink" title="铁锈效果"></a>铁锈效果</h3><p>首先我们需要导入外部素材，添加好标签方便查询</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201145231806.png" alt="image-20201201145231806"></p>
<p>新建一个文件夹为Rust，在Rust文件夹下新建base基础颜色填充图层，只输出color，height，rought。ao通道，将导入的贴图进行应用</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201152233485.png" alt="image-20201201152233485"></p>
<p>可以看到凹凸效果过于强烈，由于height贴图已经应用，没有数值可以修改，我们可以通过图层的height来修改比例，效果就好很多了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201152339199.png" alt="image-20201201152339199"></p>
<p>可以看出Rust文件夹完全覆盖了PaintedMetal文件夹，所以需要遮罩进行修正</p>
<p>首先添加grunge Map 004 达到效果，这里不选用三面映射，是因为三面映射会造成模糊效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201154327236.png" alt="image-20201201154327236"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201154408898.png" alt="三面映射模糊"></p>
<p>继续添加细节noise，这里选用的是grunge concrete old ，混合模式为Max，取最亮</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201154550759.png" alt="image-20201201154550759"></p>
<p>可以看出铁锈的区域有点多，我们可以添加生成器light限制铁锈的区域，混合模式为Mul</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201154701956.png" alt="image-20201201154701956"></p>
<p>现在铁锈的效果是分散的，添加dirt生成器让铁锈效果更加集中一些，混合效果同样为Max</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201185618247.png" alt="image-20201201185618247"></p>
<p>再添加边缘细节，同样为利用mask editor自带的两个Texture接口可以为边缘添加noise细节，以及为竖面添加划痕</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201194232328.png" alt="image-20201201194232328"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201194255305.png" alt="image-20201201194255305"></p>
<p>最后为Rust的基础颜色添加HSL滤镜因为教程老师觉得颜色过于饱和了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201194338431.png" alt="image-20201201194338431"></p>
<h2 id="智能材质的应用和图层链接"><a href="#智能材质的应用和图层链接" class="headerlink" title="智能材质的应用和图层链接"></a>智能材质的应用和图层链接</h2><p>只要把做好的材质转换为智能材质，就能应用到其他模型上面非常的方便，因为智能材质会根据模型的不同进行烘焙贴图的切换</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201195117599.png" alt="image-20201201195117599"></p>
<p>得到结果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201195620136.png" alt="image-20201201195620136"></p>
<h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><p>由于赋予的智能材质是各自为实例的，所以单独的修改不能影响全部的智能材质实例，比如我将底座的颜色改为红色，其他智能材质并不会改变</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201195801091.png" alt="image-20201201195801091"></p>
<h3 id="图层链接"><a href="#图层链接" class="headerlink" title="图层链接"></a>图层链接</h3><p>图层链接的诞生就是为了解决这个问题，右键图层—跨纹理图层链接，即可解决问题</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201200026950.png" alt="image-20201201200026950"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201201218569.png" alt="image-20201201201218569"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>Maya导出存储文件工具</title>
    <url>/2020/08/31/Maya%E5%AF%BC%E5%87%BA%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>笔记记录</p>
<a id="more"></a>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>保存场景为ma文件，并且可以加载，刷新等。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/GIF%202020-8-31%2015-49-31.gif" alt></p>
<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>主要逻辑在controllerLibrary.py脚本，save，find，load3个方法。创建ControllerLibrary类继承于dict字典类，数据存储name,path,screenshot的相关路径等等。</p>
<p>主要API：cmds.file()进行文件的存储和读取    cmds.viewFit():将摄像机对准物体    cmds.playblast():渲染导出图片    json.dump()：json文件的编码写入    json.load():json文件的解码读取</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20200831160940099.png" alt="image-20200831160940099"></p>
<pre><code>#-*-coding:gbk-*-

from maya import cmds
import os
import json
import pprint

#获取Maya文档路径
USERAPPDIR = cmds.internalVar(userAppDir=True)
#文件夹路径
DIRECTORY = os.path.join(USERAPPDIR, &quot;controllerLibrary&quot;)


def createDirectory(directory=DIRECTORY):
    &quot;&quot;&quot;
    根据文件路径创建文件夹
    Args:
        directory(str): 要创建的文件夹路径

    Returns:

    &quot;&quot;&quot;
    #首先判断文件夹是否存在
    if not os.path.exists(directory):
        #如果不存在那就创建文件夹
        os.mkdir(directory)


#继承字典类
class ControllerLibrary(dict):

    #保存文件方法
    #**info关键字参数
    def save(self,name,screenshot=True,directory=DIRECTORY,**info):

        #首先要确认要保存的路径是否存在
        createDirectory(directory)

        #保存文件路径
        path = os.path.join(directory,&quot;{0}.ma&quot;.format(name))
        #json保存文件
        infoFile = os.path.join(directory,&quot;{0}.json&quot;.format(name))
        info[&quot;name&quot;] = name
        info[&quot;path&quot;] = path

        #判是否需要screenShot
        if screenshot:
            self.saveScreenshot(name,directory)

        #进行场景文件的保存,保存格式为mayaAscii
        cmds.file(rename=path)

        #如果进行了选择，就单独保存选择了的物体场景
        if cmds.ls(selection=True):
            cmds.file(force=True,type=&quot;mayaAscii&quot;,exportSelected=True)

        #否则保存全部场景物体
        else:
            cmds.file(save=True,type=&quot;mayaAscii&quot;,force=True)

        #打开infoFile文件,保存为json格式,写入文件
        with open(infoFile,&quot;w&quot;) as f:
            json.dump(info,f,indent=4)

        self[name] = path

    #获得文件夹下的所有文件
    def find(self,directory=DIRECTORY):
        # 进行清空，避免删除.ma文件时没有更新
        self.clear()

        if not os.path.exists(directory):
            return None

        files = os.listdir(directory)

        #进行特定筛选，只获取ma文件
        mayaFiles = [f for f in files if f.endswith(&quot;.ma&quot;)]

        #进行键值对存储
        for ma in mayaFiles:
            #分离文件名和扩展名
            name,ext = os.path.splitext(ma)
            path = os.path.join(directory,ma)

            #查看是否json文件
            infoFile = &quot;{0}.json&quot;.format(name)
            if infoFile in files:
                infoFile = os.path.join(directory,infoFile)
                #读取每个场景配置的json文件
                with open(infoFile,&quot;r&quot;) as f:
                    #进行读取
                    info = json.load(f)

            else:
                print(u&quot;没有发现{0}文件&quot;.format(infoFile))
                info = {}

            #查看是否screenshot图片
            screenshot = &quot;{0}.jpg&quot;.format(name)
            if screenshot in files:
                info[&quot;screenshot&quot;] = os.path.join(directory,screenshot)

            info[&quot;name&quot;]=name
            info[&quot;path&quot;]=path

            self[name]=info
            #print(info)

    #加载
    def load(self,name):
        path = self[name][&quot;path&quot;]

        #进行加载
        cmds.file(path,i=True,usingNamespaces=False)

    #保存屏幕截图
    def saveScreenshot(self,name,directory=DIRECTORY):
        #确定图片保存的路径
        path = os.path.join(directory,&quot;{0}.jpg&quot;.format(name))

        #将摄像机对准物体，以方便进行截图
        cmds.viewFit()
        #确定保存图片格式为jpg
        cmds.setAttr(&quot;defaultRenderGlobals.imageFormat&quot;,8)

        #进行截图,这个相当于渲染命令
        &quot;&quot;&quot;
        completeFilename:导出图片的路径    forceOverwrite:是否覆盖现有的playblast     format:输出的格式
        width,heigt:分辨率     showOrnaments:是否显示轴坐标图      viewer:是否启动播放查看器
        &quot;&quot;&quot;
        cmds.playblast(completeFilename=path,forceOverwrite=True,format=&quot;image&quot;,width=200,height=200,
                       showOrnaments=False,startTime=1,endTime=1,viewer=False)

        return path

</code></pre><p>主要逻辑构建好，就可以构建UI了，UI构建在libraryUI.py中完成</p>
<pre><code>#-*-coding:gbk-*-

import controllerLibrary
from imp import reload
reload(controllerLibrary)
from PySide2 import QtWidgets,QtCore,QtGui
import maya.OpenMayaUI as omui
import maya.cmds as cmds
from shiboken2 import wrapInstance


#获取maya主窗口
def maya_main_window():
    main_window_ptr = omui.MQtUtil.mainWindow()
    return wrapInstance(long(main_window_ptr),QtWidgets.QWidget)


#ui类
class ControllerLibraryUI(QtWidgets.QDialog):

    #初始化
    def __init__(self,parent=maya_main_window()):
        super(ControllerLibraryUI, self).__init__(parent)
        self.library = controllerLibrary.ControllerLibrary()

        #图标size
        self.size = 64
        #格子Sizd
        self.buffer=12

        #设置窗口标题
        self.setWindowTitle(u&quot;控制Library窗口&quot;)
        #关闭问号按钮
        self.setWindowFlags(self.windowFlags() ^ QtCore.Qt.WindowContextHelpButtonHint)

        self.createWidgets()
        self.createLayouts()
        self.createConnects()

        #填充ListWidget
        self.populate()

    def createWidgets(self):
        self.save_btn = QtWidgets.QPushButton(&quot;save&quot;)
        self.saveName_lineEdit = QtWidgets.QLineEdit()

        #设置listWidget
        self.file_listWidget = QtWidgets.QListWidget()
        #图标模式
        self.file_listWidget.setViewMode(QtWidgets.QListWidget.IconMode)
        #设置图标大小
        self.file_listWidget.setIconSize(QtCore.QSize(self.size,self.size))
        #设置拉伸模式为Adjust
        self.file_listWidget.setResizeMode(QtWidgets.QListWidget.Adjust)
        #设置GridSize
        self.file_listWidget.setGridSize(QtCore.QSize(self.size+self.buffer,self.size+self.buffer))

        self.import_btn = QtWidgets.QPushButton(&quot;Import&quot;)
        self.refresh_btn = QtWidgets.QPushButton(&quot;Refresh&quot;)
        self.close_btn = QtWidgets.QPushButton(&quot;Close&quot;)

    def createLayouts(self):
        main_layout = QtWidgets.QVBoxLayout(self)

        save_layout = QtWidgets.QHBoxLayout()
        save_layout.addWidget(self.saveName_lineEdit)
        save_layout.addWidget(self.save_btn)
        main_layout.addLayout(save_layout)

        main_layout.addWidget(self.file_listWidget)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_layout.addWidget(self.import_btn)
        btn_layout.addWidget(self.refresh_btn)
        btn_layout.addWidget(self.close_btn)
        main_layout.addLayout(btn_layout)



    def createConnects(self):
        self.save_btn.clicked.connect(self.save)

        self.import_btn.clicked.connect(self.load)
        self.refresh_btn.clicked.connect(self.populate)
        self.close_btn.clicked.connect(self.close)

    def populate(self):

        #清空file_list，避免重复增加
        self.file_listWidget.clear()
        #获取Directory文件夹下经过筛选的文件
        self.library.find()

        #获取键值对
        for name,info in self.library.items():
            #创建ListWidegtItem
            item = QtWidgets.QListWidgetItem(name)
            #添加到file_listWidget
            self.file_listWidget.addItem(item)

            #查看是否有截图
            screenshot = info.get(&quot;screenshot&quot;)
            if screenshot:
                icon = QtGui.QIcon(screenshot)
                item.setIcon(icon)

    def load(self):
        #获取当前选中的ListWidgetItem
        currentItem = self.file_listWidget.currentItem()
        #如果没有选中，则弹出警告
        if not currentItem:
            QtWidgets.QMessageBox.warning(self,&quot;warning&quot;,u&quot;请选择文件！！&quot;)
            return

        self.library.load(currentItem.text())

    def save(self):
        #首先获取lineEdit的str
        name = self.saveName_lineEdit.text()

        #去除name的首尾空格
        if not name.strip():
            QtWidgets.QMessageBox.warning(self,&quot;warning&quot;,u&quot;名字不合法！！&quot;)
            return

        self.library.save(name)
        #重新更新ListWidget
        self.populate()
        #重置LineEdit
        self.saveName_lineEdit.setText(&quot;&quot;)


def showUI():
    ui = ControllerLibraryUI()
    ui.show()

    return ui</code></pre><h2 id="QListView和QListWidget的区别"><a href="#QListView和QListWidget的区别" class="headerlink" title="QListView和QListWidget的区别"></a>QListView和QListWidget的区别</h2><p>我上次搞图片快速分类工具的时候，对于图片文件的预览我使用了QListView来进行数据的展示。这次我用QListWidget列表展示数据，那么他们到底有什么不一样呢？</p>
<p><strong>QlistView类用于展示数据，它的子类是QListWIdget。QListView是基于模型（Model）的，需要程序来建立模型，然后再保存数据。QListWidget是一个升级版本的QListView，它已经建立了一个数据储存模型（QListWidgetItem），直接调用addItem（）函数，就可以添加条目（Item）</strong></p>
<p>图片快速分类中QlistView的使用</p>
<pre><code>        #创建QFileSystemModel
        #QFileSystemModel是一个维护文件目录内容信息的模型，它本身不包含任何数据项，而只是表示本地文件系统上的文件和目录。
        self.file_model = QtWidgets.QFileSystemModel()
        #设置过滤器
        self.file_model.setNameFilters(self.FILTERS)
        #隐藏过滤掉的文件
        self.file_model.setNameFilterDisables(False)
        #设置Model
        self.ui.image_list_view.setModel(self.file_model)
</code></pre><p>存储导入工具中QListWidget的使用</p>
<pre><code>        #设置listWidget
        self.file_listWidget = QtWidgets.QListWidget()
        #图标模式
        self.file_listWidget.setViewMode(QtWidgets.QListWidget.IconMode)
        #设置图标大小
        self.file_listWidget.setIconSize(QtCore.QSize(self.size,self.size))
        #设置拉伸模式为Adjust
        self.file_listWidget.setResizeMode(QtWidgets.QListWidget.Adjust)
        #设置GridSize                        self.file_listWidget.setGridSize(QtCore.QSize(self.size+self.buffer,self.size+self.buffer))</code></pre>]]></content>
      <categories>
        <category>Maya</category>
      </categories>
      <tags>
        <tag>Maya</tag>
      </tags>
  </entry>
  <entry>
    <title>Poof效果Niagara实现</title>
    <url>/2020/10/31/Poof%E6%95%88%E6%9E%9CNiagara%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>教程：<a href="https://www.youtube.com/watch?v=aiw1slB4Mdo&amp;t=1677s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=aiw1slB4Mdo&amp;t=1677s</a>    </p>
<p>这位老哥的Niagara教程非常的棒，思路很清晰。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/Poof%E6%95%88%E6%9E%9C.gif" alt="Poof效果"></p>
 <a id="more"></a> 

<h2 id="分析实现点"><a href="#分析实现点" class="headerlink" title="分析实现点"></a>分析实现点</h2><p>1.底层的烟雾效果    2.四处飞散的烟雾效果    3.爆炸火花和漂浮火花效果</p>
<h2 id="底层的烟雾效果"><a href="#底层的烟雾效果" class="headerlink" title="底层的烟雾效果"></a>底层的烟雾效果</h2><p><strong>主要思路</strong>：利用Cylinder Location生成沿圆柱体表面的粒子，再Add Velocity达到外扩效果，最后Scale Sprite Size调整大小。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031154142500.png" alt="image-20201031154142500"></p>
<h3 id="Cylinder-Location"><a href="#Cylinder-Location" class="headerlink" title="Cylinder Location"></a>Cylinder Location</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031154347484.png" alt="image-20201031154347484"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201030170321744.png" alt="image-20201030170321744"></p>
<p>可以通过勾选SurfaceOnly，让点只生成在圆柱的表面</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201030170359427.png" alt="image-20201030170359427"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201030170405653.png" alt="image-20201030170405653"></p>
<p>也可以选择是否封盖模式，可以看到这样点就不会生成在圆柱的上下表面</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201030170548167.png" alt="image-20201030170548167"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201030170552930.png" alt="image-20201030170552930"></p>
<h3 id="Drag"><a href="#Drag" class="headerlink" title="Drag"></a>Drag</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031154558620.png" alt="image-20201031154558620"></p>
<p>其实在我看来就是摩擦力，能达到一个非常好的物理模拟效果。</p>
<h3 id="为烟雾添加Light效果"><a href="#为烟雾添加Light效果" class="headerlink" title="为烟雾添加Light效果"></a>为烟雾添加Light效果</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031154937201.png" alt="image-20201031154937201"></p>
<h2 id="四处飞散的烟雾效果"><a href="#四处飞散的烟雾效果" class="headerlink" title="四处飞散的烟雾效果"></a>四处飞散的烟雾效果</h2><p>思路：首先用一个Emitter发射出5个点来模拟烟雾的轨迹，Generate Location Event发出Event，然后另一个Emitter接受Event，完成了粒子之间的属性传递。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031155452425.png" alt="发出Event的Emitter"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031155533248.png" alt="接收Event的Emitter"></p>
<h3 id="Add-Velocity-from-point"><a href="#Add-Velocity-from-point" class="headerlink" title="Add Velocity from point"></a>Add Velocity from point</h3><p>这个也是用于添加Velocity，大概意思是根据Velocity Origin 来计算粒子点的速度，Simulation Position指Niagara System中在场景中的位置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031155754305.png" alt="image-20201031155754305"></p>
<h3 id="Generate-Location-Event"><a href="#Generate-Location-Event" class="headerlink" title="Generate Location Event"></a>Generate Location Event</h3><p>这个需要在发射器属性中勾选持久ID，Event主要实现的是Emitter之间的信息传递，一个Emitter发出Event，另一个Emitter进行监听</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031160049739.png" alt="image-20201031160049739"></p>
<p>Event Send Rate：Event发射的速率多少，会影响接收方Emitter生成粒子的数量</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031155942917.png" alt="image-20201031155942917"></p>
<h3 id="Receive-Location-Event"><a href="#Receive-Location-Event" class="headerlink" title="Receive Location Event"></a>Receive Location Event</h3><p>顾名思义是接受Event</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031160428716.png" alt="image-20201031160428716"></p>
<h2 id="爆炸火花和漂浮火花效果"><a href="#爆炸火花和漂浮火花效果" class="headerlink" title="爆炸火花和漂浮火花效果"></a>爆炸火花和漂浮火花效果</h2><p>这个比较简单，都是利用Add Velocity from point 添加了速度，让粒子往外扩，添加Curl Noise Force让粒子更飘动更随机一点，其中Hit Emitter的size是经过拉伸的，这样才能形成长方形效果，最后都是调整Size曲线</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031160730199.png" alt="image-20201031160730199"></p>
<h2 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h2><p>如果在材质中开启默认光照，特别注意光照对粒子的效果，可能会照成粒子变黑</p>
<h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><p>朴实无华</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201031161649592.png" alt="image-20201031161649592"></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(二)</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    <content><![CDATA[<h2 id="创建基础材质"><a href="#创建基础材质" class="headerlink" title="创建基础材质"></a>创建基础材质</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00005.png" alt="HighresScreenshot00005"></p>
<a id="more"></a>

<p>创建基础颜色base，这里我们只输出color，rough，metal信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201121157424.png" alt="image-20201201121157424"></p>
<h3 id="脏迹"><a href="#脏迹" class="headerlink" title="脏迹"></a>脏迹</h3><p>新建一个填充层控制rough，同时生成黑色遮罩，为黑色遮罩dirt生成器</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201121523720.png" alt="image-20201201121523720"></p>
<p>可以看到生成的Mask遮罩图在UV接缝处有很强烈的不连接感，可以使用三面投射解决</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201121639864.png" alt="image-20201201121639864"></p>
<p>第一层效果，有一种脏迹的感觉了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201121801376.png" alt="image-20201201121801376"></p>
<p>为黑色遮罩添加第二个填充层，选取一张程序化的划痕图，同样为了避免UV接缝选择三面映射，调整一下平衡和对比度</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201122510511.png" alt="image-20201201122510511"></p>
<p>这里我们可以发现这个新加的填充层覆盖了dirt层，我们只要调整混合模式为Max最亮即可，这样就添加了许多细节</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201133513430.png" alt="image-20201201133513430"></p>
<h3 id="油漆斑点"><a href="#油漆斑点" class="headerlink" title="油漆斑点"></a>油漆斑点</h3><p>新建一个填充图层，重命名为height高度</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201135204394.png" alt="image-20201201135204394"></p>
<p>为高度层新建一个黑色遮罩，并且赋予Bnw splots程序化纹理，调整平衡和对比度，这里与教程有点出入的是SP2018是有直方图的可以调整的，但是新版本用平衡和对比度替换掉了直方图</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201135424547.png" alt="教程"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201135447659.png" alt="新版本"></p>
<p>得到效果，有点油漆凸起的效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201135605084.png" alt="image-20201201135605084"></p>
<h3 id="边缘效果"><a href="#边缘效果" class="headerlink" title="边缘效果"></a>边缘效果</h3><p>同样操作，新建一个边缘效果图层，新建黑色遮罩，由于我们想要做边缘效果，所以我们需要一个边缘的Mask，这个可以用生成器mask editor来达到效果，这里需要将曲率拉满</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201140635232.png" alt="image-20201201140635232"></p>
<p>可以看到mask editor的基础是靠烘焙贴图来完成，所以烘焙贴图很重要</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201140724364.png" alt="image-20201201140724364"></p>
<p>达到效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201140759615.png" alt="image-20201201140759615"></p>
<p>可以看到这边缘效果太整齐划一了，可以再添加一层noise效果细化 </p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201141348276.png" alt="image-20201201141348276"></p>
<h3 id="其他颜色"><a href="#其他颜色" class="headerlink" title="其他颜色"></a>其他颜色</h3><p>为了让整体颜色更加丰富，可以再添加一层颜色细化，混合模式为overlay，亮的更亮，暗的更暗（混合模式太多了，我也不大清楚）</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201141936934.png" alt="image-20201201141936934"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4--材质大师课程笔记</title>
    <url>/2020/01/11/UE4--%E6%9D%90%E8%B4%A8%E5%A4%A7%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="压缩和内存"><a href="#压缩和内存" class="headerlink" title="压缩和内存"></a>压缩和内存</h2><p>一般来说纹理导入UE4都是经过压缩的，压缩方式有BC(Block Compression块压缩)/DXTC(Directx Texture Compression DirectX纹理压缩)两种，其实都是用于PC的Directx平台的格式。但是法线贴图有点特殊，是无法通过这两种方式进行压缩的。</p>
<a id="more"></a>

<p>​    如下图所示就是贴图导入UE4后所选择的压缩方式。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F.png" alt></p>
<p>压缩方式后面所带的数字表明是不同的压缩格式，例如BC3(DXTC5)表示带透明度的纹理，BC1(DXTC1)表示不带透明度的纹理。</p>
<p>法线贴图的压缩方式是通过剔除蓝色通道的方式进行压缩，这样可以存储更多的数据，同时对红色和绿色通道进行轻度压缩。最后通过对红绿色进行蓝色通道的复原，这些都是UE4内部自己调用的，不用我们去调整。如下图只是进行蓝色通道复原的演示。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE.png" alt></p>
<p>注意的是，法线贴图的导入方式必须是选择NormalMap。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F.png" alt></p>
<h3 id="为什么要对纹理进行压缩"><a href="#为什么要对纹理进行压缩" class="headerlink" title="为什么要对纹理进行压缩"></a>为什么要对纹理进行压缩</h3><p>最主要是因为受限于内存和带宽，如果不对纹理进行压缩，可能导致卡顿。但帧率过低一般和纹理压缩没有什么关系。可以通过查看统计数据，来查看场景中哪些纹理在内存中的大小。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE.png" alt></p>
<h2 id="多级渐进纹理-纹理尺寸和纹理池"><a href="#多级渐进纹理-纹理尺寸和纹理池" class="headerlink" title="多级渐进纹理 纹理尺寸和纹理池"></a>多级渐进纹理 纹理尺寸和纹理池</h2><h3 id="纹理池"><a href="#纹理池" class="headerlink" title="纹理池"></a>纹理池</h3><p>UE4在计算机内存中，会为纹理暴保留一定的空间，这个空间就是纹理池，我们可以手动调整纹理池的大小，当纹理池大小不够用的时候，会导致贴图的分辨率降低，效果下降。</p>
<p>打开控制台，输入r.Streaming.PoolSize查看纹理池大小，并且可以进行修改。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E8%B0%83%E6%95%B4%E7%BA%B9%E7%90%86%E6%B1%A0.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E8%BF%87%E5%B0%8F%E7%BA%B9%E7%90%86%E6%B1%A0.png" alt></p>
<h3 id="Mipmaps-多级渐进纹理"><a href="#Mipmaps-多级渐进纹理" class="headerlink" title="Mipmaps(多级渐进纹理)"></a>Mipmaps(多级渐进纹理)</h3><p>Mipmaps为原始纹理的副本，大小为1/4左右,使用Mipmaps的原因是为了减少噪点的生成。</p>
<p>左侧是使用了Mipmaps，右边没有使用，可以看出右边的噪点非常多，所以Mipmaps可以看成我们手动进行模糊</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Mipmaps.png" alt></p>
<p>UE4会对远处使用不同的Mipmaps来模拟模糊的效果，如下图离镜头最近的就使用Mipmaps0原始纹理，然后随着离镜头越来越远，使用不同的Mipmaps。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/MipmapsLerp.png" alt></p>
<p>可以在贴图的LOD选择中进行Mipmaps的设置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Mipmaps%E8%AE%BE%E7%BD%AE.png" alt></p>
<h4 id="注意纹理尺寸"><a href="#注意纹理尺寸" class="headerlink" title="注意纹理尺寸"></a>注意纹理尺寸</h4><p>使用Mipmaps可以提高我们的性能，加快渲染速度和减少纹理锯齿，但注意不适于2的幂数的纹理无法生成Mipmaps，但是UI纹理可以是任意分辨率，因为UI纹理不会从远处到近处，所以没必要使用Mipmaps。</p>
<h3 id="材质的纹理数限制"><a href="#材质的纹理数限制" class="headerlink" title="材质的纹理数限制"></a>材质的纹理数限制</h3><p>UE4的每个材质的纹理可采样数是16个，加上内部的光影贴图，其实我们可以用的大概是13个左右，其实已经够用了，但是如果要突破这个限制的话，我们可以把不同的贴图合成RGB通道就成为一张贴图，到使用的的时候就可以分RGB通道分为3张贴图。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/%E8%B4%B4%E5%9B%BE%E5%90%88%E6%88%90.png" alt></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(六)---最终成果</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)/</url>
    <content><![CDATA[<h2 id="渲染作品图片"><a href="#渲染作品图片" class="headerlink" title="渲染作品图片"></a>渲染作品图片</h2><p>Iray，只渲了两分钟电脑实在顶不住了<img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/%E6%B8%B2%E6%9F%93%E6%88%90%E5%9B%BE.jpg" alt="渲染成图"></p>
<a id="more"></a>

<p>UE4由于没有添加任何效果可能看起来有点难看，但问题不大</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00004.png" alt="HighresScreenshot00004"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00003.png" alt="HighresScreenshot00003"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(五)</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)/</url>
    <content><![CDATA[<h2 id="使用id贴图和多边形填充工具制作遮罩"><a href="#使用id贴图和多边形填充工具制作遮罩" class="headerlink" title="使用id贴图和多边形填充工具制作遮罩"></a>使用id贴图和多边形填充工具制作遮罩</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00005.png" alt="HighresScreenshot00005"></p>
<a id="more"></a>

<h3 id="金属材质"><a href="#金属材质" class="headerlink" title="金属材质"></a>金属材质</h3><p>制作金属材质，添加base基础颜色layer，使用rough dirty作为粗糙度贴图</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202143149042.png" alt="image-20201202143149042"></p>
<p>调整粗糙度通道的色阶，暗部更暗，亮部更亮</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202145655888.png" alt="image-20201202145655888"></p>
<p>添加边缘颜色遮罩，同样用mask editor来获取边缘遮罩，并且添加多一个划痕贴图增加细节，混合模式最亮Max</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202150022928.png" alt="image-20201202150022928"></p>
<h3 id="利用id贴图进行金属材质和非金属材质的区分"><a href="#利用id贴图进行金属材质和非金属材质的区分" class="headerlink" title="利用id贴图进行金属材质和非金属材质的区分"></a>利用id贴图进行金属材质和非金属材质的区分</h3><p>右键图层添加颜色选择遮罩</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202150227192.png" alt="image-20201202150227192"></p>
<p>可以看到金属材质没有铁锈，需要调整rust材质的位置</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202150550248.png" alt="image-20201202150550248"></p>
<p>可以看到铁锈有点暗，这是因为我们的rust材质没有输出metal信息，所以使用的是金属材质输出的metal信息导致颜色变暗</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202150852015.png" alt="image-20201202150852015"></p>
<p>解决方法也很简单，只要rust材质输出metal信息就好了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202150932135.png" alt="image-20201202150932135"></p>
<p>接下来就是给其他模型上金属材质效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202151238490.png" alt="image-20201202151238490"></p>
<h3 id="灯芯材质"><a href="#灯芯材质" class="headerlink" title="灯芯材质"></a>灯芯材质</h3><p>首先新建一个灯芯材质，首先要确定哪个地方是灯芯，利用几何体填充可以快速选择物体，这样白色的区域就是灯芯</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202155208477.png" alt="image-20201202155208477"></p>
<p>在灯芯材质文件夹下新建base基础颜色layer，height信息为Fabric贴图，baseColor则为梯度渐变贴图，营造一种下黑上白的渐变效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202155348592.png" alt="image-20201202155348592"></p>
<p>接下来为灯芯添加AO，Gradient滤镜，同时添加painterlayer手动修改遮罩，这里没有搞懂Gradient的运作方式有点迷，先跟着做</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202155811610.png" alt="image-20201202155811610"></p>
<h2 id="创建污垢和玻璃材质"><a href="#创建污垢和玻璃材质" class="headerlink" title="创建污垢和玻璃材质"></a>创建污垢和玻璃材质</h2><p>同样新建一个Dirt文件夹，base基础颜色新建黑色遮罩，用Dirt绘制遮罩，同时用Grunge concrete old来打散遮罩，混合模式为Mul</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202163557630.png" alt="image-20201202163557630"></p>
<p>现在再添加一个dirt_top层，他是作用在所有朝上的表面上，这时候就用到mask editor的方位渐变了，得到的mask效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202165722981.png" alt="image-20201202165722981"></p>
<p>最后添加concrete old 打散添加细节</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202170058251.png" alt="image-20201202170058251"></p>
<p>这样Dirt材质就做好了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202170542796.png" alt="image-20201202170542796"></p>
<h3 id="玻璃材质"><a href="#玻璃材质" class="headerlink" title="玻璃材质"></a>玻璃材质</h3><p>新建一个Glasslayer，用于遮挡图层1的透明效果，由于准备进入渲染阶段，所以可以关闭透明效果的显示</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202171816849.png" alt="image-20201202171816849"></p>
<p>再新建一个rough调节layer，用于调整玻璃的粗糙度变化</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202173442953.png" alt="image-20201202173442953"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4学习笔记(1)——简单框架</title>
    <url>/2019/11/06/UE4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>纪录自己的UE4学习之路</p>
 <a id="more"></a> 

<h1 id="UE4的简单框架"><a href="#UE4的简单框架" class="headerlink" title="UE4的简单框架"></a>UE4的简单框架</h1><blockquote>
<p> UE创世，万物皆UObject，接着有Actor 。</p>
</blockquote>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/1.png" alt="继承关系"> </p>
<h2 id="Uobject"><a href="#Uobject" class="headerlink" title="Uobject"></a>Uobject</h2><p>Uobject是UE4中最基础的类，具有 元数据、反射生成、GC垃圾回收、序列化、编辑器可见，Class Default Object等功能。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/2.png" alt> </p>
<h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><p>Actor是UE4中最基本的场景元素，与Unity3D的gameobject相似，本身是一个容器，但是与unity不同的是，Actor没有任何可视化属性，甚至连位置属性也没有。但是也是与Unity相似，可以挂在多个可视化的组件( Component)，以达到各种功能，Actor也可以有子Actor。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/3.png" alt></p>
<p>Actor继承至Uobject，多了 Replication（网络复制）,Spawn（生生死死），Tick(有了心跳)等功能。</p>
<h2 id="组件-Component"><a href="#组件-Component" class="headerlink" title="组件(Component)"></a>组件(Component)</h2><p>组件挂在Actor身上发挥功能，例如位置组件，Actor的最终位置来至于他的根组件。组件也可以有根组件。</p>
<h2 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h2><p>Pawn是可以被控制的物体，相当于有controller的大脑，他可以是交通工具，鱼等，可以默认为生物的基类。</p>
<h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><p>Character是人形的Actor，继承于Pawn， 默认拥有一个用于碰撞的胶囊体组件(CapsuleComponent)和运动相关的组件(CharacterMoveMentComponent)，并具有一些动画相关的功能。可以认为是人性动物的基类。 </p>
<h2 id="控制器-Controller"><a href="#控制器-Controller" class="headerlink" title="控制器(Controller)"></a>控制器(Controller)</h2><p>控制器用于控制Pawn的行为， 一般分为AIController和PlayerController。控制器也是从Actor派生的，因此也可以加入到场景中。 </p>
<h3 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h3><p> 玩家控制器。是Pawn和控制其的玩家之间的桥梁，PlayerController代表了人类玩家的意愿。 </p>
<h3 id="AIController"><a href="#AIController" class="headerlink" title="AIController"></a>AIController</h3><p> 用于控制NPC的控制器，决定了NPC如何与玩家互动。 </p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><h3 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h3><p>UI, 显示玩家的名字，血条，得分等信息。 </p>
<h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><p> 每个PlayerConroller都有一个PlayerCameraManager，代表了玩家的视角。 </p>
<h2 id="游戏规则和状态"><a href="#游戏规则和状态" class="headerlink" title="游戏规则和状态"></a>游戏规则和状态</h2><h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><p> 游戏模式。处理游戏的规则，只存在与服务器端，因此客户端相关的逻辑不能存放在GameMode中。 </p>
<h3 id="GameState"><a href="#GameState" class="headerlink" title="GameState"></a>GameState</h3><p>游戏状态， 记录游戏的数据，比如当前游戏的进度，世界任务的完成状态等，会自动同步到各个客户端。 </p>
<h3 id="PlayerState"><a href="#PlayerState" class="headerlink" title="PlayerState"></a>PlayerState</h3><p> 玩家状态。记录玩家个人的数据，比如名字分数等，会自动同步到各个客户端。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>GamePlay框架使用了MVC架构，其中Pawn是视图，PlayerState是数据模型，PlayerController是控制器。</p>
<p>一个游戏由游戏规则(GameMode)和游戏状态组成(GameState)；玩家在游戏里的化身是Pawn，玩家通过PlayerConroller控制着自己的化身，通过PlayerCameraManager观察世界，PlayerState记录了玩家的数据，HUD显示了这些状态；NPC则由AIConroller去控制，与玩家进行互动。 </p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note/GameFramework.jpg" alt="GameFramework"></p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>SP学习笔记(四)</title>
    <url>/2020/12/02/SP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/</url>
    <content><![CDATA[<h2 id="理解笔刷系统"><a href="#理解笔刷系统" class="headerlink" title="理解笔刷系统"></a>理解笔刷系统</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/HighresScreenshot00005.png" alt="HighresScreenshot00005"></p>
<a id="more"></a>

<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>ctrl + 鼠标右键左右移动控制笔刷大小</p>
<p>ctrl + 鼠标右键上下移动控制笔刷软硬</p>
<p>ctrl + 鼠标左键左右控制笔刷透明度</p>
<p>ctrl + 鼠标左键上下控制笔刷旋转</p>
<p>左上的画笔调节栏</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201201221236504.png" alt="image-20201201221236504"></p>
<p>当我们把笔刷透明度调整为少于100的时候，他会自动叠加到100透明度的效果，如果不想叠加可以按着A + 鼠标左键进行绘制</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/%E7%AC%94%E5%88%B7%E9%80%8F%E6%98%8E%E5%BA%A6.gif" alt="笔刷透明度"></p>
<p>平滑笔刷可以绘制曲线的时候变得很漂亮平滑</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202115810636.png" alt="image-20201202115810636"></p>
<p>跟随路径作用是让绘制的图案跟随曲线的旋转而旋转</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202120102297.png" alt="image-20201202120102297"></p>
<p>绘画面板右键可以看到有：创建工具预设，创建材质预设，创建笔刷预设</p>
<p>工具预设：保存材质和笔刷</p>
<p>材质预设：只保存材质</p>
<p>笔刷预设：只保存笔刷</p>
<p>根据校准的选择会造成绘制的不同</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202132143033.png" alt="image-20201202132143033"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202132341569.png" alt="image-20201202132341569"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202132400295.png" alt="image-20201202132400295"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202132413256.png" alt="image-20201202132413256"></p>
<p>添加绘制模板Stencil，其实就是提供一个基于屏幕空间的遮罩</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202132739768.png" alt="image-20201202132739768"></p>
<h2 id="使用绘画特效，映射和克隆工具"><a href="#使用绘画特效，映射和克隆工具" class="headerlink" title="使用绘画特效，映射和克隆工具"></a>使用绘画特效，映射和克隆工具</h2><p>绘画特效其实就是人为绘制遮罩，X快速切换绘制的黑白颜色</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202133248432.png" alt="image-20201202133248432"></p>
<p>映射工具就是基于屏幕空间的纹理绘制</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202133551413.png" alt="image-20201202133551413"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202133716766.png" alt="image-20201202133716766"></p>
<p>克隆工具就是PS的仿制图章，需要将用到的通道混合模式都设置为Passthrough才有效，按V键对源区域进行采样</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202134301094.png" alt="image-20201202134301094"></p>
<h2 id="使用锚定点"><a href="#使用锚定点" class="headerlink" title="使用锚定点"></a>使用锚定点</h2><p>锚定点是一种在一个图层中设置目标通道，让其他图层使用的工具</p>
<p>添加文字layer，需要将笔刷的Alpha选为文字贴图Font Chathura</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202134640596.png" alt="image-20201202134640596"></p>
<p>切换到AO通道，可以看到刚才添加的文字层并没有AO信息，所以我们可以为其添加AO信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202134848402.png" alt="image-20201202134848402"></p>
<p>添加HBAO滤镜就可以为文字layer的AO信息</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202135059369.png" alt="image-20201202135059369"></p>
<p>最后添加一下Blur滤镜</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202135451556.png" alt="image-20201202135451556"></p>
<p>可以看到我们的文字并没有和rust铁锈材质进行结合，因为rust铁锈材质的遮罩是根据模型烘焙好的信息进行区分的，但是文字layer的height信息和AO信息都是后面加的，并没有存在烘焙好的贴图上，这时候锚定点的作用就来了。</p>
<p>首先为文字layer右键添加一个锚定点</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202140128258.png" alt="image-20201202140128258"></p>
<p>在rust的mask editor中微高度添加锚定点，由于我们文字layer只输出height信息，所以引用通道也要选择为Height</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202140503858.png" alt="image-20201202140503858"></p>
<p>其次在微细节中进行细节的调整，并打开微高度开关，可以看到文字上也有了铁锈的痕迹</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202140857193.png" alt="image-20201202140857193"></p>
<p>添加个人标记嘻嘻嘻</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201202142517637.png" alt="image-20201202142517637"></p>
]]></content>
      <categories>
        <category>Substance painter</category>
      </categories>
      <tags>
        <tag>Substance painter</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4学习笔记(2)---蓝图接口-标签</title>
    <url>/2019/11/13/UE4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)---%E8%93%9D%E5%9B%BE%E6%8E%A5%E5%8F%A3-%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="蓝图接口"><a href="#蓝图接口" class="headerlink" title="蓝图接口"></a>蓝图接口</h1><p> <strong>蓝图接口（Blueprint Interface）</strong> 是一个或多个函数的集合 - 只有名称，没有实现。可以添加到其他蓝图中。任何添加了该接口的蓝图都保证拥有这些函数。接口的函数 可以在添加它的每个蓝图中提供功能。在本质上，这类似于一般编程中的接口概念， 它允许多个不同类型的对象通过一个公共接口 共享和被访问。简单地说，蓝图接口允许不同的蓝图相互共享和发送数据。 </p>
<a id="more"></a>

<h2 id="创建蓝图接口"><a href="#创建蓝图接口" class="headerlink" title="创建蓝图接口"></a>创建蓝图接口</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/1.png" alt></p>
<p>新建函数和函数的输入输出值</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/2.png" alt></p>
<p>要使用蓝图接口，就必须继承该接口，并且实现。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/3.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/4.png" alt></p>
<p>实现接口之后，其他蓝图类就可以调用此方法，实现了蓝图之间的通信。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/5.png" alt></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>在调用蓝图接口方法前，先使用标签来判断是敌人还是友军，其实我感觉UE4的标签和Unity的标签还是挺相似的</p>
<h3 id="标签的设置方法"><a href="#标签的设置方法" class="headerlink" title="标签的设置方法"></a>标签的设置方法</h3><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/6.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/7.png" alt></p>
<h2 id="调用蓝图接口方法"><a href="#调用蓝图接口方法" class="headerlink" title="调用蓝图接口方法"></a>调用蓝图接口方法</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/UE4-Note%282%29/8.png" alt></p>
<p>就这样完成了蓝图接口的调用</p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Visual Effect Graph初探</title>
    <url>/2019/10/31/Unity-Visual-Effect-Graph%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近为了实现动画课程设计的烟花效果，所以要学习一下Unity的新特效工具Visual Effect Graph，特此记录学习的过程，避免以后会忘记。</p>
 <a id="more"></a> 

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>目前Visual Effect Graph只能在HDRP中使用，也就是说必须使用Unity2018.3以上的版本。</p>
</blockquote>
<h2 id="为什么要使用VEF"><a href="#为什么要使用VEF" class="headerlink" title="为什么要使用VEF"></a>为什么要使用VEF</h2><p>我们已经有传统的Particle System系统，那为什么要用VEF呢？</p>
<p>其实VEF能比传统的Particle System能做出更加复杂酷炫的特效，具体可以查看Unity的官方文档。而且我们认为VEF还有一个更加巨大有点就是可视化，我刚开始接触Particle System的时候，看到这么多参数，头都晕了….这次VEF的工作流非常的清楚。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/24.jpg" alt="VEF和传统Particle System区别"></p>
<h2 id="VEF的工作流"><a href="#VEF的工作流" class="headerlink" title="VEF的工作流"></a>VEF的工作流</h2><p>关于VEF的安装和配置就不说了，官方文档有详细的讲解。</p>
<p>首先我们来看一下VEF的画面，可以看出和shader Graph非常的相似。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/1.png" alt="VEG"></p>
<p>VEF默认模板由4个流程构成(VEF称为Context)，包含着多个Block，整个VEF工作流抽象成4个部分</p>
<h3 id="Spawn"><a href="#Spawn" class="headerlink" title="Spawn"></a>Spawn</h3><p>负责生成粒子，右键点击添加的Block都是与粒子生成相关。</p>
<h3 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h3><p>初始化模块，负责初始化粒子的属性，如初始速度，生命周期。</p>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>每帧对粒子的参数进行更新，比如重力，移动速度，坐标等。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>主要负责粒子的渲染，如颜色，形状等。</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>每个Context连接并不是唯一，比如一个Spawn可连接多个Initialize，朝多个方向发射</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/2.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/3.png" alt></p>
<h2 id="VEF的使用"><a href="#VEF的使用" class="headerlink" title="VEF的使用"></a>VEF的使用</h2><h3 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h3><p>VEF的小测试，以粒子的初始速度为基准设置粒子的颜色</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/4.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/5.png" alt></p>
<p>实现以原点为圆心，半径为1，圆以内的呈绿色，圆以外的呈紫色。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/6.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/7.png" alt></p>
<p>也可添加Get Attribute：Color结点获取粒子原本的颜色，达到新效果。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/8.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/9.png" alt></p>
<h3 id="Point-Cache-bake-tool-点阵缓存烘焙器"><a href="#Point-Cache-bake-tool-点阵缓存烘焙器" class="headerlink" title="Point Cache bake tool(点阵缓存烘焙器)"></a>Point Cache bake tool(点阵缓存烘焙器)</h3><p>这个是VEG添加的新工具，它的作用是把一张图或者Mesh的信息，烘焙成一张点阵图，然后再VEG中使用，可烘焙的信息有颜色，法线，位置，UV信息等。</p>
<p>首先点开烘焙工具，烘焙工具在上方Window—Visual Effects—Utilities—Point Cache bake tool,选择要烘焙的网格和信息，这里我选择胶囊体作为测试。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/10.png" alt></p>
<p>在VEG中使用以下两个节点，即可得到一个粒子形成的胶囊体</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/11.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/12.png" alt></p>
<h3 id="Vector-Field-Force-矢量场力"><a href="#Vector-Field-Force-矢量场力" class="headerlink" title="Vector Field Force(矢量场力)"></a>Vector Field Force(矢量场力)</h3><p>官方文档解释：矢量场力施加从包含矢量数据的3D纹理中获取的力。我也不是很明白，以后有机会再研究。通过结合矢量场力和Point Cache我们可以实现粒子物体爆掉的感觉。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/13.png" alt></p>
<h3 id="VFX-Binder脚本，参数与事件的绑定"><a href="#VFX-Binder脚本，参数与事件的绑定" class="headerlink" title="VFX Binder脚本，参数与事件的绑定"></a>VFX Binder脚本，参数与事件的绑定</h3><p>为了在游戏运行时根据游戏内的逻辑来实时动态改变VEG，我们可以用VFX Binder绑定脚本。</p>
<h4 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h4><p>首先，我们为VFX添加VFX Parameter binder脚本</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/14.png" alt></p>
<p>在Hierarchy面板新建一个Cube，这个Cube用于传递位置参数进VEG，实时更新粒子喷发的位置。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/15.png" alt></p>
<p>进入VEG在参数面板新建一个Vector3用于存储Cube的位置参数，并传递给粒子。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/18.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/17.png" alt="最终结果"></p>
<h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>在VEG里事件作为一个单独的Context，不能附加任何的Block并且只能和Spawn相连，作用是管理Spawn的发射开关。</p>
<p>现在做鼠标点击位置生成粒子效果</p>
<p>首先新建一个Plane作为脚本的载体，并且绑定VFX Mouse Event Blinder事件,拖入新建的VFX</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/22.png" alt></p>
<p>双击VEX，新建一个Event，注意名字要和脚本上的EventName要一致。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/21.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-Visual-Effect-Graph/23.png" alt></p>
<h5 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h5><p>Location为Source的Attribute只能用在Initializes中的Block上</p>
<p>最后我们就能实现鼠标点击位置生成粒子的效果了。</p>
<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>第一次尝试这样做笔记，比较痛苦，但成就感也是满满的。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4材质大师课程笔记(二)---RenderTarget</title>
    <url>/2020/02/19/UE4%E6%9D%90%E8%B4%A8%E5%A4%A7%E5%B8%88%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0(%E4%BA%8C)---RenderTarget/</url>
    <content><![CDATA[<h1 id="RenderTarget"><a href="#RenderTarget" class="headerlink" title="RenderTarget"></a>RenderTarget</h1><p>UE4的RenderTarget感觉和Unity的差不多，都是获得一个摄像机的渲染结果，然后存在RenderTarget里面进行读取使用。</p>
<a id="more"></a>

<p>在UE4中要使用RenderTarget，首先要添加SceneCapture2D组件或者SceneCapture Cube组件，前者获取2D，后者获取Cube立方体贴图。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget%E7%BB%84%E4%BB%B6.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget%E6%96%B0%E5%BB%BARenderTarget.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget%E8%B5%8B%E5%80%BCRenderTarget.png" alt></p>
<h2 id="RenderTarget的使用"><a href="#RenderTarget的使用" class="headerlink" title="RenderTarget的使用"></a>RenderTarget的使用</h2><h3 id="渲染材质"><a href="#渲染材质" class="headerlink" title="渲染材质"></a>渲染材质</h3><p>在UE4中过程化生成噪点纹理是比较昂贵的，所以通常的做法是将材质绘制到RenderTarget中。</p>
<img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetNoise.png">

<p>可以看出以上这个需要529条指令<img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetNoise%E6%8C%87%E4%BB%A4.png" alt></p>
<p>将材质绘制到RenderTarget</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget%E5%B0%86%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E5%88%B0RenderTarget.png" alt></p>
<p>得到左边的RenderTarget噪点图了，然后右键创建静态纹理则可以得到可以用的Texture纹理了。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200109210329543.png" alt></p>
<p>指令就变为了34，效率得到了提升。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200109210452008.png" alt></p>
<h3 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h3><h4 id="高度图"><a href="#高度图" class="headerlink" title="高度图"></a>高度图</h4><p>效果如下，随着鼠标左键的按下，在平面生成不同的高度。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110182834948.png" alt></p>
<p>1.首先我们要创建MAT_HeightfieldPainter材质，设置如下，注意要把shading Model改为Unlit无光照模式。这个材质主要用于控制物体在Z轴的世界偏移。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110183116238.png" alt></p>
<p>2.创建MAT_ForceSplat材质，设置如下，主要用于处理鼠标点击平面所产生的uv坐标，通过下面的计算获得一个关于这个uv坐标为圆心的渐变圆形贴图</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110183515861.png" alt></p>
<p>3.新建一个HeightFieldPainter的Actor蓝图，设置如下</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110200935951.png" alt></p>
<p>然后在构造函数里面进行动态材质的设置，这里主要针对我们上面的材质创建动态材质。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110201017886.png" alt></p>
<p>新建TraceFromCamera函数，函数用于从摄像头方向射出射线，进行射线检测，如果检测到碰撞物体，就进行伤害传递。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110204023291.png" alt></p>
<p>Begin函数，首先我们要为新建一个RenderTexture并保存，同时将RT传递给Z轴偏移的MAT_HeightfieldPainter材质。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110204531617.png" alt></p>
<p>最后处理伤害函数，传递参数给MAT_ForceSplat材质，例如点击的uv坐标，力度，大小，最后要用Draw Material to Render Target函数将材质绘制到RT里面，这样HeighfieldPainter材质才会根据RT图进行Z轴的偏移。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTargetimage-20200110204555551.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/RenderTarget%E5%B0%86%E6%9D%90%E8%B4%A8%E6%B8%B2%E6%9F%93%E5%88%B0RenderTarget.png" alt></p>
<p>这里注意，这种方法只适用于平面，计算点击位置的uv坐标也比较简单，首先获取点击位置的世界坐标，然后获取静态网格的worldTransform,然后通过Invert Transform获得从世界坐标到静态网格本地坐标的变换矩阵，将点击位置从世界空间转换为静态网格的本地空间，当然我们也要将得到的本地坐标转为uv坐标，就要除于网格的长宽，映射到【0，1】，这样就得到了正确的uv坐标。</p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity实现米哈游的Mesh变换转场效果</title>
    <url>/2019/11/13/Unity%E5%AE%9E%E7%8E%B0%E7%B1%B3%E5%93%88%E6%B8%B8%E7%9A%84Mesh%E5%8F%98%E6%8D%A2%E8%BD%AC%E5%9C%BA%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前看过米哈游大佬制作的桃源恋歌MMD，被其中的Mesh变换转场效果所折服了，所以自己想模仿着实现这个效果，幸好kerjiro技术美术大神开源了这方面的视觉特效项目，感觉自己如果想成为TA还有好长的路要走。。。</p>
 <a id="more"></a> 

<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>首先让我们来看一下最终效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/Effect.gif" alt="Effect"></p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>其实这个效果是通过几何着色器来实现的，主要思路就是通过几何着色器对三角面片的顶点进行添加，构成一个Cube。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF.png" alt="实现思路"></p>
<h2 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h2><p>相信大家接触的最多的应该是顶点着色器和像素着色器，那么什么是几何着色器呢？</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在顶点和片段着色器之间有一个可选的着色器，叫做几何着色器(Geometry Shader)。几何着色器以一个或多个表示为一个单独基本图形（primitive）即图元的顶点作为输入，比如可以是一个点或者三角形。几何着色器在将这些顶点发送到下一个着色阶段之前，可以将这些顶点转变为它认为合适的内容。<strong>几何着色器有意思的地方在于它可以把（一个或多个）顶点转变为完全不同的基本图形（primitive），从而生成比原来多得多的顶点。</strong> </p>
<h3 id="使用几何着色器进行图元转换"><a href="#使用几何着色器进行图元转换" class="headerlink" title="使用几何着色器进行图元转换"></a>使用几何着色器进行图元转换</h3><p>声明着色器</p>
<pre><code>#pragma geometry geom</code></pre><p>设置输出顶点数量，其中N为几何着色器为单个调用输出的顶点最大数量，几何着色器每次输出的顶点数量是可变的，但是不能超过定义的最大值， 出于性能考虑，最大顶点数应尽可能小; 当GS输出在1到20个标量之间时，可以实现GS的性能峰值，如果GS输出在27-40个标量之间，则性能下降50％。每次调用的标量输出数是最大顶点输出数和输出顶点类型结构中的标量数的乘积。 </p>
<pre><code>[maxvertexcount(N)]</code></pre><p>声明输入和输出的Struct</p>
<pre><code>            //传递给几何着色器的数据
            struct v2g
            {
                float4 vertex:POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv:TEXCOORD1;

            };

            //传递给像素着色器的数据
            struct g2f
            {
                float4 pos : SV_POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv : TEXCOORD1;
                float4 color:COLOR;
            };</code></pre><p>设置几何着色器输入参数和输出参数，</p>
<p>其中“triangle”为输入的图元类型， 输入参数一定为顶点数组 。</p>
<pre><code class="ruby">输入图元类型 | 所需顶点数  
-|-
point | 输入1个点的1个顶点
line | 输入1条直线的2个顶点 
lineadj | 输入1条具有邻接(lists或strips)的线段的4个顶点 
triangle | 输入1个三角形的3个顶点
triangleadj | 输入1个具有邻接(lists或strips)的三角形的6个顶点</code></pre>
<p>TriangleStream为流类型(stream type)对象，还有 LineStream 和 PointStream ,存储着由几何着色器输出的几何体顶点列表。内置Append用于向输出流添加顶点序列， 若想扩展输入的图元，也可以用内置Append向输出流添加多出来的顶点。 </p>
<p>当指定uint primID:SV_PrimitiveID时，输入汇编阶段会为每个图元自动生成一个图元ID。当调用draw方法绘制n个图元时，ID号为0到n-1，这里用到的原因是为了随机Cube化。</p>
<pre><code>void geom(triangle v2g input[3], uint pid : SV_PrimitiveID, inout TriangleStream&lt;g2f&gt; outStream)
{
    //shader body
}</code></pre><p>将输出顶点传送至输出stream上</p>
<pre><code>OutputStream.Append(o);</code></pre><h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><h3 id="CPU传递数据给Shader"><a href="#CPU传递数据给Shader" class="headerlink" title="CPU传递数据给Shader"></a>CPU传递数据给Shader</h3><p>首先我们需要新建一个脚本用于传递数据给Shader，以下就是K神的传递脚本，我已经写好注释。挂在一个空物体上面即可。</p>
<pre><code>using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//在编辑器模式下也可运行
[ExecuteInEditMode]
public class Voxelizer : MonoBehaviour
{
    //SerializeField用于面板上显示非Public的参数
    //Range(0,1)控制可滑选的范围

    //控制生成方块的密度
    [SerializeField, Range(0, 1)] float _density = 0.05f;
    //控制生成方块的大小
    [SerializeField, Range(0, 10)] float _scale = 3;


    //动画参数
    //用于控制方块变形后的长度
    [SerializeField, Range(0, 20)] float _stretch = 5;
    //用于控制方块变形后上升的最大距离
    [SerializeField, Range(0, 1000)] float _fallDistance = 1;
    //用于控制方块变形后的随机移动范围
    [SerializeField, Range(0, 10)] float _fluctuation = 1;

    //颜色参数
    [SerializeField, ColorUsage(false, true)] Color _emissionColor1 = Color.black;
    [SerializeField, ColorUsage(false, true)] Color _emissionColor2 = Color.black;
    [SerializeField, ColorUsage(false, true)] Color _transitionColor = Color.white;
    [SerializeField, ColorUsage(false, true)] Color _lineColor = Color.white;

    //用于Mesh变换物体的Renderer
    [SerializeField] Renderer[] _renderers = null;


    //效果平面的位置与距离
    Vector4 EffectorPlane
    {
        get
        {
            //获取向前的方向
            var fwd = transform.forward / transform.localScale.z;
            //获取向前方向上的移动距离
            var dist = Vector3.Dot(fwd, transform.position);
            return new Vector4(fwd.x, fwd.y, fwd.z, dist);
        }
    }


    //将RGB颜色模型转为HSV颜色模型
    Vector4  ColorToHsvm(Color color)
    {
        //获取颜色的分量最大值
        var max = color.maxColorComponent;
        float h, s, v;
        Color.RGBToHSV(color / max, out h, out s, out v);
        return new Vector4(h, s, v, max);
    }


    //获取着色器属性的唯一标识符
    //优点：使用属性标识符比将字符串传递给所有材料属性函数更有效。
    //例如，如果您经常调用Material.SetColor或使用MaterialPropertyBlock，
    //则最好只获取一次所需属性的标识符。

    static class ShaderIDs
    {
        public static readonly int VoxelParams = Shader.PropertyToID(&quot;_VoxelParams&quot;);
        public static readonly int AnimParams = Shader.PropertyToID(&quot;_AnimParams&quot;);
        public static readonly int EmissionHsvm1 = Shader.PropertyToID(&quot;_EmissionHsvm1&quot;);
        public static readonly int EmissionHsvm2 = Shader.PropertyToID(&quot;_EmissionHsvm2&quot;);
        public static readonly int TransitionColor = Shader.PropertyToID(&quot;_TransitionColor&quot;);
        public static readonly int LineColor = Shader.PropertyToID(&quot;_LineColor&quot;);
        public static readonly int EffectorPlane = Shader.PropertyToID(&quot;_EffectorPlane&quot;);
        public static readonly int PrevEffectorPlane = Shader.PropertyToID(&quot;_PrevEffectorPlane&quot;);
        public static readonly int LocalTime = Shader.PropertyToID(&quot;_LocalTime&quot;);
    }

    //在要使用相同材质但属性稍有不同的多个对象绘制的情况下使用MaterialPropertyBlock。
    MaterialPropertyBlock _sheet;
    Vector4 _prevEffectorPlane = Vector3.one * 1e+5f;

    private void LateUpdate()
    {
        //查看渲染列表是否为空
        if (_renderers == null || _renderers.Length == 0) return;
        //创建新的MaterialPropertyBlock
        if (_sheet == null) _sheet = new MaterialPropertyBlock();

        var plane = EffectorPlane;
        // Filter out large deltas.
        //过滤掉大的三角面片
        if ((_prevEffectorPlane - plane).magnitude &gt; 100) _prevEffectorPlane = plane;

        //存储参数
        var vparams = new Vector2(_density, _scale);
        var aparams = new Vector3(_stretch, _fallDistance, _fluctuation);
        var emission1 = ColorToHsvm(_emissionColor1);
        var emission2 = ColorToHsvm(_emissionColor2);

        //将参数传递给shader
        foreach (var renderer in _renderers)
        {
            if (renderer == null) continue;
            renderer.GetPropertyBlock(_sheet);
            _sheet.SetVector(ShaderIDs.VoxelParams, vparams);
            _sheet.SetVector(ShaderIDs.AnimParams, aparams);
            _sheet.SetVector(ShaderIDs.EmissionHsvm1, emission1);
            _sheet.SetVector(ShaderIDs.EmissionHsvm2, emission2);
            _sheet.SetColor(ShaderIDs.TransitionColor, _transitionColor);
            _sheet.SetColor(ShaderIDs.LineColor, _lineColor);
            _sheet.SetVector(ShaderIDs.EffectorPlane, plane);
            _sheet.SetVector(ShaderIDs.PrevEffectorPlane, _prevEffectorPlane);
            //_sheet.SetFloat(ShaderIDs.LocalTime, time);
            renderer.SetPropertyBlock(_sheet);
            print(plane);
        }
    }


    //进行gizmo编辑器的实现,用于可视化Debug
    Mesh _gridMesh;

    void OnDestroy()
    {
        if (_gridMesh != null)
        {
            if (Application.isPlaying)
                Destroy(_gridMesh);
            else
                DestroyImmediate(_gridMesh);
        }
    }

    void OnDrawGizmos()
    {
        if (_gridMesh == null) InitGridMesh();

        //矩阵用于控制Gizmos跟随物体的移动而移动
        Gizmos.matrix = transform.localToWorldMatrix;

        Gizmos.color = new Color(1, 1, 0, 0.5f);
        Gizmos.DrawWireMesh(_gridMesh, Vector3.zero);
        Gizmos.DrawWireMesh(_gridMesh, Vector3.forward);

        Gizmos.color = new Color(1, 0, 0, 0.5f);
        Gizmos.DrawWireCube(Vector3.forward / 2, new Vector3(0.02f, 0.02f, 1));
    }

    void InitGridMesh()
    {
        const float ext = 0.5f;
        const int columns = 10;

        var vertices = new List&lt;Vector3&gt;();
        var indices = new List&lt;int&gt;();

        for (var i = 0; i &lt; columns + 1; i++)
        {
            var x = ext * (2.0f * i / columns - 1);

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(x, -ext, 0));

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(x, +ext, 0));

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(-ext, x, 0));

            indices.Add(vertices.Count);
            vertices.Add(new Vector3(+ext, x, 0));
        }

        _gridMesh = new Mesh { hideFlags = HideFlags.DontSave };
        _gridMesh.SetVertices(vertices);
        _gridMesh.SetNormals(vertices);
        _gridMesh.SetIndices(indices.ToArray(), MeshTopology.Lines, 0);
        _gridMesh.UploadMeshData(true);
    }
}
</code></pre><h3 id="MaterialPropertyBlock"><a href="#MaterialPropertyBlock" class="headerlink" title="MaterialPropertyBlock"></a>MaterialPropertyBlock</h3><p>研究代码的时候发现了MaterialPropertyBlock，查阅文档才发现是用于节约性能。实际应用可以查看这篇文章<a href="https://blog.csdn.net/liweizhao/article/details/81937590" target="_blank" rel="noopener">MaterialPropertyBlock</a>。</p>
<h3 id="Shader的实现"><a href="#Shader的实现" class="headerlink" title="Shader的实现"></a>Shader的实现</h3><pre><code>// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;

// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;

Shader &quot;Custom/MeshShader&quot;
{

    Properties
    {
        _MainTex(&quot;主纹理贴图&quot;,2D)=&quot;white&quot;{}
    }
    SubShader
    {
        Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }
        LOD 100
        Pass
        {
            Tags{&quot;LightMode&quot;=&quot;ForwardBase&quot;}
            CGPROGRAM

            //声明着色器
            #pragma vertex vert 
            #pragma geometry geom
            #pragma fragment frag

            #include &quot;UnityCG.cginc&quot;
            #include &quot;Assets/My/SimplexNoise3D.hlsl&quot;
            //传递给顶点着色器的数据
            struct a2v
            {
                float4 vertex:POSITION;
                float3 normal:NORMAL;
                float4 texcoord:TEXCOORD0;
            };

            //传递给几何着色器的数据
            struct v2g
            {
                float4 vertex:POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv:TEXCOORD1;

            };

            //传递给像素着色器的数据
            struct g2f
            {
                float4 pos : SV_POSITION;
                float3 normal:TEXCOORD0;
                //float2 uv : TEXCOORD1;
                float4 color:COLOR;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            //用于几何着色器的数据
            half2 _VoxelParams; // density, scale  密度，比例
            half3 _AnimParams;  // stretch, fall distance, fluctuation   伸展、下降距离、波动
            float4 _EffectorPlane;
            float4 _PrevEffectorPlane;

            //用于像素着色器的数据
            half4 _EmissionHsvm1;
            half4 _EmissionHsvm2;
            half3 _TransitionColor;
            half3 _LineColor;


            //顶点着色器
            void vert(inout v2g input)
            {

            }

            g2f VertexOutput(
                float3 position0, float3 position1,
                half3 normal0, half3 normal1, half param,
                half emission = 0, half random = 0, half2 baryCoord = 0.5
            )
            {
                g2f i;
                i.pos = UnityObjectToClipPos(float4(lerp(position0, position1, param),1));
                i.normal = normalize(lerp(normal0, normal1, param));
                i.color = float4(baryCoord, emission,random);
                return i;
            }

            // 计算方块的位置和大小
            void CubePosScale(
                float3 center, float size, float rand, float param,
                out float3 pos, out float3 scale
            )
            {
                const float VoxelScale = _VoxelParams.y;
                const float Stretch = _AnimParams.x;
                const float FallDist = _AnimParams.y;
                const float Fluctuation = _AnimParams.z;

                // Noise field
                //噪声场
                float4 snoise = snoise_grad(float3(rand * 2378.34, param * 0.8, 0));

                // Stretch/move param
                float move = saturate(param * 4 - 3);
                move = move * move;

                // Cube position
                pos = center + snoise.xyz * size * Fluctuation;
                pos.y += move * move * lerp(0.25, 1, rand) * size * FallDist;

                // Cube scale anim
                scale = float2(1 - move, 1 + move * Stretch).xyx;
                scale *= size * VoxelScale * saturate(1 + snoise.w * 2);
            }

            //哈希值，用于随机觉得面片是三角面片还是Cube
            float Hash(uint s)
            {
                s = s ^ 2747636419u;
                s = s * 2654435769u;
                s = s ^ (s &gt;&gt; 16);
                s = s * 2654435769u;
                s = s ^ (s &gt;&gt; 16);
                s = s * 2654435769u;
                return float(s) * rcp(4294967296.0); // 2^-32
            }

            //几何着色器
            [maxvertexcount(24)]
            void geom(triangle v2g input[3], uint pid : SV_PrimitiveID, inout TriangleStream&lt;g2f&gt; outStream)
            {
                //获取密度
                const float VoxelDensity = _VoxelParams.x;

                //获取传入顶点的位置
                float3 p0 = input[0].vertex.xyz;
                float3 p1 = input[1].vertex.xyz;
                float3 p2 = input[2].vertex.xyz;

                float3 p0_prev = p0;
                float3 p1_prev = p1;
                float3 p2_prev = p2;

                //获取传入顶点的法线
                float3 n0 = input[0].normal;
                float3 n1 = input[1].normal;
                float3 n2 = input[2].normal;

                //计算中心点
                float3 center = (p0 + p1 + p2) / 3;
                float size = distance(p0, center);

                //变形参数
                //将中心点变换到世界空间中
                float3 center_ws = mul(unity_ObjectToWorld, float4(center,1)).xyz;
                float param = 1 - dot(_EffectorPlane.xyz, center_ws) + _EffectorPlane.w;


                //如果变形还没开始那就将平常操作
                if (param &lt; 0)
                {
                    outStream.Append(VertexOutput(p0, 0, n0, 0, 0, 0, 0));
                    outStream.Append(VertexOutput(p1, 0, n1, 0, 0, 0, 0));
                    outStream.Append(VertexOutput(p2, 0, n2, 0, 0, 0, 0));
                    outStream.RestartStrip();
                    return;
                }


                //变形结束后，不传递任何数据，从而使物体隐身
                if (param &gt;= 1) return;

                // Choose cube/triangle randomly.
                //uint seed = float3(pid * 877, pid * 877, pid * 877);
                uint seed = pid * 877;
                if (Hash(seed) &lt; VoxelDensity)
                {
                    // -- Cube --

                    // Random numbers
                    float rand1 = Hash(seed + 1);
                    float rand2 = Hash(seed + 5);

                    // Cube position and scale
                    float3 pos, pos_prev, scale, scale_prev;
                    CubePosScale(center, size, rand1, param, pos, scale);

                    // Secondary animation parameters
                    float morph = smoothstep(0, 0.25, param);        

                    float em = smoothstep(0, 0.15, param) * 2; // initial emission
                    em = min(em, 1 + smoothstep(0.8, 0.9, 1 - param));
                    em += smoothstep(0.75, 1, param); // emission while falling

                    // Cube points calculation
                    float3 pc0 = pos + float3(-1, -1, -1) * scale;
                    float3 pc1 = pos + float3(+1, -1, -1) * scale;
                    float3 pc2 = pos + float3(-1, +1, -1) * scale;
                    float3 pc3 = pos + float3(+1, +1, -1) * scale;
                    float3 pc4 = pos + float3(-1, -1, +1) * scale;
                    float3 pc5 = pos + float3(+1, -1, +1) * scale;
                    float3 pc6 = pos + float3(-1, +1, +1) * scale;
                    float3 pc7 = pos + float3(+1, +1, +1) * scale;


                    // World space to object space conversion

                    // Vertex outputs
                    float3 nc = float3(-1, 0, 0);
                    outStream.Append(VertexOutput(p0, pc2, n0, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc0, n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p0, pc6, n0, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p2, pc4, n2, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(1, 0, 0);
                    outStream.Append(VertexOutput(p2, pc1, n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p1, pc3, n1, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p2, pc5, n2, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p1, pc7, n1, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, -1, 0);
                    outStream.Append(VertexOutput(p2, pc0, n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc1, n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p2, pc4, n2, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p2, pc5, n2, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, 1, 0);
                    outStream.Append(VertexOutput(p1, pc3, n1, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p0, pc2, n0, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p1, pc7, n1, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p0, pc6, n0, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, 0, -1);
                    outStream.Append(VertexOutput(p2, pc1, n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc0, n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p1, pc3, n1, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p0, pc2, n0, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();

                    nc = float3(0, 0, 1);
                    outStream.Append(VertexOutput(p2, pc4, -n2, nc, morph, em, rand2, float2(0, 0)));
                    outStream.Append(VertexOutput(p2, pc5, -n2, nc, morph, em, rand2, float2(1, 0)));
                    outStream.Append(VertexOutput(p0, pc6, -n0, nc, morph, em, rand2, float2(0, 1)));
                    outStream.Append(VertexOutput(p1, pc7, -n1, nc, morph, em, rand2, float2(1, 1)));
                    outStream.RestartStrip();
                }
                else
                {
                    // -- Triangle --
                    half morph = smoothstep(0, 0.25, param);
                    //half morph = 0.25;
                    half em = smoothstep(0, 0.15, param) * 2;
                    outStream.Append(VertexOutput(p0, center, n0, n0, morph, em));
                    outStream.Append(VertexOutput(p1, center, n1, n1, morph, em));
                    outStream.Append(VertexOutput(p2, center, n2, n2, morph, em));
                    outStream.RestartStrip();
                }
            }

            //计算颜色
            half3 SelfEmission(g2f input)
            {
                half2 bcc = input.color.rg;
                half em1 = saturate(input.color.b);
                half em2 = saturate(input.color.b - 1);
                half rand = input.color.a;

                // Cube face color
                half3 face = lerp(_EmissionHsvm1.xyz, _EmissionHsvm2.xyz, rand);
                face *= lerp(_EmissionHsvm1.w, _EmissionHsvm2.w, rand);

                // Cube face attenuation
                face *= lerp(0.75, 1, smoothstep(0, 0.5, length(bcc - 0.5)));

                // Edge detection
                half2 fw = fwidth(bcc);
                half2 edge2 = min(smoothstep(0, fw * 2, bcc),
                    smoothstep(0, fw * 2, 1 - bcc));
                half edge = 1 - min(edge2.x, edge2.y);

                return
                    face * em1 +
                    _TransitionColor * em2 * face +
                    edge * _LineColor * em1;
            }

            half4 frag(g2f z):SV_Target
            {
                half4 col = half4(SelfEmission(z),1);
                return col;
            }
                ENDCG
        }
    }
    FallBack &quot;Diffuse&quot;
}
</code></pre><p>这里运用到了三维噪声的知识，这里我只是简单的调用了K神写好的噪声函数，并没有深究，其实我还是看过了一些关于噪声的文章，以后已机会把笔记总结出来。</p>
<h1 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h1><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/LastEffect.gif" alt="实现思路"></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这个效果对于模型也是有要求的，模型的面片不能太小，不然就会得到以下的结果…</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-MeshTransform/Fail.gif" alt="失败效果"></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity VEG实现烟花效果</title>
    <url>/2019/11/01/Unity-VEG%E5%AE%9E%E7%8E%B0%E7%83%9F%E8%8A%B1%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次利用VEG实现普通烟花效果。</p>
 <a id="more"></a> 

<h2 id="主粒子"><a href="#主粒子" class="headerlink" title="主粒子"></a>主粒子</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/1.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/2.png" alt></p>
<p>设置主粒子的速度，位置，周期等参数。</p>
<h3 id="Position-Line"><a href="#Position-Line" class="headerlink" title="Position(Line)"></a>Position(Line)</h3><p>用于设置粒子的初始化位置，从Start到End随机生成一个位置点。</p>
<h2 id="烟花粒子"><a href="#烟花粒子" class="headerlink" title="烟花粒子"></a>烟花粒子</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/3.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/4.png" alt></p>
<p>这里利用GPU Event当主粒子消亡时生成新的眼花粒子。</p>
<h3 id="GPU-Event"><a href="#GPU-Event" class="headerlink" title="GPU Event"></a>GPU Event</h3><p> GPU事件由系统在特定条件下触发，并且可以被其他系统捕获以生成新粒子。 可以通过读取Source或使用Inherit Source节点在子系统中访问事件数据。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/5.png" alt></p>
<h2 id="主粒子的拖尾粒子"><a href="#主粒子的拖尾粒子" class="headerlink" title="主粒子的拖尾粒子"></a>主粒子的拖尾粒子</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/6.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/7.png" alt></p>
<h2 id="烟花粒子的拖尾"><a href="#烟花粒子的拖尾" class="headerlink" title="烟花粒子的拖尾"></a>烟花粒子的拖尾</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/8.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/9.png" alt></p>
<p>就这样我们的烟花就完成啦</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/10.png" alt></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/11.png" alt></p>
<p>现在看起来还是有点难看的，但问题不大，给它加点后处理就好了，PostProcessVolume</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/12.png" alt></p>
<p>就这样，好看多了</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/Image/Unity-VEG-Firework/13.png" alt></p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>可能后面还想加点其他的功能，所以未完待续。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>龙卷风Niagara效果</title>
    <url>/2020/11/02/%E9%BE%99%E5%8D%B7%E9%A3%8ENiagara%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>继续Niagara的学习，教程地址：<a href="https://www.youtube.com/watch?v=P9Bk1Ibd0YY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=P9Bk1Ibd0YY</a></p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/%E5%86%B0%E7%81%AB%E9%A3%8E%E6%9A%B4.gif" alt="冰火风暴"></p>
<a id="more"></a>

<h2 id="分析实现点"><a href="#分析实现点" class="headerlink" title="分析实现点"></a>分析实现点</h2><p>1.龙卷风的实现    2.龙卷风吹起来的漩涡石头</p>
<h2 id="龙卷风的实现"><a href="#龙卷风的实现" class="headerlink" title="龙卷风的实现"></a>龙卷风的实现</h2><p>首先需要准备好模型和相对应的贴图，模型为没封盖的圆柱体，贴图R通道是基本色，G通道是噪声图</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023015499.png" alt="image-20201102023015499"></p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023034241.png" alt="image-20201102023034241"></p>
<p>做好龙卷风的基本材质，蓝图系统就这点不好，没办法像代码一样复制粘贴</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023206240.png" alt="image-20201102023206240"></p>
<p>新建一个新的NiagaraSystem，创建Empty发射器。龙卷风最大的特点是下小上大，从底处慢慢升高，可以从这点进行着手。利用Scale Mesh Size完成曲线的从小到大的调整。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023421834.png" alt="image-20201102023421834"></p>
<p>现在我们要完成的就剩下从底升高，同样调整曲线设置粒子的Position达到效果。同时龙卷风还会左右摇摆，我们利用cos和sin在xy方向完成摇摆效果。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023600003.png" alt="image-20201102023600003"></p>
<p>再添加一点小细节，比如龙卷风底部的小漩涡效果和外部的亮度效果</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102023855355.png" alt="image-20201102023855355"></p>
<h2 id="龙卷风吹起来的漩涡石头"><a href="#龙卷风吹起来的漩涡石头" class="headerlink" title="龙卷风吹起来的漩涡石头"></a>龙卷风吹起来的漩涡石头</h2><p>首先我们需要Add Rotational Velocity，因为石头被龙卷风吹起来，肯定是不停地进行旋转的。</p>
<h3 id="Add-Rotational-Velocity"><a href="#Add-Rotational-Velocity" class="headerlink" title="Add Rotational Velocity"></a>Add Rotational Velocity</h3><p>添加旋转加速度，要搭配Add Inital Forces 和 Solve Rotational Forces and Velocity模块使用</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102013736029.png" alt="image-20201102013736029"></p>
<h3 id="Votex-Force"><a href="#Votex-Force" class="headerlink" title="Votex Force"></a>Votex Force</h3><p>漩涡力，一般在粒子更新组里面使用，和其他加速度的模组一起使用会达到漩涡的效果，由Simulation Position升到Vortex Origin漩涡中心，在围绕着漩涡中心四处飘散</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102013130138.png" alt="image-20201102013130138"></p>
<h3 id="Add-Velocity-in-Cone-和-Cylinder-Location"><a href="#Add-Velocity-in-Cone-和-Cylinder-Location" class="headerlink" title="Add Velocity in Cone 和 Cylinder Location"></a>Add Velocity in Cone 和 Cylinder Location</h3><p>最后我们利用Add Velocity in Cone 和Cylinder Location 来完成石头的随机分散和初始随机力。</p>
<p><img src="https://opda-hexo-1300535968.cos.ap-guangzhou.myqcloud.com/markdown/image-20201102024340085.png" alt="image-20201102024340085"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的效果比较简单，只做个人简单的笔记，建议看原油管Up主的视频教程更佳。</p>
]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招总结</title>
    <url>/2020/10/12/%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本科双非，有一段腾讯的暑期实习经历，岗位是TA技术美术，因为实习的时候被深圳的物价和房价给吓到了，再加上家在广州，所以基本目标都在广州的游戏公司，也投了北京上海的游戏公司，原本想拿来练练手的，可能是双非学历再加上简历内容确实不太与游戏行业相关，所以基本石沉大海哈哈哈，根本不给机会</p>
 <a id="more"></a> 

<h2 id="投递公司"><a href="#投递公司" class="headerlink" title="投递公司"></a>投递公司</h2><table>
<thead>
<tr>
<th>公司</th>
<th>进度</th>
</tr>
</thead>
<tbody><tr>
<td>网易互娱</td>
<td>意向书</td>
</tr>
<tr>
<td>诗悦网络</td>
<td>意向书</td>
</tr>
<tr>
<td>多益</td>
<td>意向书</td>
</tr>
<tr>
<td>西山居</td>
<td>通过了面试但还有训练营？？</td>
</tr>
<tr>
<td>4399</td>
<td>笔试完等面试，投得比较晚</td>
</tr>
<tr>
<td>完美世界</td>
<td>简历筛选</td>
</tr>
<tr>
<td>巨人网络</td>
<td>简历筛选</td>
</tr>
<tr>
<td>字节跳动</td>
<td>笔试考算法直接开溜</td>
</tr>
<tr>
<td>百奥</td>
<td>笔试考算法直接开溜</td>
</tr>
<tr>
<td>西山居剑心互娱</td>
<td>笔试之后没消息</td>
</tr>
<tr>
<td>心动网络</td>
<td>笔试挂</td>
</tr>
</tbody></table>
<p>TA这个岗位需求太少了，所以可投公司不多，也算尽自己的努力去得到一个最好的结果了，我其实也没想过一定要去大厂工作，只要是广州就好了。这里吐槽一下，由于TA这个岗位才刚出来，每家公司的招人标准都不一样，腾讯网易需要做测试题，字节百奥需要考算法，心动网络笔试考C++图形学基础，很混乱，导致需要准备很多东西，浪费时间。</p>
<p><strong>吐槽一下字节游戏</strong>，昨天HR还加我微信叫我投简历，第二天就将我简历给挂掉了，就离谱，还叫我转去三维美术。</p>
<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>​    我参加的第一场笔试好像就是心动网络的笔试，那时候我以为TA的笔试大家都一样做做测试题，所以就没有做什么特别准备。我笔试做了30分钟我就做不下去了，考了C++，图形学，1.抗锯齿问题 2.GPU性能问题等等，比较久了有点忘记题目。反正我考完立刻心态崩了，没想到TA笔试还能这样玩，所以我立刻查漏补缺，对我后面影响挺大的。</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>由于时间过了太久了，我记性也不是很好，只记住了一些印象深刻的问题</p>
<h3 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h3><p>​    面试阶段，网易就问了我测试题的细节问题，图形学也没怎么问，可能是因为我春招面试过了的原因吧，就是HR问了我春招为啥去了腾讯没来网易，哈哈哈有点尴尬</p>
<h3 id="诗悦-西山居"><a href="#诗悦-西山居" class="headerlink" title="诗悦 西山居"></a>诗悦 西山居</h3><p>​    这个就比较常规正常点了，诗悦一开头就问了我算法题，我直接放弃思考，然后就问我图形学方面的问题，大概是什么是DrawCall，抗锯齿，PBR相关内容，卡通渲染的要点（主要是我项目写了这个），批处理，基本上是UnityShader入门精要上面的内容，刷一遍就好，幸好图形学加分了，不然我直接GG。</p>
<p>​    西山居问的就比较难了，基本上是根据你简历的内容一直往下问，看到我简历写了PBR，就问我PBR的实现，答完之后问我知道IBL是什么吗？然后知道SDF距离场是什么？一套组合拳直接把我打懵。</p>
<h3 id="多益"><a href="#多益" class="headerlink" title="多益"></a>多益</h3><p>​    面试官直接跟我聊天，问我哪里人，能不能接受加班，HR小姐姐问我有没有女朋友，我说没有，面试官还给我补了一刀：你看他那么宅肯定没有女朋友的啦……</p>
<h2 id="学习历程"><a href="#学习历程" class="headerlink" title="学习历程"></a>学习历程</h2><p><strong>入门书籍</strong>：UnityShader入门精要，3D数学基础，龙书DX11（太厚了，我没看下去，引擎程序员可以看）</p>
<p>C++ Primer（感觉TA不是很看重C++内容，只要基础就行，可以面向面经学习）</p>
<p><strong>视频学习</strong>：GAMES101-现代计算机图形学入门，闫令琪大佬的现代图形学课程（真的非常好，帮我图形学知识重新梳理了一遍）</p>
<p>UE4教程B站杨一鸣大佬视频都挺好的，看着撸一遍，Unity可以看看Siki学院的教程</p>
<p><strong>关于数据结构和算法</strong>，不同公司不同标准，米哈游和字节的TA会考算法，但腾讯网易不会考算法，考测试题，我根本没刷算法题，所以考算法的公司直接开溜不考了，这里还是看要目标公司再决定算法要不要刷，毕竟需要的时间也是要很多的。</p>
<p><strong>TA很需要审美</strong>，毕竟这也跟引擎程序员的最大不同，要做出好看的东西（虽然我做的东西不好看哈哈，春招找实习的时候还被面试官diss），所以我最近买个数位板在学板绘提高审美</p>
<p>最后根据自己兴趣做几个游戏的demo，也可以写个光栅化渲染器（这个一般是引擎程序员干的）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这次秋招我感觉到实习经历非常重要，如果有一个好的大厂经历，秋招真的会好过很多。这里非常感谢我的师兄，如果没有他的分享我铁定今年春招的时候混吃等死，哪里会去找什么暑期实习，那秋招的时候双非学历可能简历都过不了。</p>
<p>​    有了春招的铺垫和历练，秋招就比较容易地过去了（虽然还是很焦虑），也拿到自己想要的offer，希望自己能继续学下去，不再混吃等死吧</p>
<p>​    最后，秋招终于结束辣，可以无忧无虑地看S赛了，LPL加油！</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
</search>
